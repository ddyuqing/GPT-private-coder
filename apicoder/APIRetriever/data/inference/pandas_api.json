{"text_id": 1000000, "text": "release(): Returns the system's release, e."}
{"text_id": 1000001, "text": "count(value, /): Return number of occurrences of value."}
{"text_id": 1000002, "text": "count(value, /): Return number of occurrences of value."}
{"text_id": 1000003, "text": "count(value, /): Return number of occurrences of value."}
{"text_id": 1000004, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000005, "text": "count(self, axis: 'Axis' = 0, level: 'Level | None' = None, numeric_only: 'bool' = False): Count non-NA cells for each column or row."}
{"text_id": 1000006, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000007, "text": "count(value, /): Return number of occurrences of value."}
{"text_id": 1000008, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000009, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000010, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000011, "text": "count(value, /): Return number of occurrences of value."}
{"text_id": 1000012, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000013, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000014, "text": "count(self, value, /): Return number of occurrences of value."}
{"text_id": 1000015, "text": "count(value, /): Return number of occurrences of value."}
{"text_id": 1000016, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000017, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000018, "text": "count(self, level=None): Return number of non-NA/null observations in the Series."}
{"text_id": 1000019, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000020, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000021, "text": "count(self, pat, flags=0): Count occurrences of pattern in each string of the Series/Index."}
{"text_id": 1000022, "text": "count(self, axis: 'Axis' = 0, level: 'Level | None' = None, numeric_only: 'bool' = False): Count non-NA cells for each column or row."}
{"text_id": 1000023, "text": "count(self, value, /): Return number of occurrences of value."}
{"text_id": 1000024, "text": "count(self, level=None): Return number of non-NA/null observations in the Series."}
{"text_id": 1000025, "text": "index(value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000026, "text": "index(value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000027, "text": "index(value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000028, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000029, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000030, "text": "index(value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000031, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000032, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000033, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000034, "text": "index(value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000035, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000036, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000037, "text": "index(self, value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000038, "text": "index(value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000039, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000040, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000041, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000042, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000043, "text": "index(self, sub, start=0, end=None): Return lowest indexes in each string in Series/Index."}
{"text_id": 1000044, "text": "index(self, value, start=0, stop=9223372036854775807, /): Return first index of value."}
{"text_id": 1000045, "text": "get_cache_token(): Returns the current ABC cache token."}
{"text_id": 1000046, "text": "lru_cache(maxsize=128, typed=False): Least-recently-used cache decorator."}
{"text_id": 1000047, "text": "namedtuple(typename, field_names, *, rename=False, defaults=None, module=None): Returns a new subclass of tuple with named fields."}
{"text_id": 1000048, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000049, "text": "func(self) -> 'int': return the size of a single category."}
{"text_id": 1000050, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000051, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000052, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000053, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000054, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000055, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000056, "text": "func(self) -> 'bool': return if I have any nans; enables various perf speedups."}
{"text_id": 1000057, "text": "func(self): Tries to return a string representing a frequency guess, generated by infer_freq."}
{"text_id": 1000058, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000059, "text": "func(self): Returns True if all of the dates are at midnight (\"no time\")."}
{"text_id": 1000060, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000061, "text": "func(self): Returns day, hour, minute, second, millisecond or microsecond."}
{"text_id": 1000062, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000063, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000064, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000065, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000066, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000067, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000068, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000069, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000070, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000071, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000072, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000073, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000074, "text": "func(self) -> 'str_t': Return a string of the type inferred from the values."}
{"text_id": 1000075, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000076, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000077, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000078, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000079, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000080, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000081, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000082, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000083, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000084, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000085, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000086, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000087, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000088, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000089, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000090, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000091, "text": "func(self): Whether the intervals are closed on the left-side, right-side, both or neither."}
{"text_id": 1000092, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000093, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000094, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000095, "text": "func(self) -> 'bool': Return True if the IntervalIndex is monotonic decreasing (only equal or decreasing values), else False."}
{"text_id": 1000096, "text": "func(self): Return True if the IntervalArray is non-overlapping (no Intervals share points) and is either monotonic increasing or monotonic decreasing, else False."}
{"text_id": 1000097, "text": "func(self) -> 'bool': Return True if the IntervalIndex contains unique elements, else False."}
{"text_id": 1000098, "text": "func(self) -> 'Series': Return the dtypes as a Series for the underlying MultiIndex."}
{"text_id": 1000099, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000100, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000101, "text": "func(self) -> 'bool': return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1000102, "text": "func(self) -> 'bool': return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1000103, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000104, "text": "func(self) -> 'int': return the number of bytes in the underlying data."}
{"text_id": 1000105, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000106, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000107, "text": "func(self) -> 'bool': return if I have any nans; enables various perf speedups."}
{"text_id": 1000108, "text": "func(self): Tries to return a string representing a frequency guess, generated by infer_freq."}
{"text_id": 1000109, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000110, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000111, "text": "func(self): Returns day, hour, minute, second, millisecond or microsecond."}
{"text_id": 1000112, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000113, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000114, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000115, "text": "func(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1000116, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000117, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000118, "text": "func(self) -> 'bool': return if I have any nans; enables various perf speedups."}
{"text_id": 1000119, "text": "func(self): Tries to return a string representing a frequency guess, generated by infer_freq."}
{"text_id": 1000120, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000121, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000122, "text": "func(self): Returns day, hour, minute, second, millisecond or microsecond."}
{"text_id": 1000123, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000124, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000125, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000126, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000127, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000128, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000129, "text": "func(self) -> 'ExtensionArray': The ExtensionArray of the data backing this Series or Index."}
{"text_id": 1000130, "text": "func(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1000131, "text": "func(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1000132, "text": "func(self) -> 'bool': Whether or not the index values only consist of dates."}
{"text_id": 1000133, "text": "func(self) -> 'bool': Return if the index has unique values."}
{"text_id": 1000134, "text": "func(self) -> 'int': Return the number of bytes in this dtype."}
{"text_id": 1000135, "text": "func(self) -> 'np.dtype': Return an instance of our numpy dtype."}
{"text_id": 1000136, "text": "partialmethod(func, /, *args, **keywords): Method descriptor with partial application of the given arguments and keywords."}
{"text_id": 1000137, "text": "recursive_repr(fillvalue='...'): Decorator to make a repr function return fillvalue for a recursive call."}
{"text_id": 1000138, "text": "singledispatch(func): Single-dispatch generic function decorator."}
{"text_id": 1000139, "text": "singledispatchmethod(func): Single-dispatch generic method descriptor."}
{"text_id": 1000140, "text": "register(self, cls, method=None): generic_method."}
{"text_id": 1000141, "text": "total_ordering(cls): Class decorator that fills in missing ordering methods."}
{"text_id": 1000142, "text": "update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)): Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools."}
{"text_id": 1000143, "text": "wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)): Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments."}
{"text_id": 1000144, "text": "wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)): Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments."}
{"text_id": 1000145, "text": "BooleanDtype(): Extension dtype for boolean data."}
{"text_id": 1000146, "text": "BooleanDtype(): Extension dtype for boolean data."}
{"text_id": 1000147, "text": "BooleanDtype(): Extension dtype for boolean data."}
{"text_id": 1000148, "text": "BooleanDtype(): Extension dtype for boolean data."}
{"text_id": 1000149, "text": "construct_array_type() -> 'type_t[BooleanArray]': Return the array type associated with this dtype."}
{"text_id": 1000150, "text": "construct_array_type() -> 'type_t[Categorical]': Return the array type associated with this dtype."}
{"text_id": 1000151, "text": "construct_array_type() -> 'type_t[DatetimeArray]': Return the array type associated with this dtype."}
{"text_id": 1000152, "text": "construct_array_type() -> 'type[FloatingArray]': Return the array type associated with this dtype."}
{"text_id": 1000153, "text": "construct_array_type() -> 'type[FloatingArray]': Return the array type associated with this dtype."}
{"text_id": 1000154, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000155, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000156, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000157, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000158, "text": "construct_array_type() -> 'type[IntervalArray]': Return the array type associated with this dtype."}
{"text_id": 1000159, "text": "construct_array_type() -> 'type_t[PeriodArray]': Return the array type associated with this dtype."}
{"text_id": 1000160, "text": "construct_array_type() -> 'type_t[SparseArray]': Return the array type associated with this dtype."}
{"text_id": 1000161, "text": "construct_array_type(self) -> 'type_t[BaseStringArray]': Return the array type associated with this dtype."}
{"text_id": 1000162, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000163, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000164, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000165, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000166, "text": "construct_array_type() -> 'type_t[BooleanArray]': Return the array type associated with this dtype."}
{"text_id": 1000167, "text": "construct_array_type() -> 'type_t[Categorical]': Return the array type associated with this dtype."}
{"text_id": 1000168, "text": "construct_array_type() -> 'type_t[DatetimeArray]': Return the array type associated with this dtype."}
{"text_id": 1000169, "text": "construct_array_type() -> 'type[FloatingArray]': Return the array type associated with this dtype."}
{"text_id": 1000170, "text": "construct_array_type() -> 'type[FloatingArray]': Return the array type associated with this dtype."}
{"text_id": 1000171, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000172, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000173, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000174, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000175, "text": "construct_array_type() -> 'type[IntervalArray]': Return the array type associated with this dtype."}
{"text_id": 1000176, "text": "construct_array_type() -> 'type_t[PeriodArray]': Return the array type associated with this dtype."}
{"text_id": 1000177, "text": "construct_array_type() -> 'type_t[SparseArray]': Return the array type associated with this dtype."}
{"text_id": 1000178, "text": "construct_array_type(self) -> 'type_t[BaseStringArray]': Return the array type associated with this dtype."}
{"text_id": 1000179, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000180, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000181, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000182, "text": "construct_array_type() -> 'type[IntegerArray]': Return the array type associated with this dtype."}
{"text_id": 1000183, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000184, "text": "construct_from_string(string: 'str_type') -> 'CategoricalDtype': Construct a CategoricalDtype from a string."}
{"text_id": 1000185, "text": "construct_from_string(string: 'str_type') -> 'DatetimeTZDtype': Construct a DatetimeTZDtype from a string."}
{"text_id": 1000186, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000187, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000188, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000189, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000190, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000191, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000192, "text": "construct_from_string(string: 'str_type') -> 'IntervalDtype': attempt to construct this type from a string, raise a TypeError if its not possible."}
{"text_id": 1000193, "text": "construct_from_string(string: 'str_type') -> 'PeriodDtype': Strict construction from a string, raise a TypeError if not possible."}
{"text_id": 1000194, "text": "construct_from_string(string: 'str') -> 'SparseDtype': Construct a SparseDtype from a string form."}
{"text_id": 1000195, "text": "construct_from_string(string): Construct a StringDtype from a string."}
{"text_id": 1000196, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000197, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000198, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000199, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000200, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000201, "text": "construct_from_string(string: 'str_type') -> 'CategoricalDtype': Construct a CategoricalDtype from a string."}
{"text_id": 1000202, "text": "construct_from_string(string: 'str_type') -> 'DatetimeTZDtype': Construct a DatetimeTZDtype from a string."}
{"text_id": 1000203, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000204, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000205, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000206, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000207, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000208, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000209, "text": "construct_from_string(string: 'str_type') -> 'IntervalDtype': attempt to construct this type from a string, raise a TypeError if its not possible."}
{"text_id": 1000210, "text": "construct_from_string(string: 'str_type') -> 'PeriodDtype': Strict construction from a string, raise a TypeError if not possible."}
{"text_id": 1000211, "text": "construct_from_string(string: 'str') -> 'SparseDtype': Construct a SparseDtype from a string form."}
{"text_id": 1000212, "text": "construct_from_string(string): Construct a StringDtype from a string."}
{"text_id": 1000213, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000214, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000215, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000216, "text": "construct_from_string(string: 'str'): Construct this type from a string."}
{"text_id": 1000217, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000218, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000219, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000220, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000221, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000222, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000223, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000224, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000225, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000226, "text": "is_dtype(dtype: 'object') -> 'bool': Return a boolean if we if the passed type is an actual dtype that we can match (via string or type)."}
{"text_id": 1000227, "text": "is_dtype(dtype: 'object') -> 'bool': Return a boolean if we if the passed type is an actual dtype that we can match (via string or type)."}
{"text_id": 1000228, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000229, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000230, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000231, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000232, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000233, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000234, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000235, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000236, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000237, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000238, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000239, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000240, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000241, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000242, "text": "is_dtype(dtype: 'object') -> 'bool': Return a boolean if we if the passed type is an actual dtype that we can match (via string or type)."}
{"text_id": 1000243, "text": "is_dtype(dtype: 'object') -> 'bool': Return a boolean if we if the passed type is an actual dtype that we can match (via string or type)."}
{"text_id": 1000244, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000245, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000246, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000247, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000248, "text": "is_dtype(dtype: 'object') -> 'bool': Check if we match 'dtype'."}
{"text_id": 1000249, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000250, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000251, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000252, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000253, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000254, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000255, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000256, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000257, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000258, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000259, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000260, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000261, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000262, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000263, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000264, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000265, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000266, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000267, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000268, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000269, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000270, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000271, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000272, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000273, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000274, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000275, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000276, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000277, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000278, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000279, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000280, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000281, "text": "capitalize(self): Convert strings in the Series/Index to be capitalized."}
{"text_id": 1000282, "text": "capitalize(): Return a capitalized version of the string."}
{"text_id": 1000283, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000284, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000285, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000286, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000287, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000288, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000289, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000290, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000291, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000292, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000293, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000294, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000295, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000296, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000297, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000298, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000299, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000300, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000301, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000302, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000303, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000304, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000305, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000306, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000307, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000308, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000309, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000310, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000311, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000312, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000313, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000314, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000315, "text": "casefold(self): Convert strings in the Series/Index to be casefolded."}
{"text_id": 1000316, "text": "casefold(): Return a version of the string suitable for caseless comparisons."}
{"text_id": 1000317, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000318, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000319, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000320, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000321, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000322, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000323, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000324, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000325, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000326, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000327, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000328, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000329, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000330, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000331, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000332, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000333, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000334, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000335, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000336, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000337, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000338, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000339, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000340, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000341, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000342, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000343, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000344, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000345, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000346, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000347, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000348, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000349, "text": "center(self, width, fillchar=' '): Pad left and right side of strings in the Series/Index."}
{"text_id": 1000350, "text": "center(width, fillchar=' ', /): Return a centered string of length width."}
{"text_id": 1000351, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000352, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000353, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000354, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000355, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000356, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000357, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000358, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000359, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000360, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000361, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000362, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000363, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000364, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000365, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000366, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000367, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000368, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000369, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000370, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000371, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000372, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000373, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000374, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000375, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000376, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000377, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000378, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000379, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000380, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000381, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000382, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000383, "text": "encode(self, encoding, errors='strict'): Encode character string in the Series/Index using indicated encoding."}
{"text_id": 1000384, "text": "encode(encoding='utf-8', errors='strict'): Encode the string using the codec registered for encoding."}
{"text_id": 1000385, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000386, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000387, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000388, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000389, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000390, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000391, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000392, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000393, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000394, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000395, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000396, "text": "endswith(self, pat, na=None): Test if the end of each string element matches a pattern."}
{"text_id": 1000397, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000398, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000399, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000400, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000401, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000402, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000403, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000404, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000405, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000406, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000407, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000408, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000409, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000410, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000411, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000412, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000413, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000414, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000415, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000416, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000417, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000418, "text": "expandtabs(tabsize=8): Return a copy where all tab characters are expanded using spaces."}
{"text_id": 1000419, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000420, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000421, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000422, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000423, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000424, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000425, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000426, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000427, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000428, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000429, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000430, "text": "find(self, sub, start=0, end=None): Return lowest indexes in each strings in the Series/Index."}
{"text_id": 1000431, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000432, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str' = 'NaT', date_format: 'str | None' = None) -> 'list[str]': Render a string representation of the Index."}
{"text_id": 1000433, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000434, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000435, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000436, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000437, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str' = 'NaT', date_format: 'str | None' = None) -> 'list[str]': Render a string representation of the Index."}
{"text_id": 1000438, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000439, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str' = 'NaT', date_format: 'str | None' = None) -> 'list[str]': Render a string representation of the Index."}
{"text_id": 1000440, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000441, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000442, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str' = 'NaT', date_format: 'str | None' = None) -> 'list[str]': Render a string representation of the Index."}
{"text_id": 1000443, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000444, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000445, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000446, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000447, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str' = 'NaT', date_format: 'str | None' = None) -> 'list[str]': Render a string representation of the Index."}
{"text_id": 1000448, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000449, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str' = 'NaT', date_format: 'str | None' = None) -> 'list[str]': Render a string representation of the Index."}
{"text_id": 1000450, "text": "format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index."}
{"text_id": 1000451, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000452, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000453, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000454, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000455, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000456, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000457, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000458, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000459, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000460, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000461, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000462, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000463, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000464, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000465, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000466, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000467, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000468, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000469, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000470, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000471, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000472, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000473, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000474, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000475, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000476, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000477, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000478, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000479, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000480, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000481, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000482, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000483, "text": "isalnum(self): Check whether all characters in each string are alphanumeric."}
{"text_id": 1000484, "text": "isalnum(): Return True if the string is an alpha-numeric string, False otherwise."}
{"text_id": 1000485, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000486, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000487, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000488, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000489, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000490, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000491, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000492, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000493, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000494, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000495, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000496, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000497, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000498, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000499, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000500, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000501, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000502, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000503, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000504, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000505, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000506, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000507, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000508, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000509, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000510, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000511, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000512, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000513, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000514, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000515, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000516, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000517, "text": "isalpha(self): Check whether all characters in each string are alphabetic."}
{"text_id": 1000518, "text": "isalpha(): Return True if the string is an alphabetic string, False otherwise."}
{"text_id": 1000519, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000520, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000521, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000522, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000523, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000524, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000525, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000526, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000527, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000528, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000529, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000530, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000531, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000532, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000533, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000534, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000535, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000536, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000537, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000538, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000539, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000540, "text": "isascii(): Return True if all characters in the string are ASCII, False otherwise."}
{"text_id": 1000541, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000542, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000543, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000544, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000545, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000546, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000547, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000548, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000549, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000550, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000551, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000552, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000553, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000554, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000555, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000556, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000557, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000558, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000559, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000560, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000561, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000562, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000563, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000564, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000565, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000566, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000567, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000568, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000569, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000570, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000571, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000572, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000573, "text": "isdecimal(self): Check whether all characters in each string are decimal."}
{"text_id": 1000574, "text": "isdecimal(): Return True if the string is a decimal string, False otherwise."}
{"text_id": 1000575, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000576, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000577, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000578, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000579, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000580, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000581, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000582, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000583, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000584, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000585, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000586, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000587, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000588, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000589, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000590, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000591, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000592, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000593, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000594, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000595, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000596, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000597, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000598, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000599, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000600, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000601, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000602, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000603, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000604, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000605, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000606, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000607, "text": "isdigit(self): Check whether all characters in each string are digits."}
{"text_id": 1000608, "text": "isdigit(): Return True if the string is a digit string, False otherwise."}
{"text_id": 1000609, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000610, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000611, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000612, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000613, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000614, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000615, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000616, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000617, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000618, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000619, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000620, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000621, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000622, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000623, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000624, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000625, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000626, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000627, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000628, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000629, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000630, "text": "isidentifier(): Return True if the string is a valid Python identifier, False otherwise."}
{"text_id": 1000631, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000632, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000633, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000634, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000635, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000636, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000637, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000638, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000639, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000640, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000641, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000642, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000643, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000644, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000645, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000646, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000647, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000648, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000649, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000650, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000651, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000652, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000653, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000654, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000655, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000656, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000657, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000658, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000659, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000660, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000661, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000662, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000663, "text": "islower(self): Check whether all characters in each string are lowercase."}
{"text_id": 1000664, "text": "islower(): Return True if the string is a lowercase string, False otherwise."}
{"text_id": 1000665, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000666, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000667, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000668, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000669, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000670, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000671, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000672, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000673, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000674, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000675, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000676, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000677, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000678, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000679, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000680, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000681, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000682, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000683, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000684, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000685, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000686, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000687, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000688, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000689, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000690, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000691, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000692, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000693, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000694, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000695, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000696, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000697, "text": "isnumeric(self): Check whether all characters in each string are numeric."}
{"text_id": 1000698, "text": "isnumeric(): Return True if the string is a numeric string, False otherwise."}
{"text_id": 1000699, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000700, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000701, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000702, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000703, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000704, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000705, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000706, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000707, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000708, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000709, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000710, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000711, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000712, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000713, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000714, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000715, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000716, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000717, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000718, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000719, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000720, "text": "isprintable(): Return True if the string is printable, False otherwise."}
{"text_id": 1000721, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000722, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000723, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000724, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000725, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000726, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000727, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000728, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000729, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000730, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000731, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000732, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000733, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000734, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000735, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000736, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000737, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000738, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000739, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000740, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000741, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000742, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000743, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000744, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000745, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000746, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000747, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000748, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000749, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000750, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000751, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000752, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000753, "text": "isspace(self): Check whether all characters in each string are whitespace."}
{"text_id": 1000754, "text": "isspace(): Return True if the string is a whitespace string, False otherwise."}
{"text_id": 1000755, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000756, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000757, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000758, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000759, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000760, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000761, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000762, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000763, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000764, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000765, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000766, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000767, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000768, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000769, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000770, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000771, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000772, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000773, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000774, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000775, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000776, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000777, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000778, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000779, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000780, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000781, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000782, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000783, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000784, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000785, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000786, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000787, "text": "istitle(self): Check whether all characters in each string are titlecase."}
{"text_id": 1000788, "text": "istitle(): Return True if the string is a title-cased string, False otherwise."}
{"text_id": 1000789, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000790, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000791, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000792, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000793, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000794, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000795, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000796, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000797, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000798, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000799, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000800, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000801, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000802, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000803, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000804, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000805, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000806, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000807, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000808, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000809, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000810, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000811, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000812, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000813, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000814, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000815, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000816, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000817, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000818, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000819, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000820, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000821, "text": "isupper(self): Check whether all characters in each string are uppercase."}
{"text_id": 1000822, "text": "isupper(): Return True if the string is an uppercase string, False otherwise."}
{"text_id": 1000823, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000824, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000825, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000826, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000827, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000828, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000829, "text": "join(self, other: 'FrameOrSeriesUnion', on: 'IndexLabel | None' = None, how: 'str' = 'left', lsuffix: 'str' = '', rsuffix: 'str' = '', sort: 'bool' = False) -> 'DataFrame': Join columns of another DataFrame."}
{"text_id": 1000830, "text": "join(self, other, how: 'str' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): See Index."}
{"text_id": 1000831, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000832, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000833, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000834, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000835, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000836, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000837, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000838, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000839, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000840, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000841, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000842, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000843, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000844, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000845, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000846, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000847, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000848, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000849, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000850, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000851, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000852, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000853, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000854, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000855, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000856, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000857, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000858, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000859, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000860, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000861, "text": "join(self, other, how: 'str' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): See Index."}
{"text_id": 1000862, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000863, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000864, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000865, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000866, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000867, "text": "join(self, sep): Join lists contained as elements in the Series/Index with passed delimiter."}
{"text_id": 1000868, "text": "join(iterable, /): Concatenate any number of strings."}
{"text_id": 1000869, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000870, "text": "join(self, other: 'FrameOrSeriesUnion', on: 'IndexLabel | None' = None, how: 'str' = 'left', lsuffix: 'str' = '', rsuffix: 'str' = '', sort: 'bool' = False) -> 'DataFrame': Join columns of another DataFrame."}
{"text_id": 1000871, "text": "join(self, other, how: 'str' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): See Index."}
{"text_id": 1000872, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000873, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000874, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000875, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000876, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000877, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000878, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000879, "text": "join(self, other, how: 'str' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): See Index."}
{"text_id": 1000880, "text": "join(self, other, how: 'str_t' = 'left', level=None, return_indexers: 'bool' = False, sort: 'bool' = False): Compute join_index and indexers to conform data structures to the new index."}
{"text_id": 1000881, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000882, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000883, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000884, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000885, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000886, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000887, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000888, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000889, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000890, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000891, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000892, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000893, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000894, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000895, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000896, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000897, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000898, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000899, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000900, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000901, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000902, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000903, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000904, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000905, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000906, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000907, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000908, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000909, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000910, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000911, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000912, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000913, "text": "ljust(self, width, fillchar=' '): Pad right side of strings in the Series/Index."}
{"text_id": 1000914, "text": "ljust(width, fillchar=' ', /): Return a left-justified string of length width."}
{"text_id": 1000915, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000916, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000917, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000918, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000919, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000920, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000921, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000922, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000923, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000924, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000925, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000926, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000927, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000928, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000929, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000930, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000931, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000932, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000933, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000934, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000935, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000936, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000937, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000938, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000939, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000940, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000941, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000942, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000943, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000944, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000945, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000946, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000947, "text": "lower(self): Convert strings in the Series/Index to lowercase."}
{"text_id": 1000948, "text": "lower(): Return a copy of the string converted to lowercase."}
{"text_id": 1000949, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000950, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000951, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000952, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000953, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000954, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000955, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000956, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000957, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000958, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000959, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000960, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000961, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000962, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000963, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000964, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000965, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000966, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000967, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000968, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000969, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000970, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000971, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000972, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000973, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000974, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000975, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000976, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000977, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000978, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000979, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000980, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000981, "text": "lstrip(self, to_strip=None): Remove leading characters."}
{"text_id": 1000982, "text": "lstrip(chars=None, /): Return a copy of the string with leading whitespace removed."}
{"text_id": 1000983, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000984, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000985, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000986, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000987, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1000988, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1000989, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000990, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000991, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000992, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000993, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1000994, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1000995, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000996, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000997, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1000998, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1000999, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001000, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001001, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001002, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001003, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1001004, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1001005, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001006, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001007, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1001008, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1001009, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1001010, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001011, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1001012, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001013, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001014, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001015, "text": "partition(self, sep=' ', expand=True): Split the string at the first occurrence of `sep`."}
{"text_id": 1001016, "text": "partition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001017, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001018, "text": "replace(self, to_replace, value, inplace: 'bool' = False): Replaces all instances of one value with another."}
{"text_id": 1001019, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001020, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001021, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001022, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001023, "text": "replace(self, to_replace=None, value=None, inplace: 'bool' = False, limit=None, regex: 'bool' = False, method: 'str' = 'pad'): Replace values given in `to_replace` with `value`."}
{"text_id": 1001024, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001025, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001026, "text": "replace(*args, **kwargs): Implements datetime."}
{"text_id": 1001027, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001028, "text": "replace(self, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=<class 'object'>, fold=None): Implements datetime."}
{"text_id": 1001029, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001030, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001031, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001032, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001033, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001034, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001035, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001036, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001037, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001038, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001039, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001040, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001041, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001042, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001043, "text": "replace(*args, **kwargs): Implements datetime."}
{"text_id": 1001044, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001045, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001046, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001047, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001048, "text": "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad'): Replace values given in `to_replace` with `value`."}
{"text_id": 1001049, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001050, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001051, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001052, "text": "replace(year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=<class 'object'>, fold=None): Implements datetime."}
{"text_id": 1001053, "text": "replace(year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=<class 'object'>, fold=None): Implements datetime."}
{"text_id": 1001054, "text": "replace(self, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=<class 'object'>, fold=None): Implements datetime."}
{"text_id": 1001055, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001056, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001057, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001058, "text": "replace(self, pat: 'str | re.Pattern', repl: 'str | Callable', n: 'int' = -1, case: 'bool | None' = None, flags: 'int' = 0, regex: 'bool | None' = None): Replace each occurrence of pattern/regex in the Series/Index."}
{"text_id": 1001059, "text": "replace(old, new, count=-1, /): Return a copy with all occurrences of substring old replaced by new."}
{"text_id": 1001060, "text": "replace(self, to_replace, value, inplace: 'bool' = False): Replaces all instances of one value with another."}
{"text_id": 1001061, "text": "replace(self, to_replace, value, inplace: 'bool' = False): Replaces all instances of one value with another."}
{"text_id": 1001062, "text": "replace(self, to_replace=None, value=None, inplace: 'bool' = False, limit=None, regex: 'bool' = False, method: 'str' = 'pad'): Replace values given in `to_replace` with `value`."}
{"text_id": 1001063, "text": "replace(*args, **kwargs): Implements datetime."}
{"text_id": 1001064, "text": "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad'): Replace values given in `to_replace` with `value`."}
{"text_id": 1001065, "text": "replace(self, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=<class 'object'>, fold=None): Implements datetime."}
{"text_id": 1001066, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001067, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001068, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001069, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001070, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001071, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001072, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001073, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001074, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001075, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001076, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001077, "text": "rfind(self, sub, start=0, end=None): Return highest indexes in each strings in the Series/Index."}
{"text_id": 1001078, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001079, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001080, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001081, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001082, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001083, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001084, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001085, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001086, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001087, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001088, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001089, "text": "rindex(self, sub, start=0, end=None): Return highest indexes in each string in Series/Index."}
{"text_id": 1001090, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001091, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001092, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001093, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001094, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001095, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001096, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001097, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001098, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001099, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001100, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001101, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001102, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001103, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001104, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001105, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001106, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001107, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001108, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001109, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001110, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001111, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001112, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001113, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001114, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001115, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001116, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001117, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001118, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001119, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001120, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001121, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001122, "text": "rjust(self, width, fillchar=' '): Pad left side of strings in the Series/Index."}
{"text_id": 1001123, "text": "rjust(width, fillchar=' ', /): Return a right-justified string of length width."}
{"text_id": 1001124, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001125, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001126, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001127, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001128, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001129, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001130, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001131, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001132, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001133, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001134, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001135, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001136, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001137, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001138, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001139, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001140, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001141, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001142, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001143, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001144, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001145, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001146, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001147, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001148, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001149, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001150, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001151, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001152, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001153, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001154, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001155, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001156, "text": "rpartition(self, sep=' ', expand=True): Split the string at the last occurrence of `sep`."}
{"text_id": 1001157, "text": "rpartition(sep, /): Partition the string into three parts using the given separator."}
{"text_id": 1001158, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001159, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001160, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001161, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001162, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001163, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001164, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001165, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001166, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001167, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001168, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001169, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001170, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001171, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001172, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001173, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001174, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001175, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001176, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001177, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001178, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001179, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001180, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001181, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001182, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001183, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001184, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001185, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001186, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001187, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001188, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001189, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001190, "text": "rsplit(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001191, "text": "rsplit(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001192, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001193, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001194, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001195, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001196, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001197, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001198, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001199, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001200, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001201, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001202, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001203, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001204, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001205, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001206, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001207, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001208, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001209, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001210, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001211, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001212, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001213, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001214, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001215, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001216, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001217, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001218, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001219, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001220, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001221, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001222, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001223, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001224, "text": "rstrip(self, to_strip=None): Remove trailing characters."}
{"text_id": 1001225, "text": "rstrip(chars=None, /): Return a copy of the string with trailing whitespace removed."}
{"text_id": 1001226, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001227, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001228, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001229, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001230, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001231, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001232, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001233, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001234, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001235, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001236, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001237, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001238, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001239, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001240, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001241, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001242, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001243, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001244, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001245, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001246, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001247, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001248, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001249, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001250, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001251, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001252, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001253, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001254, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001255, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001256, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001257, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001258, "text": "split(self, pat=None, n=-1, expand=False): Split strings around given separator/delimiter."}
{"text_id": 1001259, "text": "split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string."}
{"text_id": 1001260, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001261, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001262, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001263, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001264, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001265, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001266, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001267, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001268, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001269, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001270, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001271, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001272, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001273, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001274, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001275, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001276, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001277, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001278, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001279, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001280, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001281, "text": "splitlines(keepends=False): Return a list of the lines in the string, breaking at line boundaries."}
{"text_id": 1001282, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001283, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001284, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001285, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001286, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001287, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001288, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001289, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001290, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001291, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001292, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001293, "text": "startswith(self, pat, na=None): Test if the start of each string element matches a pattern."}
{"text_id": 1001294, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001295, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001296, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001297, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001298, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001299, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001300, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001301, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001302, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001303, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001304, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001305, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001306, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001307, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001308, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001309, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001310, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001311, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001312, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001313, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001314, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001315, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001316, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001317, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001318, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001319, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001320, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001321, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001322, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001323, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001324, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001325, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001326, "text": "strip(self, to_strip=None): Remove leading and trailing characters."}
{"text_id": 1001327, "text": "strip(chars=None, /): Return a copy of the string with leading and trailing whitespace removed."}
{"text_id": 1001328, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001329, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001330, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001331, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001332, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001333, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001334, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001335, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001336, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001337, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001338, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001339, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001340, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001341, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001342, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001343, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001344, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001345, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001346, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001347, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001348, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001349, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001350, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001351, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001352, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001353, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001354, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001355, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001356, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001357, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001358, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001359, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001360, "text": "swapcase(self): Convert strings in the Series/Index to be swapcased."}
{"text_id": 1001361, "text": "swapcase(): Convert uppercase characters to lowercase and lowercase characters to uppercase."}
{"text_id": 1001362, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001363, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001364, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001365, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001366, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001367, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001368, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001369, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001370, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001371, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001372, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001373, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001374, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001375, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001376, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001377, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001378, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001379, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001380, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001381, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001382, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001383, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001384, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001385, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001386, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001387, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001388, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001389, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001390, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001391, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001392, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001393, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001394, "text": "title(self): Convert strings in the Series/Index to titlecase."}
{"text_id": 1001395, "text": "title(): Return a version of the string where each word is titlecased."}
{"text_id": 1001396, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001397, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001398, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001399, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001400, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001401, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001402, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001403, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001404, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001405, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001406, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001407, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001408, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001409, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001410, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001411, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001412, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001413, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001414, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001415, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001416, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001417, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001418, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001419, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001420, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001421, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001422, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001423, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001424, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001425, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001426, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001427, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001428, "text": "translate(self, table): Map all characters in the string through the given mapping table."}
{"text_id": 1001429, "text": "translate(table, /): Replace each character in the string using the given translation table."}
{"text_id": 1001430, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001431, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001432, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001433, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001434, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001435, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001436, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001437, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001438, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001439, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001440, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001441, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001442, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001443, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001444, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001445, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001446, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001447, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001448, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001449, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001450, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001451, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001452, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001453, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001454, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001455, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001456, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001457, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001458, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001459, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001460, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001461, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001462, "text": "upper(self): Convert strings in the Series/Index to uppercase."}
{"text_id": 1001463, "text": "upper(): Return a copy of the string converted to uppercase."}
{"text_id": 1001464, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001465, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001466, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001467, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001468, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001469, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001470, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001471, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001472, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001473, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001474, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001475, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001476, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001477, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001478, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001479, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001480, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001481, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001482, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001483, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001484, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001485, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001486, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001487, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001488, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001489, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001490, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001491, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001492, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001493, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001494, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001495, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001496, "text": "zfill(self, width): Pad strings in the Series/Index by prepending '0' characters."}
{"text_id": 1001497, "text": "zfill(width, /): Pad a numeric string with zeros on the left, to fill a field of the given width."}
{"text_id": 1001498, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001499, "text": "fget(self): The categories of this categorical."}
{"text_id": 1001500, "text": "fget(self) -> 'np.ndarray': The category codes of this categorical."}
{"text_id": 1001501, "text": "fget(self) -> 'CategoricalDtype': The :class:`~pandas."}
{"text_id": 1001502, "text": "fget(self) -> 'Ordered': Whether the categories have an ordered relationship."}
{"text_id": 1001503, "text": "fget(self) -> 'Index': An ``Index`` containing the unique categories allowed."}
{"text_id": 1001504, "text": "fget(self) -> 'object': Default NA value to use for this type."}
{"text_id": 1001505, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001506, "text": "fget(self) -> 'Ordered': Whether the categories have an ordered relationship."}
{"text_id": 1001507, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001508, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001509, "text": "fget(self): The categories of this categorical."}
{"text_id": 1001510, "text": "fget(self): The category codes of this categorical."}
{"text_id": 1001511, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001512, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001513, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001514, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001515, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001516, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001517, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001518, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001519, "text": "fget(self): Whether the categories have an ordered relationship."}
{"text_id": 1001520, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001521, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001522, "text": "fget(self) -> 'ArrayLike': Return an array representing the data in the Index."}
{"text_id": 1001523, "text": "fget(self) -> '_AtIndexer': Access a single value for a row/column label pair."}
{"text_id": 1001524, "text": "fget(self) -> 'dict[Hashable, Any]': Dictionary of global attributes of this dataset."}
{"text_id": 1001525, "text": "fget(self) -> 'list[Index]': Return a list representing the axes of the DataFrame."}
{"text_id": 1001526, "text": "fget(self): Return the dtypes in the DataFrame."}
{"text_id": 1001527, "text": "fget(self) -> 'bool_t': Indicator whether DataFrame is empty."}
{"text_id": 1001528, "text": "fget(self) -> 'Flags': Get the properties associated with this pandas object."}
{"text_id": 1001529, "text": "fget(self) -> '_iAtIndexer': Access a single value for a row/column pair by integer position."}
{"text_id": 1001530, "text": "fget(self) -> '_iLocIndexer': Purely integer-location based indexing for selection by position."}
{"text_id": 1001531, "text": "fget(self) -> '_LocIndexer': Access a group of rows and columns by label(s) or a boolean array."}
{"text_id": 1001532, "text": "fget(self) -> 'int': Return an int representing the number of axes / array dimensions."}
{"text_id": 1001533, "text": "fget(self) -> 'tuple[int, int]': Return a tuple representing the dimensionality of the DataFrame."}
{"text_id": 1001534, "text": "fget(self) -> 'int': Return an int representing the number of elements in this object."}
{"text_id": 1001535, "text": "fget(self) -> 'Styler': Returns a Styler object."}
{"text_id": 1001536, "text": "fget(self) -> 'np.ndarray': Return a Numpy representation of the DataFrame."}
{"text_id": 1001537, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001538, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001539, "text": "fget(self): Returns numpy array of python datetime."}
{"text_id": 1001540, "text": "fget(self): The day of the datetime."}
{"text_id": 1001541, "text": "fget(self): The day of the week with Monday=0, Sunday=6."}
{"text_id": 1001542, "text": "fget(self): The ordinal day of the year."}
{"text_id": 1001543, "text": "fget(self): The day of the week with Monday=0, Sunday=6."}
{"text_id": 1001544, "text": "fget(self): The ordinal day of the year."}
{"text_id": 1001545, "text": "fget(self): The number of days in the month."}
{"text_id": 1001546, "text": "fget(self): The number of days in the month."}
{"text_id": 1001547, "text": "fget(self): The dtype for the DatetimeArray."}
{"text_id": 1001548, "text": "fget(self): Return the frequency object if it is set, otherwise None."}
{"text_id": 1001549, "text": "fget(self): Return the frequency object as a string if its set, otherwise None."}
{"text_id": 1001550, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001551, "text": "fget(self): The hours of the datetime."}
{"text_id": 1001552, "text": "fget(self): Boolean indicator if the date belongs to a leap year."}
{"text_id": 1001553, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001554, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001555, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001556, "text": "fget(self): Indicates whether the date is the last day of the month."}
{"text_id": 1001557, "text": "fget(self): Indicates whether the date is the first day of the month."}
{"text_id": 1001558, "text": "fget(self): Indicator for whether the date is the last day of a quarter."}
{"text_id": 1001559, "text": "fget(self): Indicator for whether the date is the first day of a quarter."}
{"text_id": 1001560, "text": "fget(self): Indicate whether the date is the last day of the year."}
{"text_id": 1001561, "text": "fget(self): Indicate whether the date is the first day of a year."}
{"text_id": 1001562, "text": "fget(self): The microseconds of the datetime."}
{"text_id": 1001563, "text": "fget(self): The minutes of the datetime."}
{"text_id": 1001564, "text": "fget(self): The month as January=1, December=12."}
{"text_id": 1001565, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001566, "text": "fget(self): The nanoseconds of the datetime."}
{"text_id": 1001567, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001568, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001569, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001570, "text": "fget(self): The quarter of the date."}
{"text_id": 1001571, "text": "fget(self): The seconds of the datetime."}
{"text_id": 1001572, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001573, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001574, "text": "fget(self): Returns numpy array of datetime."}
{"text_id": 1001575, "text": "fget(self): Returns numpy array of datetime."}
{"text_id": 1001576, "text": "fget(self): Return timezone, if any."}
{"text_id": 1001577, "text": "fget(self): Alias for tz attribute."}
{"text_id": 1001578, "text": "fget(self): The week ordinal of the year."}
{"text_id": 1001579, "text": "fget(self): The day of the week with Monday=0, Sunday=6."}
{"text_id": 1001580, "text": "fget(self): The week ordinal of the year."}
{"text_id": 1001581, "text": "fget(self): The year of the datetime."}
{"text_id": 1001582, "text": "fget(self) -> 'str_type': A string representation of the dtype."}
{"text_id": 1001583, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001584, "text": "fget(self) -> 'tzinfo': The timezone."}
{"text_id": 1001585, "text": "fget(self) -> 'str_type': The precision of the datetime data."}
{"text_id": 1001586, "text": "fget(self): Name of engine."}
{"text_id": 1001587, "text": "fget(self): Extensions that writer engine supports."}
{"text_id": 1001588, "text": "fget(self) -> bool: Whether this object allows duplicate labels."}
{"text_id": 1001589, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001590, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001591, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001592, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001593, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001594, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001595, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001596, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001597, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001598, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001599, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001600, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001601, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001602, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001603, "text": "fget(self) -> 'ArrayLike': Return an array representing the data in the Index."}
{"text_id": 1001604, "text": "fget(self) -> 'bool': return a boolean indicating whether the file is open."}
{"text_id": 1001605, "text": "fget(self): return the root node."}
{"text_id": 1001606, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001607, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001608, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001609, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001610, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001611, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001612, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001613, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001614, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001615, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001616, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001617, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001618, "text": "fget(self) -> 'ArrayLike': Return an array representing the data in the Index."}
{"text_id": 1001619, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001620, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001621, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001622, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001623, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001624, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001625, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001626, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001627, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001628, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001629, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001630, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001631, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001632, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001633, "text": "fget(self) -> 'ArrayLike': Return an array representing the data in the Index."}
{"text_id": 1001634, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001635, "text": "fget(self) -> 'object': Default NA value to use for this type."}
{"text_id": 1001636, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001637, "text": "fget(self): The dtype of the Interval bounds."}
{"text_id": 1001638, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001639, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001640, "text": "fget(self): Check if the interval is closed on the left side."}
{"text_id": 1001641, "text": "fget(self): Check if the interval is closed on the right side."}
{"text_id": 1001642, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001643, "text": "fget(self) -> 'str': Return a string of the type inferred from the values."}
{"text_id": 1001644, "text": "fget(self): Indicates if an interval is empty, meaning it contains no points."}
{"text_id": 1001645, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001646, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001647, "text": "fget(self) -> 'bool': Return True if the IntervalIndex has overlapping intervals, else False."}
{"text_id": 1001648, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001649, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001650, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001651, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001652, "text": "fget(self): Check if the interval is open on the left side."}
{"text_id": 1001653, "text": "fget(self): Check if the interval is open on the right side."}
{"text_id": 1001654, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001655, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001656, "text": "fget(self) -> 'ArrayLike': Return an array representing the data in the Index."}
{"text_id": 1001657, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001658, "text": "fget(self): Raises a ValueError for `MultiIndex` because there's no single array backing a MultiIndex."}
{"text_id": 1001659, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001660, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001661, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001662, "text": "fget(self) -> 'Shape': A tuple with the length of each level."}
{"text_id": 1001663, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001664, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001665, "text": "fget(self) -> 'int': Integer number of levels in this MultiIndex."}
{"text_id": 1001666, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001667, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001668, "text": "fget(self): The frequency object of this PeriodDtype."}
{"text_id": 1001669, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001670, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001671, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001672, "text": "fget(self): The days of the period."}
{"text_id": 1001673, "text": "fget(self): The day of the week with Monday=0, Sunday=6."}
{"text_id": 1001674, "text": "fget(self): The ordinal day of the year."}
{"text_id": 1001675, "text": "fget(self): The day of the week with Monday=0, Sunday=6."}
{"text_id": 1001676, "text": "fget(self): The ordinal day of the year."}
{"text_id": 1001677, "text": "fget(self): The number of days in the month."}
{"text_id": 1001678, "text": "fget(self): The number of days in the month."}
{"text_id": 1001679, "text": "fget(self): Return the frequency object if it is set, otherwise None."}
{"text_id": 1001680, "text": "fget(self): Return the frequency object as a string if its set, otherwise None."}
{"text_id": 1001681, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001682, "text": "fget(self): The hour of the period."}
{"text_id": 1001683, "text": "fget(self) -> 'bool': Returns True if this PeriodIndex is range-like in that all Periods between start and end are present, in order."}
{"text_id": 1001684, "text": "fget(self): Logical indicating if the date belongs to a leap year."}
{"text_id": 1001685, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001686, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001687, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001688, "text": "fget(self): The minute of the period."}
{"text_id": 1001689, "text": "fget(self): The month as January=1, December=12."}
{"text_id": 1001690, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001691, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001692, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001693, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001694, "text": "fget(self): The quarter of the date."}
{"text_id": 1001695, "text": "fget(self): The second of the period."}
{"text_id": 1001696, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001697, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001698, "text": "fget(self): The week ordinal of the year."}
{"text_id": 1001699, "text": "fget(self): The day of the week with Monday=0, Sunday=6."}
{"text_id": 1001700, "text": "fget(self): The week ordinal of the year."}
{"text_id": 1001701, "text": "fget(self): The year of the period."}
{"text_id": 1001702, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001703, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001704, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001705, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001706, "text": "fget(self) -> 'bool': return if the index has unique values."}
{"text_id": 1001707, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001708, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001709, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001710, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001711, "text": "fget(self) -> 'int': The value of the `start` parameter (``0`` if this was not supplied)."}
{"text_id": 1001712, "text": "fget(self) -> 'int': The value of the `step` parameter (``1`` if this was not supplied)."}
{"text_id": 1001713, "text": "fget(self) -> 'int': The value of the `stop` parameter."}
{"text_id": 1001714, "text": "fget(self) -> 'ArrayLike': Return an array representing the data in the Index."}
{"text_id": 1001715, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001716, "text": "fget(self) -> '_AtIndexer': Access a single value for a row/column label pair."}
{"text_id": 1001717, "text": "fget(self) -> 'dict[Hashable, Any]': Dictionary of global attributes of this dataset."}
{"text_id": 1001718, "text": "fget(self) -> 'list[Index]': Return a list of the row axis labels."}
{"text_id": 1001719, "text": "fget(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1001720, "text": "fget(self) -> 'DtypeObj': Return the dtype object of the underlying data."}
{"text_id": 1001721, "text": "fget(self) -> 'Flags': Get the properties associated with this pandas object."}
{"text_id": 1001722, "text": "fget(self) -> 'bool': Return if I have any nans; enables various perf speedups."}
{"text_id": 1001723, "text": "fget(self) -> '_iAtIndexer': Access a single value for a row/column pair by integer position."}
{"text_id": 1001724, "text": "fget(self) -> '_iLocIndexer': Purely integer-location based indexing for selection by position."}
{"text_id": 1001725, "text": "fget(self) -> 'bool': Return boolean if values in the object are monotonic_increasing."}
{"text_id": 1001726, "text": "fget(self) -> 'bool': Return boolean if values in the object are monotonic_decreasing."}
{"text_id": 1001727, "text": "fget(self) -> 'bool': Alias for is_monotonic."}
{"text_id": 1001728, "text": "fget(self) -> 'bool': Return boolean if values in the object are unique."}
{"text_id": 1001729, "text": "fget(self) -> '_LocIndexer': Access a group of rows and columns by label(s) or a boolean array."}
{"text_id": 1001730, "text": "fget(self) -> 'Hashable': Return the name of the Series."}
{"text_id": 1001731, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001732, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001733, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001734, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001735, "text": "fget(self): Return Series as ndarray or ndarray-like depending on the dtype."}
{"text_id": 1001736, "text": "fget(self): The fill value of the array."}
{"text_id": 1001737, "text": "fget(self): The sparse kind."}
{"text_id": 1001738, "text": "fget(self) -> 'object': Default NA value to use for this type."}
{"text_id": 1001739, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001740, "text": "fget(self) -> 'str': A character code (one of 'biufcmMOSUV'), default 'O' This should match the NumPy dtype used when the array is converted to an ndarray, which is probably 'O' for object if the extension type cannot be represented as a built-in NumPy type."}
{"text_id": 1001741, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001742, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001743, "text": "fget(self): Integer representation of the values."}
{"text_id": 1001744, "text": "fget(self): Return a dataframe of the components (days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) of the Timedeltas."}
{"text_id": 1001745, "text": "fget(self): Number of days for each element."}
{"text_id": 1001746, "text": "fget(self): Return the frequency object if it is set, otherwise None."}
{"text_id": 1001747, "text": "fget(self): Return the frequency object as a string if its set, otherwise None."}
{"text_id": 1001748, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001749, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001750, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001751, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001752, "text": "fget(self): Number of microseconds (>= 0 and less than 1 second) for each element."}
{"text_id": 1001753, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001754, "text": "fget(self): Number of nanoseconds (>= 0 and less than 1 microsecond) for each element."}
{"text_id": 1001755, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001756, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001757, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001758, "text": "fget(self): Number of seconds (>= 0 and less than 1 day) for each element."}
{"text_id": 1001759, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001760, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001761, "text": "fget(self): Return the total number of days in the month."}
{"text_id": 1001762, "text": "fget(self): Alias for tzinfo."}
{"text_id": 1001763, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001764, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001765, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001766, "text": "fget(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1001767, "text": "fget(self) -> 'bool': Check if the Index has duplicate values."}
{"text_id": 1001768, "text": "fget(self) -> 'bool': Alias for is_monotonic_increasing."}
{"text_id": 1001769, "text": "fget(self) -> 'bool': Return if the index is monotonic decreasing (only equal or decreasing) values."}
{"text_id": 1001770, "text": "fget(self) -> 'bool': Return if the index is monotonic increasing (only equal or increasing) values."}
{"text_id": 1001771, "text": "fget(self): Return Index or MultiIndex name."}
{"text_id": 1001772, "text": "fget(self) -> 'int': Return the number of bytes in the underlying data."}
{"text_id": 1001773, "text": "fget(self) -> 'int': Number of dimensions of the underlying data, by definition 1."}
{"text_id": 1001774, "text": "fget(self) -> 'int': Number of levels."}
{"text_id": 1001775, "text": "fget(self) -> 'Shape': Return a tuple of the shape of the underlying data."}
{"text_id": 1001776, "text": "fget(self) -> 'int': Return the number of elements in the underlying data."}
{"text_id": 1001777, "text": "fget(self) -> 'ArrayLike': Return an array representing the data in the Index."}
{"text_id": 1001778, "text": "fget(self) -> 'list[str] | None': Ordered list of field names, or None if there are no fields."}
{"text_id": 1001779, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001780, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001781, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001782, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001783, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001784, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001785, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001786, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001787, "text": "Categorical(values, categories=None, ordered=None, dtype: 'Dtype | None' = None, fastpath=False, copy: 'bool' = True): Represent a categorical variable in classic R / S-plus fashion."}
{"text_id": 1001788, "text": "add_categories(self, new_categories, inplace=<no_default>): Add new categories."}
{"text_id": 1001789, "text": "add_categories(self, *args, **kwargs): Add new categories."}
{"text_id": 1001790, "text": "add_categories(self, *args, **kwargs): Add new categories."}
{"text_id": 1001791, "text": "add_categories(self, new_categories, inplace=<no_default>): Add new categories."}
{"text_id": 1001792, "text": "add_categories(self, new_categories, inplace=<no_default>): Add new categories."}
{"text_id": 1001793, "text": "add_categories(self, *args, **kwargs): Add new categories."}
{"text_id": 1001794, "text": "argsort(self, ascending=True, kind='quicksort', **kwargs): Return the indices that would sort the Categorical."}
{"text_id": 1001795, "text": "argsort(self, *args, **kwargs): Return the indices that would sort the Categorical."}
{"text_id": 1001796, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001797, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001798, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001799, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001800, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001801, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001802, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Returns the indices that would sort the index and its underlying data."}
{"text_id": 1001803, "text": "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series': Return the integer indices that would sort the Series values."}
{"text_id": 1001804, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001805, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001806, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001807, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001808, "text": "argsort(self, ascending=True, kind='quicksort', **kwargs): Return the indices that would sort the Categorical."}
{"text_id": 1001809, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001810, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001811, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001812, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001813, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001814, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001815, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001816, "text": "argsort(self, ascending: 'bool' = True, kind: 'str' = 'quicksort', na_position: 'str' = 'last', *args, **kwargs) -> 'np.ndarray': Return the indices that would sort this array."}
{"text_id": 1001817, "text": "argsort(self, ascending=True, kind='quicksort', **kwargs): Return the indices that would sort the Categorical."}
{"text_id": 1001818, "text": "argsort(self, *args, **kwargs): Return the indices that would sort the Categorical."}
{"text_id": 1001819, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001820, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001821, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001822, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001823, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001824, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001825, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Returns the indices that would sort the index and its underlying data."}
{"text_id": 1001826, "text": "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series': Return the integer indices that would sort the Series values."}
{"text_id": 1001827, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001828, "text": "argsort(self, *args, **kwargs) -> 'np.ndarray': Return the integer indices that would sort the index."}
{"text_id": 1001829, "text": "as_ordered(self, inplace=False): Set the Categorical to be ordered."}
{"text_id": 1001830, "text": "as_ordered(self, *args, **kwargs): Set the Categorical to be ordered."}
{"text_id": 1001831, "text": "as_ordered(self, *args, **kwargs): Set the Categorical to be ordered."}
{"text_id": 1001832, "text": "as_ordered(self, inplace=False): Set the Categorical to be ordered."}
{"text_id": 1001833, "text": "as_ordered(self, inplace=False): Set the Categorical to be ordered."}
{"text_id": 1001834, "text": "as_ordered(self, *args, **kwargs): Set the Categorical to be ordered."}
{"text_id": 1001835, "text": "as_unordered(self, inplace=False): Set the Categorical to be unordered."}
{"text_id": 1001836, "text": "as_unordered(self, *args, **kwargs): Set the Categorical to be unordered."}
{"text_id": 1001837, "text": "as_unordered(self, *args, **kwargs): Set the Categorical to be unordered."}
{"text_id": 1001838, "text": "as_unordered(self, inplace=False): Set the Categorical to be unordered."}
{"text_id": 1001839, "text": "as_unordered(self, inplace=False): Set the Categorical to be unordered."}
{"text_id": 1001840, "text": "as_unordered(self, *args, **kwargs): Set the Categorical to be unordered."}
{"text_id": 1001841, "text": "astype(self, dtype: 'Dtype', copy: 'bool' = True) -> 'ArrayLike': Coerce this type to another dtype."}
{"text_id": 1001842, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001843, "text": "astype(self: 'FrameOrSeries', dtype, copy: 'bool_t' = True, errors: 'str' = 'raise') -> 'FrameOrSeries': Cast a pandas object to a specified dtype ``dtype``."}
{"text_id": 1001844, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001845, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001846, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001847, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001848, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001849, "text": "astype(self, dtype, copy: 'bool' = True): Create an Index with values cast to dtypes."}
{"text_id": 1001850, "text": "astype(self, dtype, copy: 'bool' = True, how=<no_default>): Create an Index with values cast to dtypes."}
{"text_id": 1001851, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001852, "text": "astype(self: 'FrameOrSeries', dtype, copy: 'bool_t' = True, errors: 'str' = 'raise') -> 'FrameOrSeries': Cast a pandas object to a specified dtype ``dtype``."}
{"text_id": 1001853, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001854, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001855, "text": "astype(self, dtype, copy: 'bool' = True) -> 'ArrayLike': Cast to a NumPy array or ExtensionArray with 'dtype'."}
{"text_id": 1001856, "text": "astype(self, dtype: 'Dtype', copy: 'bool' = True) -> 'ArrayLike': Coerce this type to another dtype."}
{"text_id": 1001857, "text": "astype(self, dtype, copy: 'bool' = True) -> 'ArrayLike': Cast to a NumPy array or ExtensionArray with 'dtype'."}
{"text_id": 1001858, "text": "astype(self, dtype, copy: 'bool' = True) -> 'ArrayLike': Cast to a NumPy array or ExtensionArray with 'dtype'."}
{"text_id": 1001859, "text": "astype(self, dtype, copy: 'bool' = True): Cast to an ExtensionArray or NumPy array with dtype 'dtype'."}
{"text_id": 1001860, "text": "astype(self, dtype, copy=True): Cast to a NumPy array with 'dtype'."}
{"text_id": 1001861, "text": "astype(self, dtype: 'Dtype | None' = None, copy=True): Change the dtype of a SparseArray."}
{"text_id": 1001862, "text": "astype(self, dtype: 'Dtype', copy: 'bool' = True) -> 'ArrayLike': Coerce this type to another dtype."}
{"text_id": 1001863, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001864, "text": "astype(self: 'FrameOrSeries', dtype, copy: 'bool_t' = True, errors: 'str' = 'raise') -> 'FrameOrSeries': Cast a pandas object to a specified dtype ``dtype``."}
{"text_id": 1001865, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001866, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001867, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001868, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001869, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001870, "text": "astype(self, dtype, copy: 'bool' = True): Create an Index with values cast to dtypes."}
{"text_id": 1001871, "text": "astype(self, dtype, copy: 'bool' = True, how=<no_default>): Create an Index with values cast to dtypes."}
{"text_id": 1001872, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001873, "text": "astype(self: 'FrameOrSeries', dtype, copy: 'bool_t' = True, errors: 'str' = 'raise') -> 'FrameOrSeries': Cast a pandas object to a specified dtype ``dtype``."}
{"text_id": 1001874, "text": "astype(self, dtype, copy: 'bool' = True) -> 'Index': Create an Index with values cast to dtypes."}
{"text_id": 1001875, "text": "astype(self, dtype, copy=True): Create an Index with values cast to dtypes."}
{"text_id": 1001876, "text": "check_for_ordered(self, op): assert that we are ordered."}
{"text_id": 1001877, "text": "check_for_ordered(self, op): assert that we are ordered."}
{"text_id": 1001878, "text": "check_for_ordered(self, op): assert that we are ordered."}
{"text_id": 1001879, "text": "describe(self): Describes this Categorical."}
{"text_id": 1001880, "text": "describe(self: 'FrameOrSeries', percentiles=None, include=None, exclude=None, datetime_is_numeric=False) -> 'FrameOrSeries': Generate descriptive statistics."}
{"text_id": 1001881, "text": "describe(self: 'FrameOrSeries', percentiles=None, include=None, exclude=None, datetime_is_numeric=False) -> 'FrameOrSeries': Generate descriptive statistics."}
{"text_id": 1001882, "text": "describe(self): Describes this Categorical."}
{"text_id": 1001883, "text": "describe(self): Describes this Categorical."}
{"text_id": 1001884, "text": "describe(self: 'FrameOrSeries', percentiles=None, include=None, exclude=None, datetime_is_numeric=False) -> 'FrameOrSeries': Generate descriptive statistics."}
{"text_id": 1001885, "text": "describe(self: 'FrameOrSeries', percentiles=None, include=None, exclude=None, datetime_is_numeric=False) -> 'FrameOrSeries': Generate descriptive statistics."}
{"text_id": 1001886, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001887, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001888, "text": "dropna(self, axis: 'Axis' = 0, how: 'str' = 'any', thresh=None, subset=None, inplace: 'bool' = False): Remove missing values."}
{"text_id": 1001889, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001890, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001891, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001892, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001893, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001894, "text": "dropna(self, how: 'str' = 'any') -> 'MultiIndex': Return Index without NA/NaN values."}
{"text_id": 1001895, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001896, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001897, "text": "dropna(self, axis=0, inplace=False, how=None): Return a new Series with missing values removed."}
{"text_id": 1001898, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001899, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001900, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001901, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001902, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001903, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001904, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001905, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001906, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001907, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001908, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001909, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001910, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001911, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001912, "text": "dropna(self): Return ExtensionArray without NA values."}
{"text_id": 1001913, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001914, "text": "dropna(self, axis: 'Axis' = 0, how: 'str' = 'any', thresh=None, subset=None, inplace: 'bool' = False): Remove missing values."}
{"text_id": 1001915, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001916, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001917, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001918, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001919, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001920, "text": "dropna(self, how: 'str' = 'any') -> 'MultiIndex': Return Index without NA/NaN values."}
{"text_id": 1001921, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001922, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001923, "text": "dropna(self, axis=0, inplace=False, how=None): Return a new Series with missing values removed."}
{"text_id": 1001924, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001925, "text": "dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT': Return Index without NA/NaN values."}
{"text_id": 1001926, "text": "equals(self, other: 'object') -> 'bool': Returns True if categorical arrays are equal."}
{"text_id": 1001927, "text": "equals(self, other: 'object') -> 'bool': Determine if two CategoricalIndex objects contain the same elements."}
{"text_id": 1001928, "text": "equals(self, other: 'object') -> 'bool_t': Test whether two objects contain the same elements."}
{"text_id": 1001929, "text": "equals(self, other: 'Any') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001930, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001931, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001932, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001933, "text": "equals(self, other) -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001934, "text": "equals(self, other: 'object') -> 'bool': Determines if two MultiIndex objects have the same labeling information (the levels themselves do not necessarily have to be the same)."}
{"text_id": 1001935, "text": "equals(self, other: 'Any') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001936, "text": "equals(self, other: 'object') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001937, "text": "equals(self, other: 'object') -> 'bool_t': Test whether two objects contain the same elements."}
{"text_id": 1001938, "text": "equals(self, other: 'Any') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001939, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001940, "text": "equals(self, other: 'object') -> 'bool': Return if another array is equivalent to this array."}
{"text_id": 1001941, "text": "equals(self, other: 'object') -> 'bool': Return if another array is equivalent to this array."}
{"text_id": 1001942, "text": "equals(self, other: 'object') -> 'bool': Returns True if categorical arrays are equal."}
{"text_id": 1001943, "text": "equals(self, other: 'object') -> 'bool': Return if another array is equivalent to this array."}
{"text_id": 1001944, "text": "equals(self, other: 'object') -> 'bool': Return if another array is equivalent to this array."}
{"text_id": 1001945, "text": "equals(self, other: 'object') -> 'bool': Return if another array is equivalent to this array."}
{"text_id": 1001946, "text": "equals(self, other: 'object') -> 'bool': Returns True if categorical arrays are equal."}
{"text_id": 1001947, "text": "equals(self, other: 'object') -> 'bool': Determine if two CategoricalIndex objects contain the same elements."}
{"text_id": 1001948, "text": "equals(self, other: 'object') -> 'bool_t': Test whether two objects contain the same elements."}
{"text_id": 1001949, "text": "equals(self, other: 'Any') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001950, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001951, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001952, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001953, "text": "equals(self, other) -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001954, "text": "equals(self, other: 'object') -> 'bool': Determines if two MultiIndex objects have the same labeling information (the levels themselves do not necessarily have to be the same)."}
{"text_id": 1001955, "text": "equals(self, other: 'Any') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001956, "text": "equals(self, other: 'object') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001957, "text": "equals(self, other: 'object') -> 'bool_t': Test whether two objects contain the same elements."}
{"text_id": 1001958, "text": "equals(self, other: 'Any') -> 'bool': Determines if two Index objects contain the same elements."}
{"text_id": 1001959, "text": "equals(self, other: 'Any') -> 'bool': Determine if two Index object are equal."}
{"text_id": 1001960, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001961, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001962, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001963, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001964, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001965, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001966, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001967, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001968, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001969, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001970, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001971, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001972, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001973, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001974, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001975, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001976, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001977, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001978, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001979, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001980, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001981, "text": "factorize(values, sort: 'bool' = False, na_sentinel: 'int | None' = -1, size_hint: 'int | None' = None) -> 'tuple[np.ndarray, np.ndarray | Index]': Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001982, "text": "factorize(values, sort: 'bool' = False, na_sentinel: 'int | None' = -1, size_hint: 'int | None' = None) -> 'tuple[np.ndarray, np.ndarray | Index]': Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001983, "text": "factorize(values, sort: 'bool' = False, na_sentinel: 'int | None' = -1, size_hint: 'int | None' = None) -> 'tuple[np.ndarray, np.ndarray | Index]': Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001984, "text": "factorize(self, na_sentinel: 'int' = -1) -> 'tuple[np.ndarray, ExtensionArray]': Encode the extension array as an enumerated type."}
{"text_id": 1001985, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001986, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001987, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001988, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001989, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001990, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001991, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001992, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001993, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001994, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001995, "text": "factorize(self, sort: 'bool' = False, na_sentinel: 'int | None' = -1): Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001996, "text": "factorize(values, sort: 'bool' = False, na_sentinel: 'int | None' = -1, size_hint: 'int | None' = None) -> 'tuple[np.ndarray, np.ndarray | Index]': Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001997, "text": "factorize(values, sort: 'bool' = False, na_sentinel: 'int | None' = -1, size_hint: 'int | None' = None) -> 'tuple[np.ndarray, np.ndarray | Index]': Encode the object as an enumerated type or categorical variable."}
{"text_id": 1001998, "text": "fillna(self: 'NDArrayBackedExtensionArrayT', value=None, method=None, limit=None) -> 'NDArrayBackedExtensionArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1001999, "text": "fillna(self, value, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002000, "text": "fillna(self, value: 'object | ArrayLike | None' = None, method: 'FillnaOptions | None' = None, axis: 'Axis | None' = None, inplace: 'bool' = False, limit=None, downcast=None) -> 'DataFrame | None': Fill NA/NaN values using the specified method."}
{"text_id": 1002001, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002002, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002003, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002004, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002005, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002006, "text": "fillna(self, value=None, downcast=None): fillna is not implemented for MultiIndex."}
{"text_id": 1002007, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002008, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002009, "text": "fillna(self, value: 'object | ArrayLike | None' = None, method: 'FillnaOptions | None' = None, axis=None, inplace=False, limit=None, downcast=None) -> 'Series | None': Fill NA/NaN values using the specified method."}
{"text_id": 1002010, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002011, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002012, "text": "fillna(self, value=None, method=None, limit=None): Fill NA/NaN values using the specified method."}
{"text_id": 1002013, "text": "fillna(self: 'BaseMaskedArrayT', value=None, method=None, limit=None) -> 'BaseMaskedArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002014, "text": "fillna(self: 'NDArrayBackedExtensionArrayT', value=None, method=None, limit=None) -> 'NDArrayBackedExtensionArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002015, "text": "fillna(self: 'NDArrayBackedExtensionArrayT', value=None, method=None, limit=None) -> 'NDArrayBackedExtensionArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002016, "text": "fillna(self: 'BaseMaskedArrayT', value=None, method=None, limit=None) -> 'BaseMaskedArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002017, "text": "fillna(self: 'BaseMaskedArrayT', value=None, method=None, limit=None) -> 'BaseMaskedArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002018, "text": "fillna(self: 'IntervalArrayT', value=None, method=None, limit=None) -> 'IntervalArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002019, "text": "fillna(self: 'NDArrayBackedExtensionArrayT', value=None, method=None, limit=None) -> 'NDArrayBackedExtensionArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002020, "text": "fillna(self, value=None, method=None, limit=None): Fill missing values with `value`."}
{"text_id": 1002021, "text": "fillna(self: 'NDArrayBackedExtensionArrayT', value=None, method=None, limit=None) -> 'NDArrayBackedExtensionArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002022, "text": "fillna(self: 'NDArrayBackedExtensionArrayT', value=None, method=None, limit=None) -> 'NDArrayBackedExtensionArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002023, "text": "fillna(self: 'NDArrayBackedExtensionArrayT', value=None, method=None, limit=None) -> 'NDArrayBackedExtensionArrayT': Fill NA/NaN values using the specified method."}
{"text_id": 1002024, "text": "fillna(self, value, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002025, "text": "fillna(self, value: 'object | ArrayLike | None' = None, method: 'FillnaOptions | None' = None, axis: 'Axis | None' = None, inplace: 'bool' = False, limit=None, downcast=None) -> 'DataFrame | None': Fill NA/NaN values using the specified method."}
{"text_id": 1002026, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002027, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002028, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002029, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002030, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002031, "text": "fillna(self, value=None, downcast=None): fillna is not implemented for MultiIndex."}
{"text_id": 1002032, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002033, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002034, "text": "fillna(self, value: 'object | ArrayLike | None' = None, method: 'FillnaOptions | None' = None, axis=None, inplace=False, limit=None, downcast=None) -> 'Series | None': Fill NA/NaN values using the specified method."}
{"text_id": 1002035, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002036, "text": "fillna(self, value=None, downcast=None): Fill NA/NaN values with the specified value."}
{"text_id": 1002037, "text": "from_codes(codes, categories=None, ordered=None, dtype: 'Dtype | None' = None): Make a Categorical type from codes and categories or dtype."}
{"text_id": 1002038, "text": "from_codes(codes, categories=None, ordered=None, dtype: 'Dtype | None' = None): Make a Categorical type from codes and categories or dtype."}
{"text_id": 1002039, "text": "from_codes(codes, categories=None, ordered=None, dtype: 'Dtype | None' = None): Make a Categorical type from codes and categories or dtype."}
{"text_id": 1002040, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002041, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002042, "text": "insert(self, loc, column, value, allow_duplicates: 'bool' = False) -> 'None': Insert column into DataFrame at specified location."}
{"text_id": 1002043, "text": "insert(self, loc: 'int', item): Make new Index inserting new item at location."}
{"text_id": 1002044, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002045, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002046, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002047, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002048, "text": "insert(self, loc: 'int', item) -> 'MultiIndex': Make new MultiIndex inserting new item at location."}
{"text_id": 1002049, "text": "insert(self, loc: 'int', item): Make new Index inserting new item at location."}
{"text_id": 1002050, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002051, "text": "insert(self, loc: 'int', item): Make new Index inserting new item at location."}
{"text_id": 1002052, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002053, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002054, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002055, "text": "insert(self: 'IntervalArrayT', loc: 'int', item: 'Interval') -> 'IntervalArrayT': Return a new IntervalArray inserting new item at location."}
{"text_id": 1002056, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002057, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002058, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002059, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002060, "text": "insert(self: 'NDArrayBackedExtensionArrayT', loc: 'int', item) -> 'NDArrayBackedExtensionArrayT': Make new ExtensionArray inserting new item at location."}
{"text_id": 1002061, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002062, "text": "insert(self, loc, column, value, allow_duplicates: 'bool' = False) -> 'None': Insert column into DataFrame at specified location."}
{"text_id": 1002063, "text": "insert(self, loc: 'int', item): Make new Index inserting new item at location."}
{"text_id": 1002064, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002065, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002066, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002067, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002068, "text": "insert(self, loc: 'int', item) -> 'MultiIndex': Make new MultiIndex inserting new item at location."}
{"text_id": 1002069, "text": "insert(self, loc: 'int', item): Make new Index inserting new item at location."}
{"text_id": 1002070, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002071, "text": "insert(self, loc: 'int', item): Make new Index inserting new item at location."}
{"text_id": 1002072, "text": "insert(self, loc: 'int', item) -> 'Index': Make new Index inserting new item at location."}
{"text_id": 1002073, "text": "isin(self, values) -> 'np.ndarray': Check whether `values` are contained in Categorical."}
{"text_id": 1002074, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002075, "text": "isin(self, values) -> 'DataFrame': Whether each element in the DataFrame is contained in values."}
{"text_id": 1002076, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002077, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002078, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002079, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002080, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002081, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002082, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002083, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002084, "text": "isin(self, values) -> 'Series': Whether elements in Series are contained in `values`."}
{"text_id": 1002085, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002086, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002087, "text": "isin(self, values) -> 'np.ndarray': Check whether `values` are contained in Categorical."}
{"text_id": 1002088, "text": "isin(self, values) -> 'np.ndarray': Compute boolean array of whether each value is found in the passed set of values."}
{"text_id": 1002089, "text": "isin(self, values) -> 'np.ndarray': Pointwise comparison for set containment in the given values."}
{"text_id": 1002090, "text": "isin(self, values) -> 'np.ndarray': Compute boolean array of whether each value is found in the passed set of values."}
{"text_id": 1002091, "text": "isin(self, values) -> 'np.ndarray': Pointwise comparison for set containment in the given values."}
{"text_id": 1002092, "text": "isin(self, values) -> 'np.ndarray': Pointwise comparison for set containment in the given values."}
{"text_id": 1002093, "text": "isin(self, values) -> 'np.ndarray': Compute boolean array of whether each value is found in the passed set of values."}
{"text_id": 1002094, "text": "isin(comps: 'AnyArrayLike', values: 'AnyArrayLike') -> 'np.ndarray': Compute the isin boolean array."}
{"text_id": 1002095, "text": "isin(self, values) -> 'np.ndarray': Check whether `values` are contained in Categorical."}
{"text_id": 1002096, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002097, "text": "isin(self, values) -> 'DataFrame': Whether each element in the DataFrame is contained in values."}
{"text_id": 1002098, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002099, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002100, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002101, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002102, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002103, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002104, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002105, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002106, "text": "isin(self, values) -> 'Series': Whether elements in Series are contained in `values`."}
{"text_id": 1002107, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002108, "text": "isin(self, values, level=None) -> 'np.ndarray': Return a boolean array where the index values are in `values`."}
{"text_id": 1002109, "text": "isna(self) -> 'np.ndarray': Detect missing values Missing values (-1 in."}
{"text_id": 1002110, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002111, "text": "isna(self) -> 'DataFrame': Detect missing values."}
{"text_id": 1002112, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002113, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002114, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002115, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002116, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002117, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002118, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002119, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002120, "text": "isna(self) -> 'Series': Detect missing values."}
{"text_id": 1002121, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002122, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002123, "text": "isna(self) -> 'np.ndarray': Boolean NumPy array indicating if each value is missing."}
{"text_id": 1002124, "text": "isna(self) -> 'np.ndarray': Detect missing values Missing values (-1 in."}
{"text_id": 1002125, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002126, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002127, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002128, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002129, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002130, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002131, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002132, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002133, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002134, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002135, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002136, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002137, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002138, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002139, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002140, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002141, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002142, "text": "isna(self) -> 'np.ndarray': Detect missing values Missing values (-1 in."}
{"text_id": 1002143, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002144, "text": "isna(self) -> 'DataFrame': Detect missing values."}
{"text_id": 1002145, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002146, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002147, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002148, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002149, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002150, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002151, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002152, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002153, "text": "isna(self) -> 'Series': Detect missing values."}
{"text_id": 1002154, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002155, "text": "isna(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002156, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002157, "text": "isna(obj): Detect missing values for an array-like object."}
{"text_id": 1002158, "text": "isnull(self) -> 'np.ndarray': Detect missing values Missing values (-1 in."}
{"text_id": 1002159, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002160, "text": "isnull(self) -> 'DataFrame': Detect missing values."}
{"text_id": 1002161, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002162, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002163, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002164, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002165, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002166, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002167, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002168, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002169, "text": "isnull(self) -> 'Series': Detect missing values."}
{"text_id": 1002170, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002171, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002172, "text": "isnull(self) -> 'np.ndarray': Detect missing values Missing values (-1 in."}
{"text_id": 1002173, "text": "isnull(obj): Detect missing values for an array-like object."}
{"text_id": 1002174, "text": "isnull(obj): Detect missing values for an array-like object."}
{"text_id": 1002175, "text": "isnull(self) -> 'np.ndarray': Detect missing values Missing values (-1 in."}
{"text_id": 1002176, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002177, "text": "isnull(self) -> 'DataFrame': Detect missing values."}
{"text_id": 1002178, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002179, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002180, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002181, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002182, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002183, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002184, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002185, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002186, "text": "isnull(self) -> 'Series': Detect missing values."}
{"text_id": 1002187, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002188, "text": "isnull(self) -> 'np.ndarray': Detect missing values."}
{"text_id": 1002189, "text": "isnull(obj): Detect missing values for an array-like object."}
{"text_id": 1002190, "text": "isnull(obj): Detect missing values for an array-like object."}
{"text_id": 1002191, "text": "map(self, mapper): Map categories using input correspondence (dict, Series, or function)."}
{"text_id": 1002192, "text": "map(self, mapper): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002193, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002194, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002195, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002196, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002197, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002198, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002199, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002200, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002201, "text": "map(self, arg, na_action=None) -> 'Series': Map values of Series according to input correspondence."}
{"text_id": 1002202, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002203, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002204, "text": "map(self, mapper): Map categories using input correspondence (dict, Series, or function)."}
{"text_id": 1002205, "text": "map(self, mapper): Map categories using input correspondence (dict, Series, or function)."}
{"text_id": 1002206, "text": "map(self, mapper): Map categories using input correspondence (dict, Series, or function)."}
{"text_id": 1002207, "text": "map(self, mapper): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002208, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002209, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002210, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002211, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002212, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002213, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002214, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002215, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002216, "text": "map(self, arg, na_action=None) -> 'Series': Map values of Series according to input correspondence."}
{"text_id": 1002217, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002218, "text": "map(self, mapper, na_action=None): Map values using input correspondence (a dict, Series, or function)."}
{"text_id": 1002219, "text": "max(self, *, skipna=True, **kwargs): The maximum value of the object."}
{"text_id": 1002220, "text": "max(self, *args, **kwargs): The maximum value of the object."}
{"text_id": 1002221, "text": "max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the maximum of the values over the requested axis."}
{"text_id": 1002222, "text": "max(self, axis=None, skipna=True, *args, **kwargs): Return the maximum value of the Index or maximum along an axis."}
{"text_id": 1002223, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002224, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002225, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002226, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002227, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002228, "text": "max(self, axis=None, skipna=True, *args, **kwargs): Return the maximum value of the Index or maximum along an axis."}
{"text_id": 1002229, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': The maximum value of the RangeIndex."}
{"text_id": 1002230, "text": "max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the maximum of the values over the requested axis."}
{"text_id": 1002231, "text": "max(self, axis=None, skipna=True, *args, **kwargs): Return the maximum value of the Index or maximum along an axis."}
{"text_id": 1002232, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002233, "text": "max(self, *, skipna=True, **kwargs): The maximum value of the object."}
{"text_id": 1002234, "text": "max(self, *, axis: 'int | None' = None, skipna: 'bool' = True, **kwargs): Return the maximum value of the Array or maximum along an axis."}
{"text_id": 1002235, "text": "max(self, *, axis: 'int | None' = None, skipna: 'bool' = True, **kwargs): Return the maximum value of the Array or maximum along an axis."}
{"text_id": 1002236, "text": "max(self, *, axis: 'int | None' = None, skipna: 'bool' = True, **kwargs): Return the maximum value of the Array or maximum along an axis."}
{"text_id": 1002237, "text": "max(self, *, skipna=True, **kwargs): The maximum value of the object."}
{"text_id": 1002238, "text": "max(self, *args, **kwargs): The maximum value of the object."}
{"text_id": 1002239, "text": "max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the maximum of the values over the requested axis."}
{"text_id": 1002240, "text": "max(self, axis=None, skipna=True, *args, **kwargs): Return the maximum value of the Index or maximum along an axis."}
{"text_id": 1002241, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002242, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002243, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002244, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002245, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002246, "text": "max(self, axis=None, skipna=True, *args, **kwargs): Return the maximum value of the Index or maximum along an axis."}
{"text_id": 1002247, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': The maximum value of the RangeIndex."}
{"text_id": 1002248, "text": "max(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the maximum of the values over the requested axis."}
{"text_id": 1002249, "text": "max(self, axis=None, skipna=True, *args, **kwargs): Return the maximum value of the Index or maximum along an axis."}
{"text_id": 1002250, "text": "max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index."}
{"text_id": 1002251, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of my values."}
{"text_id": 1002252, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002253, "text": "memory_usage(self, index: 'bool' = True, deep: 'bool' = False) -> 'Series': Return the memory usage of each column in bytes."}
{"text_id": 1002254, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002255, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002256, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002257, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002258, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002259, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002260, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002261, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of my values."}
{"text_id": 1002262, "text": "memory_usage(self, index: 'bool' = True, deep: 'bool' = False) -> 'int': Return the memory usage of the Series."}
{"text_id": 1002263, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002264, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002265, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of my values."}
{"text_id": 1002266, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of my values."}
{"text_id": 1002267, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002268, "text": "memory_usage(self, index: 'bool' = True, deep: 'bool' = False) -> 'Series': Return the memory usage of each column in bytes."}
{"text_id": 1002269, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002270, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002271, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002272, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002273, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002274, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002275, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002276, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of my values."}
{"text_id": 1002277, "text": "memory_usage(self, index: 'bool' = True, deep: 'bool' = False) -> 'int': Return the memory usage of the Series."}
{"text_id": 1002278, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002279, "text": "memory_usage(self, deep: 'bool' = False) -> 'int': Memory usage of the values."}
{"text_id": 1002280, "text": "min(self, *, skipna=True, **kwargs): The minimum value of the object."}
{"text_id": 1002281, "text": "min(self, *args, **kwargs): The minimum value of the object."}
{"text_id": 1002282, "text": "min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the minimum of the values over the requested axis."}
{"text_id": 1002283, "text": "min(self, axis=None, skipna=True, *args, **kwargs): Return the minimum value of the Index or minimum along an axis."}
{"text_id": 1002284, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002285, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002286, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002287, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002288, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002289, "text": "min(self, axis=None, skipna=True, *args, **kwargs): Return the minimum value of the Index or minimum along an axis."}
{"text_id": 1002290, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': The minimum value of the RangeIndex."}
{"text_id": 1002291, "text": "min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the minimum of the values over the requested axis."}
{"text_id": 1002292, "text": "min(self, axis=None, skipna=True, *args, **kwargs): Return the minimum value of the Index or minimum along an axis."}
{"text_id": 1002293, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002294, "text": "min(self, *, skipna=True, **kwargs): The minimum value of the object."}
{"text_id": 1002295, "text": "min(self, *, axis: 'int | None' = None, skipna: 'bool' = True, **kwargs): Return the minimum value of the Array or minimum along an axis."}
{"text_id": 1002296, "text": "min(self, *, axis: 'int | None' = None, skipna: 'bool' = True, **kwargs): Return the minimum value of the Array or minimum along an axis."}
{"text_id": 1002297, "text": "min(self, *, axis: 'int | None' = None, skipna: 'bool' = True, **kwargs): Return the minimum value of the Array or minimum along an axis."}
{"text_id": 1002298, "text": "min(self, *, skipna=True, **kwargs): The minimum value of the object."}
{"text_id": 1002299, "text": "min(self, *args, **kwargs): The minimum value of the object."}
{"text_id": 1002300, "text": "min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the minimum of the values over the requested axis."}
{"text_id": 1002301, "text": "min(self, axis=None, skipna=True, *args, **kwargs): Return the minimum value of the Index or minimum along an axis."}
{"text_id": 1002302, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002303, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002304, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002305, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002306, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002307, "text": "min(self, axis=None, skipna=True, *args, **kwargs): Return the minimum value of the Index or minimum along an axis."}
{"text_id": 1002308, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': The minimum value of the RangeIndex."}
{"text_id": 1002309, "text": "min(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the minimum of the values over the requested axis."}
{"text_id": 1002310, "text": "min(self, axis=None, skipna=True, *args, **kwargs): Return the minimum value of the Index or minimum along an axis."}
{"text_id": 1002311, "text": "min(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the minimum value of the Index."}
{"text_id": 1002312, "text": "mode(self, dropna=True): Returns the mode(s) of the Categorical."}
{"text_id": 1002313, "text": "mode(self, axis: 'Axis' = 0, numeric_only: 'bool' = False, dropna: 'bool' = True) -> 'DataFrame': Get the mode(s) of each element along the selected axis."}
{"text_id": 1002314, "text": "mode(self, dropna=True) -> 'Series': Return the mode(s) of the Series."}
{"text_id": 1002315, "text": "mode(self, dropna=True): Returns the mode(s) of the Categorical."}
{"text_id": 1002316, "text": "mode(values, dropna: 'bool' = True) -> 'Series': Returns the mode(s) of an array."}
{"text_id": 1002317, "text": "mode(self, dropna=True): Returns the mode(s) of the Categorical."}
{"text_id": 1002318, "text": "mode(self, axis: 'Axis' = 0, numeric_only: 'bool' = False, dropna: 'bool' = True) -> 'DataFrame': Get the mode(s) of each element along the selected axis."}
{"text_id": 1002319, "text": "mode(self, dropna=True) -> 'Series': Return the mode(s) of the Series."}
{"text_id": 1002320, "text": "notna(self) -> 'np.ndarray': Inverse of isna Both missing values (-1 in."}
{"text_id": 1002321, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002322, "text": "notna(self) -> 'DataFrame': Detect existing (non-missing) values."}
{"text_id": 1002323, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002324, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002325, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002326, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002327, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002328, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002329, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002330, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002331, "text": "notna(self) -> 'Series': Detect existing (non-missing) values."}
{"text_id": 1002332, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002333, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002334, "text": "notna(self) -> 'np.ndarray': Inverse of isna Both missing values (-1 in."}
{"text_id": 1002335, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002336, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002337, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002338, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002339, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002340, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002341, "text": "notna(self) -> 'np.ndarray': Inverse of isna Both missing values (-1 in."}
{"text_id": 1002342, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002343, "text": "notna(self) -> 'DataFrame': Detect existing (non-missing) values."}
{"text_id": 1002344, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002345, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002346, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002347, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002348, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002349, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002350, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002351, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002352, "text": "notna(self) -> 'Series': Detect existing (non-missing) values."}
{"text_id": 1002353, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002354, "text": "notna(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002355, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002356, "text": "notna(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002357, "text": "notnull(self) -> 'np.ndarray': Inverse of isna Both missing values (-1 in."}
{"text_id": 1002358, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002359, "text": "notnull(self) -> 'DataFrame': Detect existing (non-missing) values."}
{"text_id": 1002360, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002361, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002362, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002363, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002364, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002365, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002366, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002367, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002368, "text": "notnull(self) -> 'Series': Detect existing (non-missing) values."}
{"text_id": 1002369, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002370, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002371, "text": "notnull(self) -> 'np.ndarray': Inverse of isna Both missing values (-1 in."}
{"text_id": 1002372, "text": "notnull(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002373, "text": "notnull(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002374, "text": "notnull(self) -> 'np.ndarray': Inverse of isna Both missing values (-1 in."}
{"text_id": 1002375, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002376, "text": "notnull(self) -> 'DataFrame': Detect existing (non-missing) values."}
{"text_id": 1002377, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002378, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002379, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002380, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002381, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002382, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002383, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002384, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002385, "text": "notnull(self) -> 'Series': Detect existing (non-missing) values."}
{"text_id": 1002386, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002387, "text": "notnull(self) -> 'np.ndarray': Detect existing (non-missing) values."}
{"text_id": 1002388, "text": "notnull(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002389, "text": "notnull(obj): Detect non-missing values for an array-like object."}
{"text_id": 1002390, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002391, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002392, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002393, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002394, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002395, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002396, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002397, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002398, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002399, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002400, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002401, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002402, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002403, "text": "putmask(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'None': Analogue to np."}
{"text_id": 1002404, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002405, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002406, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002407, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002408, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002409, "text": "putmask(self, mask, value) -> 'Index': Return a new Index of the values set with the mask."}
{"text_id": 1002410, "text": "remove_categories(self, removals, inplace=<no_default>): Remove the specified categories."}
{"text_id": 1002411, "text": "remove_categories(self, *args, **kwargs): Remove the specified categories."}
{"text_id": 1002412, "text": "remove_categories(self, *args, **kwargs): Remove the specified categories."}
{"text_id": 1002413, "text": "remove_categories(self, removals, inplace=<no_default>): Remove the specified categories."}
{"text_id": 1002414, "text": "remove_categories(self, removals, inplace=<no_default>): Remove the specified categories."}
{"text_id": 1002415, "text": "remove_categories(self, *args, **kwargs): Remove the specified categories."}
{"text_id": 1002416, "text": "remove_unused_categories(self, inplace=<no_default>): Remove categories which are not used."}
{"text_id": 1002417, "text": "remove_unused_categories(self, *args, **kwargs): Remove categories which are not used."}
{"text_id": 1002418, "text": "remove_unused_categories(self, *args, **kwargs): Remove categories which are not used."}
{"text_id": 1002419, "text": "remove_unused_categories(self, inplace=<no_default>): Remove categories which are not used."}
{"text_id": 1002420, "text": "remove_unused_categories(self, inplace=<no_default>): Remove categories which are not used."}
{"text_id": 1002421, "text": "remove_unused_categories(self, *args, **kwargs): Remove categories which are not used."}
{"text_id": 1002422, "text": "rename_categories(self, new_categories, inplace=<no_default>): Rename categories."}
{"text_id": 1002423, "text": "rename_categories(self, *args, **kwargs): Rename categories."}
{"text_id": 1002424, "text": "rename_categories(self, *args, **kwargs): Rename categories."}
{"text_id": 1002425, "text": "rename_categories(self, new_categories, inplace=<no_default>): Rename categories."}
{"text_id": 1002426, "text": "rename_categories(self, new_categories, inplace=<no_default>): Rename categories."}
{"text_id": 1002427, "text": "rename_categories(self, *args, **kwargs): Rename categories."}
{"text_id": 1002428, "text": "reorder_categories(self, new_categories, ordered=None, inplace=<no_default>): Reorder categories as specified in new_categories."}
{"text_id": 1002429, "text": "reorder_categories(self, *args, **kwargs): Reorder categories as specified in new_categories."}
{"text_id": 1002430, "text": "reorder_categories(self, *args, **kwargs): Reorder categories as specified in new_categories."}
{"text_id": 1002431, "text": "reorder_categories(self, new_categories, ordered=None, inplace=<no_default>): Reorder categories as specified in new_categories."}
{"text_id": 1002432, "text": "reorder_categories(self, new_categories, ordered=None, inplace=<no_default>): Reorder categories as specified in new_categories."}
{"text_id": 1002433, "text": "reorder_categories(self, *args, **kwargs): Reorder categories as specified in new_categories."}
{"text_id": 1002434, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002435, "text": "searchsorted(self, *args, **kwargs): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002436, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002437, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002438, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002439, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002440, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002441, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002442, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002443, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002444, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002445, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002446, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002447, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002448, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002449, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002450, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002451, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002452, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002453, "text": "searchsorted(arr, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002454, "text": "searchsorted(self, value, side='left', sorter=None): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002455, "text": "searchsorted(self, *args, **kwargs): Find indices where elements should be inserted to maintain order."}
{"text_id": 1002456, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002457, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002458, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002459, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002460, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002461, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002462, "text": "searchsorted(self, value, side='left', sorter=None) -> 'np.ndarray': Find indices where elements should be inserted to maintain order."}
{"text_id": 1002463, "text": "set_categories(self, new_categories, ordered=None, rename=False, inplace=<no_default>): Set the categories to the specified new_categories."}
{"text_id": 1002464, "text": "set_categories(self, *args, **kwargs): Set the categories to the specified new_categories."}
{"text_id": 1002465, "text": "set_categories(self, *args, **kwargs): Set the categories to the specified new_categories."}
{"text_id": 1002466, "text": "set_categories(self, new_categories, ordered=None, rename=False, inplace=<no_default>): Set the categories to the specified new_categories."}
{"text_id": 1002467, "text": "set_categories(self, new_categories, ordered=None, rename=False, inplace=<no_default>): Set the categories to the specified new_categories."}
{"text_id": 1002468, "text": "set_categories(self, *args, **kwargs): Set the categories to the specified new_categories."}
{"text_id": 1002469, "text": "set_ordered(self, value, inplace=False): Set the ordered attribute to the boolean value."}
{"text_id": 1002470, "text": "set_ordered(self, value, inplace=False): Set the ordered attribute to the boolean value."}
{"text_id": 1002471, "text": "set_ordered(self, value, inplace=False): Set the ordered attribute to the boolean value."}
{"text_id": 1002472, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002473, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002474, "text": "shift(self, periods=1, freq: 'Frequency | None' = None, axis: 'Axis' = 0, fill_value=<no_default>) -> 'DataFrame': Shift index by desired number of periods with an optional time `freq`."}
{"text_id": 1002475, "text": "shift(self: '_T', periods: 'int' = 1, freq=None) -> '_T': Shift index by desired number of time frequency increments."}
{"text_id": 1002476, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002477, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002478, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002479, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002480, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002481, "text": "shift(self: '_T', periods: 'int' = 1, freq=None) -> '_T': Shift index by desired number of time frequency increments."}
{"text_id": 1002482, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002483, "text": "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series': Shift index by desired number of periods with an optional time `freq`."}
{"text_id": 1002484, "text": "shift(self: '_T', periods: 'int' = 1, freq=None) -> '_T': Shift index by desired number of time frequency increments."}
{"text_id": 1002485, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002486, "text": "shift(self, periods: 'int' = 1, fill_value: 'object' = None) -> 'ExtensionArray': Shift values by desired number."}
{"text_id": 1002487, "text": "shift(self, periods: 'int' = 1, fill_value: 'object' = None) -> 'ExtensionArray': Shift values by desired number."}
{"text_id": 1002488, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002489, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002490, "text": "shift(self, periods: 'int' = 1, fill_value: 'object' = None) -> 'ExtensionArray': Shift values by desired number."}
{"text_id": 1002491, "text": "shift(self, periods: 'int' = 1, fill_value: 'object' = None) -> 'ExtensionArray': Shift values by desired number."}
{"text_id": 1002492, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002493, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002494, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002495, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002496, "text": "shift(self, periods=1, fill_value=None, axis=0): Shift values by desired number."}
{"text_id": 1002497, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002498, "text": "shift(self, periods=1, freq: 'Frequency | None' = None, axis: 'Axis' = 0, fill_value=<no_default>) -> 'DataFrame': Shift index by desired number of periods with an optional time `freq`."}
{"text_id": 1002499, "text": "shift(self: '_T', periods: 'int' = 1, freq=None) -> '_T': Shift index by desired number of time frequency increments."}
{"text_id": 1002500, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002501, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002502, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002503, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002504, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002505, "text": "shift(self: '_T', periods: 'int' = 1, freq=None) -> '_T': Shift index by desired number of time frequency increments."}
{"text_id": 1002506, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002507, "text": "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series': Shift index by desired number of periods with an optional time `freq`."}
{"text_id": 1002508, "text": "shift(self: '_T', periods: 'int' = 1, freq=None) -> '_T': Shift index by desired number of time frequency increments."}
{"text_id": 1002509, "text": "shift(self, periods=1, freq=None): Shift index by desired number of time frequency increments."}
{"text_id": 1002510, "text": "sort_values(self, inplace: 'bool' = False, ascending: 'bool' = True, na_position: 'str' = 'last'): Sort the Categorical by category value returning a new Categorical by default."}
{"text_id": 1002511, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002512, "text": "sort_values(self, by, axis: 'Axis' = 0, ascending=True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', ignore_index: 'bool' = False, key: 'ValueKeyFunc' = None): Sort by the values along either axis."}
{"text_id": 1002513, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002514, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002515, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002516, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002517, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002518, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002519, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002520, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002521, "text": "sort_values(self, axis=0, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', ignore_index: 'bool' = False, key: 'ValueKeyFunc' = None): Sort by the values."}
{"text_id": 1002522, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002523, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002524, "text": "sort_values(self, inplace: 'bool' = False, ascending: 'bool' = True, na_position: 'str' = 'last'): Sort the Categorical by category value returning a new Categorical by default."}
{"text_id": 1002525, "text": "sort_values(self, inplace: 'bool' = False, ascending: 'bool' = True, na_position: 'str' = 'last'): Sort the Categorical by category value returning a new Categorical by default."}
{"text_id": 1002526, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002527, "text": "sort_values(self, by, axis: 'Axis' = 0, ascending=True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', ignore_index: 'bool' = False, key: 'ValueKeyFunc' = None): Sort by the values along either axis."}
{"text_id": 1002528, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002529, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002530, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002531, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002532, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002533, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002534, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002535, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002536, "text": "sort_values(self, axis=0, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', ignore_index: 'bool' = False, key: 'ValueKeyFunc' = None): Sort by the values."}
{"text_id": 1002537, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002538, "text": "sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None): Return a sorted copy of the index."}
{"text_id": 1002539, "text": "to_dense(self) -> 'np.ndarray': Return my 'dense' representation For internal compatibility with numpy arrays."}
{"text_id": 1002540, "text": "to_dense(self): Convert a DataFrame with sparse values to dense."}
{"text_id": 1002541, "text": "to_dense(self): Convert a Series from sparse values to dense."}
{"text_id": 1002542, "text": "to_dense(self) -> 'np.ndarray': Return my 'dense' representation For internal compatibility with numpy arrays."}
{"text_id": 1002543, "text": "to_dense(self): Convert SparseArray to a NumPy array."}
{"text_id": 1002544, "text": "to_dense(self) -> 'np.ndarray': Return my 'dense' representation For internal compatibility with numpy arrays."}
{"text_id": 1002545, "text": "to_list(self) -> 'list[Scalar]': Return a list of the values."}
{"text_id": 1002546, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002547, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002548, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002549, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002550, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002551, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002552, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002553, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002554, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002555, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002556, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002557, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002558, "text": "to_list(self) -> 'list[Scalar]': Return a list of the values."}
{"text_id": 1002559, "text": "to_list(self) -> 'list[Scalar]': Return a list of the values."}
{"text_id": 1002560, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002561, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002562, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002563, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002564, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002565, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002566, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002567, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002568, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002569, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002570, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002571, "text": "to_list(self): Return a list of the values."}
{"text_id": 1002572, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002573, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002574, "text": "to_numpy(self, dtype: 'NpDtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert the DataFrame to a NumPy array."}
{"text_id": 1002575, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002576, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002577, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002578, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002579, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002580, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002581, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002582, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002583, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002584, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002585, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002586, "text": "to_numpy(self, dtype: 'NpDtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002587, "text": "to_numpy(self, dtype: 'NpDtype | None' = None, copy: 'bool' = False, na_value: 'Scalar' = <no_default>) -> 'np.ndarray': Convert to a NumPy Array."}
{"text_id": 1002588, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002589, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002590, "text": "to_numpy(self, dtype: 'NpDtype | None' = None, copy: 'bool' = False, na_value: 'Scalar' = <no_default>) -> 'np.ndarray': Convert to a NumPy Array."}
{"text_id": 1002591, "text": "to_numpy(self, dtype: 'NpDtype | None' = None, copy: 'bool' = False, na_value: 'Scalar' = <no_default>) -> 'np.ndarray': Convert to a NumPy Array."}
{"text_id": 1002592, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002593, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002594, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002595, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002596, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert to a NumPy ndarray."}
{"text_id": 1002597, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002598, "text": "to_numpy(self, dtype: 'NpDtype | None' = None, copy: 'bool' = False, na_value=<no_default>) -> 'np.ndarray': Convert the DataFrame to a NumPy array."}
{"text_id": 1002599, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002600, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002601, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002602, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002603, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002604, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002605, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002606, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002607, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002608, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002609, "text": "to_numpy(self, dtype: 'Dtype | None' = None, copy: 'bool' = False, na_value=<no_default>, **kwargs) -> 'np.ndarray': A NumPy ndarray representing the values in this Series or Index."}
{"text_id": 1002610, "text": "tolist(self) -> 'list[Scalar]': Return a list of the values."}
{"text_id": 1002611, "text": "tolist(self, *args, **kwargs): Return a list of the values."}
{"text_id": 1002612, "text": "tolist(self) -> 'list': Return a list of the underlying data."}
{"text_id": 1002613, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002614, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002615, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002616, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002617, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002618, "text": "tolist(self) -> 'list': Return a list of the underlying data."}
{"text_id": 1002619, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002620, "text": "tolist(self) -> 'list': Return a list of the underlying data."}
{"text_id": 1002621, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002622, "text": "tolist(self) -> 'list[Scalar]': Return a list of the values."}
{"text_id": 1002623, "text": "tolist(self) -> 'list[Scalar]': Return a list of the values."}
{"text_id": 1002624, "text": "tolist(self, *args, **kwargs): Return a list of the values."}
{"text_id": 1002625, "text": "tolist(self) -> 'list': Return a list of the underlying data."}
{"text_id": 1002626, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002627, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002628, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002629, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002630, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002631, "text": "tolist(self) -> 'list': Return a list of the underlying data."}
{"text_id": 1002632, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002633, "text": "tolist(self) -> 'list': Return a list of the underlying data."}
{"text_id": 1002634, "text": "tolist(self): Return a list of the values."}
{"text_id": 1002635, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002636, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002637, "text": "transpose(self, *args, copy: 'bool' = False) -> 'DataFrame': Transpose index and columns."}
{"text_id": 1002638, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002639, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002640, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002641, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002642, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002643, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002644, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002645, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002646, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002647, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002648, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002649, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002650, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002651, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002652, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002653, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002654, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002655, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002656, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002657, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002658, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002659, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002660, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002661, "text": "transpose(self, *axes: 'int') -> 'ExtensionArray': Return a transposed view on this array."}
{"text_id": 1002662, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002663, "text": "transpose(self, *args, copy: 'bool' = False) -> 'DataFrame': Transpose index and columns."}
{"text_id": 1002664, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002665, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002666, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002667, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002668, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002669, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002670, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002671, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002672, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002673, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002674, "text": "transpose(self: '_T', *args, **kwargs) -> '_T': Return the transpose, which is by definition self."}
{"text_id": 1002675, "text": "unique(self): Return the ``Categorical`` which ``categories`` and ``codes`` are unique."}
{"text_id": 1002676, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002677, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002678, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002679, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002680, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002681, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002682, "text": "unique(self, level=None): Return unique values in the index."}
{"text_id": 1002683, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002684, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002685, "text": "unique(self) -> 'ArrayLike': Return unique values of Series object."}
{"text_id": 1002686, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002687, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002688, "text": "unique(self: 'ExtensionArrayT') -> 'ExtensionArrayT': Compute the ExtensionArray of unique values."}
{"text_id": 1002689, "text": "unique(self: 'ExtensionArrayT') -> 'ExtensionArrayT': Compute the ExtensionArray of unique values."}
{"text_id": 1002690, "text": "unique(self): Return the ``Categorical`` which ``categories`` and ``codes`` are unique."}
{"text_id": 1002691, "text": "unique(self: 'ExtensionArrayT') -> 'ExtensionArrayT': Compute the ExtensionArray of unique values."}
{"text_id": 1002692, "text": "unique(self: 'ExtensionArrayT') -> 'ExtensionArrayT': Compute the ExtensionArray of unique values."}
{"text_id": 1002693, "text": "unique(values): Hash table-based unique."}
{"text_id": 1002694, "text": "unique(values): Hash table-based unique."}
{"text_id": 1002695, "text": "unique(self): Return the ``Categorical`` which ``categories`` and ``codes`` are unique."}
{"text_id": 1002696, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002697, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002698, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002699, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002700, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002701, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002702, "text": "unique(self, level=None): Return unique values in the index."}
{"text_id": 1002703, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002704, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002705, "text": "unique(self) -> 'ArrayLike': Return unique values of Series object."}
{"text_id": 1002706, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002707, "text": "unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return unique values in the index."}
{"text_id": 1002708, "text": "unique(values): Hash table-based unique."}
{"text_id": 1002709, "text": "unique(values): Hash table-based unique."}
{"text_id": 1002710, "text": "unique(values): Hash table-based unique."}
{"text_id": 1002711, "text": "unique(values): Hash table-based unique."}
{"text_id": 1002712, "text": "value_counts(self, dropna: 'bool' = True): Return a Series containing counts of each category."}
{"text_id": 1002713, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002714, "text": "value_counts(self, subset: 'Sequence[Hashable] | None' = None, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, dropna: 'bool' = True): Return a Series containing counts of unique rows in the DataFrame."}
{"text_id": 1002715, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002716, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002717, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002718, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002719, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002720, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002721, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002722, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002723, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002724, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002725, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002726, "text": "value_counts(self, dropna: 'bool' = True) -> 'Series': Return a Series containing counts of each unique value."}
{"text_id": 1002727, "text": "value_counts(self, dropna: 'bool' = True) -> 'Series': Returns a Series containing counts of each unique value."}
{"text_id": 1002728, "text": "value_counts(self, dropna: 'bool' = True): Return a Series containing counts of each category."}
{"text_id": 1002729, "text": "value_counts(self, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002730, "text": "value_counts(self, dropna: 'bool' = True) -> 'Series': Returns a Series containing counts of each unique value."}
{"text_id": 1002731, "text": "value_counts(self, dropna: 'bool' = True) -> 'Series': Returns a Series containing counts of each unique value."}
{"text_id": 1002732, "text": "value_counts(self, dropna: 'bool' = True): Returns a Series containing counts of each interval."}
{"text_id": 1002733, "text": "value_counts(self, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002734, "text": "value_counts(self, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002735, "text": "value_counts(self, dropna: 'bool' = True): Returns a Series containing counts of unique values."}
{"text_id": 1002736, "text": "value_counts(self, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002737, "text": "value_counts(values, sort: 'bool' = True, ascending: 'bool' = False, normalize: 'bool' = False, bins=None, dropna: 'bool' = True) -> 'Series': Compute a histogram of the counts of non-null values."}
{"text_id": 1002738, "text": "value_counts(values, sort: 'bool' = True, ascending: 'bool' = False, normalize: 'bool' = False, bins=None, dropna: 'bool' = True) -> 'Series': Compute a histogram of the counts of non-null values."}
{"text_id": 1002739, "text": "value_counts(values, sort: 'bool' = True, ascending: 'bool' = False, normalize: 'bool' = False, bins=None, dropna: 'bool' = True) -> 'Series': Compute a histogram of the counts of non-null values."}
{"text_id": 1002740, "text": "value_counts(self, dropna: 'bool' = True): Return a Series containing counts of each category."}
{"text_id": 1002741, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002742, "text": "value_counts(self, subset: 'Sequence[Hashable] | None' = None, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, dropna: 'bool' = True): Return a Series containing counts of unique rows in the DataFrame."}
{"text_id": 1002743, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002744, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002745, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002746, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002747, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002748, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002749, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002750, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002751, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002752, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002753, "text": "value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True): Return a Series containing counts of unique values."}
{"text_id": 1002754, "text": "value_counts(values, sort: 'bool' = True, ascending: 'bool' = False, normalize: 'bool' = False, bins=None, dropna: 'bool' = True) -> 'Series': Compute a histogram of the counts of non-null values."}
{"text_id": 1002755, "text": "value_counts(values, sort: 'bool' = True, ascending: 'bool' = False, normalize: 'bool' = False, bins=None, dropna: 'bool' = True) -> 'Series': Compute a histogram of the counts of non-null values."}
{"text_id": 1002756, "text": "value_counts(values, sort: 'bool' = True, ascending: 'bool' = False, normalize: 'bool' = False, bins=None, dropna: 'bool' = True) -> 'Series': Compute a histogram of the counts of non-null values."}
{"text_id": 1002757, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002758, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002759, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002760, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002761, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002762, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002763, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002764, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002765, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002766, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002767, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002768, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002769, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002770, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002771, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002772, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002773, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002774, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002775, "text": "where(self: 'NDArrayBackedExtensionArrayT', mask: 'np.ndarray', value) -> 'NDArrayBackedExtensionArrayT': Analogue to np."}
{"text_id": 1002776, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002777, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002778, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002779, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002780, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002781, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002782, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002783, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002784, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002785, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002786, "text": "where(self, cond, other=None) -> 'Index': Replace values where the condition is False."}
{"text_id": 1002787, "text": "CategoricalDtype(categories=None, ordered: 'Ordered' = False): Type for categorical data with the categories and orderedness."}
{"text_id": 1002788, "text": "CategoricalDtype(categories=None, ordered: 'Ordered' = False): Type for categorical data with the categories and orderedness."}
{"text_id": 1002789, "text": "CategoricalDtype(categories=None, ordered: 'Ordered' = False): Type for categorical data with the categories and orderedness."}
{"text_id": 1002790, "text": "CategoricalDtype(categories=None, ordered: 'Ordered' = False): Type for categorical data with the categories and orderedness."}
{"text_id": 1002791, "text": "CategoricalDtype(categories=None, ordered: 'Ordered' = False): Type for categorical data with the categories and orderedness."}
{"text_id": 1002792, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002793, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002794, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002795, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002796, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002797, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002798, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002799, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002800, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002801, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002802, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002803, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002804, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002805, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002806, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002807, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002808, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002809, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002810, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002811, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002812, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002813, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002814, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002815, "text": "str(data): Vectorized string functions for Series and Index."}
{"text_id": 1002816, "text": "type(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1002817, "text": "type(x=0, /): Double-precision floating-point number type, compatible with Python `float` and C ``double``."}
{"text_id": 1002818, "text": "type(value=None, freq=None, ordinal=None, year=None, month=None, quarter=None, day=None, hour=None, minute=None, second=None): Represents a period of time."}
{"text_id": 1002819, "text": "type(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1002820, "text": "type(x=0, /): Double-precision floating-point number type, compatible with Python `float` and C ``double``."}
{"text_id": 1002821, "text": "type(value=None, freq=None, ordinal=None, year=None, month=None, quarter=None, day=None, hour=None, minute=None, second=None): Represents a period of time."}
{"text_id": 1002822, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002823, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002824, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002825, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002826, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002827, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002828, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002829, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002830, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002831, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002832, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002833, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002834, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002835, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002836, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002837, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002838, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002839, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002840, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002841, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002842, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002843, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002844, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002845, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002846, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002847, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002848, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002849, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002850, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002851, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002852, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002853, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002854, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002855, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002856, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002857, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002858, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002859, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002860, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002861, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002862, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002863, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002864, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002865, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002866, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002867, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002868, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002869, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002870, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002871, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002872, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002873, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002874, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002875, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002876, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002877, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002878, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002879, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002880, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002881, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002882, "text": "as_integer_ratio(): Return integer ratio."}
{"text_id": 1002883, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002884, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002885, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002886, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002887, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002888, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002889, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002890, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002891, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002892, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002893, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002894, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002895, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002896, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002897, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002898, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002899, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002900, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002901, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002902, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002903, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002904, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002905, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002906, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002907, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002908, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002909, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002910, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002911, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002912, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002913, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002914, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002915, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002916, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002917, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002918, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002919, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002920, "text": "bit_length(): Number of bits necessary to represent self in binary."}
{"text_id": 1002921, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002922, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002923, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002924, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002925, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002926, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002927, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002928, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002929, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002930, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002931, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002932, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002933, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002934, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002935, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002936, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002937, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002938, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002939, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002940, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002941, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002942, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002943, "text": "conjugate(): Return self, the complex conjugate of any float."}
{"text_id": 1002944, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002945, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002946, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002947, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002948, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002949, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002950, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002951, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002952, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002953, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002954, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002955, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002956, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002957, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002958, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002959, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002960, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002961, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002962, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002963, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002964, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002965, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002966, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002967, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002968, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002969, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002970, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002971, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002972, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002973, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002974, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002975, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002976, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002977, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002978, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002979, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002980, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002981, "text": "from_bytes(bytes, byteorder, *, signed=False): Return the integer represented by the given array of bytes."}
{"text_id": 1002982, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002983, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002984, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002985, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002986, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002987, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002988, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002989, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002990, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002991, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002992, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002993, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002994, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002995, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002996, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002997, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002998, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1002999, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003000, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003001, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003002, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003003, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003004, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003005, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003006, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003007, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003008, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003009, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003010, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003011, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003012, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003013, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003014, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003015, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003016, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003017, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003018, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003019, "text": "to_bytes(length, byteorder, *, signed=False): Return an array of bytes representing an integer."}
{"text_id": 1003020, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003021, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003022, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003023, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003024, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003025, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003026, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003027, "text": "reset_cache() -> 'None': clear the cache."}
{"text_id": 1003028, "text": "mro(self, /): Return a type's method resolution order."}
{"text_id": 1003029, "text": "update_dtype(self, dtype: 'str_type | CategoricalDtype') -> 'CategoricalDtype': Returns a CategoricalDtype with categories and ordered taken from dtype if specified, otherwise falling back to self if unspecified."}
{"text_id": 1003030, "text": "update_dtype(self, dtype): Convert the SparseDtype to a new dtype."}
{"text_id": 1003031, "text": "update_dtype(self, dtype: 'str_type | CategoricalDtype') -> 'CategoricalDtype': Returns a CategoricalDtype with categories and ordered taken from dtype if specified, otherwise falling back to self if unspecified."}
{"text_id": 1003032, "text": "update_dtype(self, dtype): Convert the SparseDtype to a new dtype."}
{"text_id": 1003033, "text": "validate_categories(categories, fastpath: 'bool' = False) -> 'Index': Validates that we have good categories."}
{"text_id": 1003034, "text": "validate_categories(categories, fastpath: 'bool' = False) -> 'Index': Validates that we have good categories."}
{"text_id": 1003035, "text": "validate_ordered(ordered: 'Ordered') -> 'None': Validates that we have a valid ordered parameter."}
{"text_id": 1003036, "text": "validate_ordered(ordered: 'Ordered') -> 'None': Validates that we have a valid ordered parameter."}
{"text_id": 1003037, "text": "CategoricalIndex(data=None, categories=None, ordered=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'CategoricalIndex': Index based on an underlying :class:`Categorical`."}
{"text_id": 1003038, "text": "CategoricalIndex(data=None, categories=None, ordered=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'CategoricalIndex': Index based on an underlying :class:`Categorical`."}
{"text_id": 1003039, "text": "CategoricalIndex(data=None, categories=None, ordered=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'CategoricalIndex': Index based on an underlying :class:`Categorical`."}
{"text_id": 1003040, "text": "CategoricalIndex(data=None, categories=None, ordered=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'CategoricalIndex': Index based on an underlying :class:`Categorical`."}
{"text_id": 1003041, "text": "CategoricalIndex(data=None, categories=None, ordered=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'CategoricalIndex': Index based on an underlying :class:`Categorical`."}
{"text_id": 1003042, "text": "CategoricalIndex(data=None, categories=None, ordered=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'CategoricalIndex': Index based on an underlying :class:`Categorical`."}
{"text_id": 1003043, "text": "CategoricalIndex(data=None, categories=None, ordered=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'CategoricalIndex': Index based on an underlying :class:`Categorical`."}
{"text_id": 1003044, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003045, "text": "all(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether all elements are True, potentially over an axis."}
{"text_id": 1003046, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003047, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003048, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003049, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003050, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003051, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003052, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003053, "text": "all(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether all elements are True, potentially over an axis."}
{"text_id": 1003054, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003055, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003056, "text": "all(self, *, skipna: 'bool' = True, **kwargs): Return whether all elements are True."}
{"text_id": 1003057, "text": "all(self, axis=None, *args, **kwargs): Tests whether all elements evaluate True."}
{"text_id": 1003058, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003059, "text": "all(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether all elements are True, potentially over an axis."}
{"text_id": 1003060, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003061, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003062, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003063, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003064, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003065, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003066, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003067, "text": "all(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether all elements are True, potentially over an axis."}
{"text_id": 1003068, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003069, "text": "all(self, *args, **kwargs): Return whether all elements are Truthy."}
{"text_id": 1003070, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003071, "text": "any(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether any element is True, potentially over an axis."}
{"text_id": 1003072, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003073, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003074, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003075, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003076, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003077, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003078, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003079, "text": "any(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether any element is True, potentially over an axis."}
{"text_id": 1003080, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003081, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003082, "text": "any(self, *, skipna: 'bool' = True, **kwargs): Return whether any element is True."}
{"text_id": 1003083, "text": "any(self, axis=0, *args, **kwargs): Tests whether at least one of elements evaluate True."}
{"text_id": 1003084, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003085, "text": "any(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether any element is True, potentially over an axis."}
{"text_id": 1003086, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003087, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003088, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003089, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003090, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003091, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003092, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003093, "text": "any(self, axis=0, bool_only=None, skipna=True, level=None, **kwargs): Return whether any element is True, potentially over an axis."}
{"text_id": 1003094, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003095, "text": "any(self, *args, **kwargs): Return whether any element is Truthy."}
{"text_id": 1003096, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003097, "text": "append(self, other, ignore_index: 'bool' = False, verify_integrity: 'bool' = False, sort: 'bool' = False) -> 'DataFrame': Append rows of `other` to the end of caller, returning a new object."}
{"text_id": 1003098, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003099, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003100, "text": "append(self, key: 'str', value: 'FrameOrSeries', format=None, axes=None, index=True, append=True, complib=None, complevel: 'int | None' = None, columns=None, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, chunksize=None, expectedrows=None, dropna: 'bool | None' = None, data_columns: 'list[str] | None' = None, encoding=None, errors: 'str' = 'strict'): Append to Table in file."}
{"text_id": 1003101, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003102, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003103, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003104, "text": "append(self, other): Append a collection of Index options together."}
{"text_id": 1003105, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003106, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003107, "text": "append(self, to_append, ignore_index: 'bool' = False, verify_integrity: 'bool' = False): Concatenate two or more Series."}
{"text_id": 1003108, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003109, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003110, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003111, "text": "append(self, other, ignore_index: 'bool' = False, verify_integrity: 'bool' = False, sort: 'bool' = False) -> 'DataFrame': Append rows of `other` to the end of caller, returning a new object."}
{"text_id": 1003112, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003113, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003114, "text": "append(self, key: 'str', value: 'FrameOrSeries', format=None, axes=None, index=True, append=True, complib=None, complevel: 'int | None' = None, columns=None, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, chunksize=None, expectedrows=None, dropna: 'bool | None' = None, data_columns: 'list[str] | None' = None, encoding=None, errors: 'str' = 'strict'): Append to Table in file."}
{"text_id": 1003115, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003116, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003117, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003118, "text": "append(self, other): Append a collection of Index options together."}
{"text_id": 1003119, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003120, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003121, "text": "append(self, to_append, ignore_index: 'bool' = False, verify_integrity: 'bool' = False): Concatenate two or more Series."}
{"text_id": 1003122, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003123, "text": "append(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options together."}
{"text_id": 1003124, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003125, "text": "argmax(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the maximum values along an axis."}
{"text_id": 1003126, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003127, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003128, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003129, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003130, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003131, "text": "argmax(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the maximum values along an axis."}
{"text_id": 1003132, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003133, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003134, "text": "argmax(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the maximum values along an axis."}
{"text_id": 1003135, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003136, "text": "argmax(self, skipna: 'bool' = True) -> 'int': Return the index of maximum value."}
{"text_id": 1003137, "text": "argmax(self, skipna: 'bool' = True) -> 'int': Return the index of maximum value."}
{"text_id": 1003138, "text": "argmax(self, skipna: 'bool' = True) -> 'int': Return the index of maximum value."}
{"text_id": 1003139, "text": "argmax(self, skipna: 'bool' = True) -> 'int': Return the index of maximum value."}
{"text_id": 1003140, "text": "argmax(self, skipna: 'bool' = True) -> 'int': Return the index of maximum value."}
{"text_id": 1003141, "text": "argmax(self, skipna: 'bool' = True) -> 'int': Return the index of maximum value."}
{"text_id": 1003142, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003143, "text": "argmax(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the maximum values along an axis."}
{"text_id": 1003144, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003145, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003146, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003147, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003148, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003149, "text": "argmax(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the maximum values along an axis."}
{"text_id": 1003150, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003151, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003152, "text": "argmax(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the maximum values along an axis."}
{"text_id": 1003153, "text": "argmax(self, axis=None, skipna: 'bool' = True, *args, **kwargs) -> 'int': Return int position of the largest value in the Series."}
{"text_id": 1003154, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003155, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the minimum values along an axis."}
{"text_id": 1003156, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003157, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003158, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003159, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003160, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003161, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the minimum values along an axis."}
{"text_id": 1003162, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003163, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003164, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the minimum values along an axis."}
{"text_id": 1003165, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003166, "text": "argmin(self, skipna: 'bool' = True) -> 'int': Return the index of minimum value."}
{"text_id": 1003167, "text": "argmin(self, skipna: 'bool' = True) -> 'int': Return the index of minimum value."}
{"text_id": 1003168, "text": "argmin(self, skipna: 'bool' = True) -> 'int': Return the index of minimum value."}
{"text_id": 1003169, "text": "argmin(self, skipna: 'bool' = True) -> 'int': Return the index of minimum value."}
{"text_id": 1003170, "text": "argmin(self, skipna: 'bool' = True) -> 'int': Return the index of minimum value."}
{"text_id": 1003171, "text": "argmin(self, skipna: 'bool' = True) -> 'int': Return the index of minimum value."}
{"text_id": 1003172, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003173, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the minimum values along an axis."}
{"text_id": 1003174, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003175, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003176, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003177, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003178, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003179, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the minimum values along an axis."}
{"text_id": 1003180, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003181, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003182, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs): Returns the indices of the minimum values along an axis."}
{"text_id": 1003183, "text": "argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int': Return int position of the smallest value in the Series."}
{"text_id": 1003184, "text": "array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1003185, "text": "array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1003186, "text": "array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1003187, "text": "array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1003188, "text": "array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1003189, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003190, "text": "asof(self, where, subset=None): Return the last row(s) without any NaNs before `where`."}
{"text_id": 1003191, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003192, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003193, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003194, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003195, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003196, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003197, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003198, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003199, "text": "asof(self, where, subset=None): Return the last row(s) without any NaNs before `where`."}
{"text_id": 1003200, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003201, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003202, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003203, "text": "asof(self, where, subset=None): Return the last row(s) without any NaNs before `where`."}
{"text_id": 1003204, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003205, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003206, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003207, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003208, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003209, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003210, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003211, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003212, "text": "asof(self, where, subset=None): Return the last row(s) without any NaNs before `where`."}
{"text_id": 1003213, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003214, "text": "asof(self, label): Return the label from the index, or, if not present, the previous one."}
{"text_id": 1003215, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003216, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003217, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003218, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003219, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003220, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003221, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003222, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': where : array of timestamps mask : np."}
{"text_id": 1003223, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003224, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003225, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003226, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003227, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003228, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003229, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003230, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003231, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003232, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003233, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': where : array of timestamps mask : np."}
{"text_id": 1003234, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003235, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003236, "text": "asof_locs(self, where: 'Index', mask: 'np.ndarray') -> 'np.ndarray': Return the locations (indices) of labels in the index."}
{"text_id": 1003237, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003238, "text": "copy(self: 'FrameOrSeries', deep: 'bool_t' = True) -> 'FrameOrSeries': Make a copy of this object's indices and data."}
{"text_id": 1003239, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003240, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003241, "text": "copy(self, file, mode='w', propindexes: 'bool' = True, keys=None, complib=None, complevel: 'int | None' = None, fletcher32: 'bool' = False, overwrite=True): Copy the existing store to a new file, updating in place."}
{"text_id": 1003242, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003243, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003244, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003245, "text": "copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, name=None): Make a copy of this object."}
{"text_id": 1003246, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003247, "text": "copy(self, name: 'Hashable' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names=None): Make a copy of this object."}
{"text_id": 1003248, "text": "copy(self: 'FrameOrSeries', deep: 'bool_t' = True) -> 'FrameOrSeries': Make a copy of this object's indices and data."}
{"text_id": 1003249, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003250, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003251, "text": "copy(self) -> 'ArrowStringArray': Return a shallow copy of the array."}
{"text_id": 1003252, "text": "copy(self: 'IntervalArrayT') -> 'IntervalArrayT': Return a copy of the array."}
{"text_id": 1003253, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003254, "text": "copy(self: 'FrameOrSeries', deep: 'bool_t' = True) -> 'FrameOrSeries': Make a copy of this object's indices and data."}
{"text_id": 1003255, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003256, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003257, "text": "copy(self, file, mode='w', propindexes: 'bool' = True, keys=None, complib=None, complevel: 'int | None' = None, fletcher32: 'bool' = False, overwrite=True): Copy the existing store to a new file, updating in place."}
{"text_id": 1003258, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003259, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003260, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003261, "text": "copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, name=None): Make a copy of this object."}
{"text_id": 1003262, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003263, "text": "copy(self, name: 'Hashable' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names=None): Make a copy of this object."}
{"text_id": 1003264, "text": "copy(self: 'FrameOrSeries', deep: 'bool_t' = True) -> 'FrameOrSeries': Make a copy of this object's indices and data."}
{"text_id": 1003265, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003266, "text": "copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a copy of this object."}
{"text_id": 1003267, "text": "delete(self, loc): Make new Index with passed location(-s) deleted."}
{"text_id": 1003268, "text": "delete(self: '_T', loc) -> '_T': Make new Index with passed location(-s) deleted."}
{"text_id": 1003269, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003270, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003271, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003272, "text": "delete(self, loc): Make new Index with passed location(-s) deleted."}
{"text_id": 1003273, "text": "delete(self, loc) -> 'MultiIndex': Make new index with passed location deleted."}
{"text_id": 1003274, "text": "delete(self: '_T', loc) -> '_T': Make new Index with passed location(-s) deleted."}
{"text_id": 1003275, "text": "delete(self: '_T', loc) -> '_T': Make new Index with passed location(-s) deleted."}
{"text_id": 1003276, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003277, "text": "delete(self, loc): Make new Index with passed location(-s) deleted."}
{"text_id": 1003278, "text": "delete(self: '_T', loc) -> '_T': Make new Index with passed location(-s) deleted."}
{"text_id": 1003279, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003280, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003281, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003282, "text": "delete(self, loc): Make new Index with passed location(-s) deleted."}
{"text_id": 1003283, "text": "delete(self, loc) -> 'MultiIndex': Make new index with passed location deleted."}
{"text_id": 1003284, "text": "delete(self: '_T', loc) -> '_T': Make new Index with passed location(-s) deleted."}
{"text_id": 1003285, "text": "delete(self: '_T', loc) -> '_T': Make new Index with passed location(-s) deleted."}
{"text_id": 1003286, "text": "delete(self: '_IndexT', loc) -> '_IndexT': Make new Index with passed location(-s) deleted."}
{"text_id": 1003287, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003288, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003289, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003290, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003291, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003292, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003293, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003294, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003295, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003296, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003297, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003298, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003299, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003300, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003301, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003302, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003303, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003304, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003305, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003306, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003307, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003308, "text": "difference(self, other, sort=None): Return a new Index with elements of index not in `other`."}
{"text_id": 1003309, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003310, "text": "drop(self, labels=None, axis: 'Axis' = 0, index=None, columns=None, level: 'Level | None' = None, inplace: 'bool' = False, errors: 'str' = 'raise'): Drop specified labels from rows or columns."}
{"text_id": 1003311, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003312, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003313, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003314, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003315, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003316, "text": "drop(self, codes, level=None, errors='raise'): Make new MultiIndex with passed list of codes deleted."}
{"text_id": 1003317, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003318, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003319, "text": "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series': Return Series with specified index labels removed."}
{"text_id": 1003320, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003321, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003322, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003323, "text": "drop(self, labels=None, axis: 'Axis' = 0, index=None, columns=None, level: 'Level | None' = None, inplace: 'bool' = False, errors: 'str' = 'raise'): Drop specified labels from rows or columns."}
{"text_id": 1003324, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003325, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003326, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003327, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003328, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003329, "text": "drop(self, codes, level=None, errors='raise'): Make new MultiIndex with passed list of codes deleted."}
{"text_id": 1003330, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003331, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003332, "text": "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series': Return Series with specified index labels removed."}
{"text_id": 1003333, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003334, "text": "drop(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted."}
{"text_id": 1003335, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003336, "text": "drop_duplicates(self, subset: 'Hashable | Sequence[Hashable] | None' = None, keep: \"Literal['first'] | Literal['last'] | Literal[False]\" = 'first', inplace: 'bool' = False, ignore_index: 'bool' = False) -> 'DataFrame | None': Return DataFrame with duplicate rows removed."}
{"text_id": 1003337, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003338, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003339, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003340, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003341, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003342, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003343, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003344, "text": "drop_duplicates(self, keep='first', inplace=False) -> 'Series | None': Return Series with duplicate values removed."}
{"text_id": 1003345, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003346, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003347, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003348, "text": "drop_duplicates(self, subset: 'Hashable | Sequence[Hashable] | None' = None, keep: \"Literal['first'] | Literal['last'] | Literal[False]\" = 'first', inplace: 'bool' = False, ignore_index: 'bool' = False) -> 'DataFrame | None': Return DataFrame with duplicate rows removed."}
{"text_id": 1003349, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003350, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003351, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003352, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003353, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003354, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003355, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003356, "text": "drop_duplicates(self, keep='first', inplace=False) -> 'Series | None': Return Series with duplicate values removed."}
{"text_id": 1003357, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003358, "text": "drop_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed."}
{"text_id": 1003359, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003360, "text": "droplevel(self: 'FrameOrSeries', level, axis=0) -> 'FrameOrSeries': Return Series/DataFrame with requested index / column level(s) removed."}
{"text_id": 1003361, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003362, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003363, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003364, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003365, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003366, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003367, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003368, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003369, "text": "droplevel(self: 'FrameOrSeries', level, axis=0) -> 'FrameOrSeries': Return Series/DataFrame with requested index / column level(s) removed."}
{"text_id": 1003370, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003371, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003372, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003373, "text": "droplevel(self: 'FrameOrSeries', level, axis=0) -> 'FrameOrSeries': Return Series/DataFrame with requested index / column level(s) removed."}
{"text_id": 1003374, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003375, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003376, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003377, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003378, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003379, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003380, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003381, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003382, "text": "droplevel(self: 'FrameOrSeries', level, axis=0) -> 'FrameOrSeries': Return Series/DataFrame with requested index / column level(s) removed."}
{"text_id": 1003383, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003384, "text": "droplevel(self, level=0): Return index with requested level(s) removed."}
{"text_id": 1003385, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003386, "text": "duplicated(self, subset: 'Hashable | Sequence[Hashable] | None' = None, keep: \"Literal['first'] | Literal['last'] | Literal[False]\" = 'first') -> 'Series': Return boolean Series denoting duplicate rows."}
{"text_id": 1003387, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003388, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003389, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003390, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003391, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003392, "text": "duplicated(self, keep='first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003393, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003394, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003395, "text": "duplicated(self, keep='first') -> 'Series': Indicate duplicate Series values."}
{"text_id": 1003396, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003397, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003398, "text": "duplicated(values: 'ArrayLike', keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Return boolean ndarray denoting duplicate values."}
{"text_id": 1003399, "text": "duplicated(values: 'ArrayLike', keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Return boolean ndarray denoting duplicate values."}
{"text_id": 1003400, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003401, "text": "duplicated(self, subset: 'Hashable | Sequence[Hashable] | None' = None, keep: \"Literal['first'] | Literal['last'] | Literal[False]\" = 'first') -> 'Series': Return boolean Series denoting duplicate rows."}
{"text_id": 1003402, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003403, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003404, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003405, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003406, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003407, "text": "duplicated(self, keep='first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003408, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003409, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003410, "text": "duplicated(self, keep='first') -> 'Series': Indicate duplicate Series values."}
{"text_id": 1003411, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003412, "text": "duplicated(self, keep: \"Literal[('first', 'last', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values."}
{"text_id": 1003413, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003414, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003415, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003416, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003417, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003418, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003419, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003420, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003421, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003422, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003423, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003424, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003425, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003426, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003427, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003428, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003429, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003430, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003431, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003432, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003433, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003434, "text": "get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'np.ndarray': Compute indexer and mask for new index given the current index."}
{"text_id": 1003435, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003436, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003437, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003438, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003439, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003440, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003441, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003442, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003443, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003444, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003445, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003446, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003447, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003448, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003449, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003450, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003451, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003452, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003453, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003454, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003455, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003456, "text": "get_indexer_for(self, target, **kwargs) -> 'np.ndarray': Guaranteed return of an indexer even when non-unique."}
{"text_id": 1003457, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003458, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003459, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003460, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003461, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003462, "text": "get_indexer_non_unique(self, target: 'Index') -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003463, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003464, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003465, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003466, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003467, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003468, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003469, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003470, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003471, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003472, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003473, "text": "get_indexer_non_unique(self, target: 'Index') -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003474, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003475, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003476, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003477, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003478, "text": "get_indexer_non_unique(self, target) -> 'tuple[np.ndarray, np.ndarray]': Compute indexer and mask for new index given the current index."}
{"text_id": 1003479, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003480, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003481, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003482, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003483, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003484, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003485, "text": "get_level_values(self, level): Return vector of label values for requested level."}
{"text_id": 1003486, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003487, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003488, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003489, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003490, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003491, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003492, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003493, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003494, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003495, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003496, "text": "get_level_values(self, level): Return vector of label values for requested level."}
{"text_id": 1003497, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003498, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003499, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003500, "text": "get_level_values(self, level) -> 'Index': Return an Index of values for requested level."}
{"text_id": 1003501, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003502, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location for requested label."}
{"text_id": 1003503, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003504, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003505, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003506, "text": "get_loc(self, key, method: 'str | None' = None, tolerance=None) -> 'int | slice | np.ndarray': Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003507, "text": "get_loc(self, key, method=None): Get location for a label or a tuple of labels."}
{"text_id": 1003508, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location for requested label."}
{"text_id": 1003509, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003510, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location for requested label."}
{"text_id": 1003511, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003512, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003513, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location for requested label."}
{"text_id": 1003514, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003515, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003516, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003517, "text": "get_loc(self, key, method: 'str | None' = None, tolerance=None) -> 'int | slice | np.ndarray': Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003518, "text": "get_loc(self, key, method=None): Get location for a label or a tuple of labels."}
{"text_id": 1003519, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location for requested label."}
{"text_id": 1003520, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003521, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location for requested label."}
{"text_id": 1003522, "text": "get_loc(self, key, method=None, tolerance=None): Get integer location, slice or boolean mask for requested label."}
{"text_id": 1003523, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003524, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003525, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003526, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003527, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003528, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003529, "text": "get_slice_bound(self, label: 'Hashable | Sequence[Hashable]', side: 'str', kind: 'str | None' = None) -> 'int': For an ordered MultiIndex, compute slice bound that corresponds to given label."}
{"text_id": 1003530, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003531, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003532, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003533, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003534, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003535, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003536, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003537, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003538, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003539, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003540, "text": "get_slice_bound(self, label: 'Hashable | Sequence[Hashable]', side: 'str', kind: 'str | None' = None) -> 'int': For an ordered MultiIndex, compute slice bound that corresponds to given label."}
{"text_id": 1003541, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003542, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003543, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003544, "text": "get_slice_bound(self, label, side: 'str_t', kind=None) -> 'int': Calculate slice bound that corresponds to given label."}
{"text_id": 1003545, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003546, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003547, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003548, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003549, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003550, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003551, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003552, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003553, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003554, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003555, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003556, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003557, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003558, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003559, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003560, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003561, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003562, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003563, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003564, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003565, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003566, "text": "get_value(self, series: 'Series', key): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1003567, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003568, "text": "groupby(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, dropna: 'bool' = True) -> 'DataFrameGroupBy': Group DataFrame using a mapper or by a Series of columns."}
{"text_id": 1003569, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003570, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003571, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003572, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003573, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003574, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003575, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003576, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003577, "text": "groupby(self, by=None, axis=0, level=None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, dropna: 'bool' = True) -> 'SeriesGroupBy': Group Series using a mapper or by a Series of columns."}
{"text_id": 1003578, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003579, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003580, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003581, "text": "groupby(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, dropna: 'bool' = True) -> 'DataFrameGroupBy': Group DataFrame using a mapper or by a Series of columns."}
{"text_id": 1003582, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003583, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003584, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003585, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003586, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003587, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003588, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003589, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003590, "text": "groupby(self, by=None, axis=0, level=None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, dropna: 'bool' = True) -> 'SeriesGroupBy': Group Series using a mapper or by a Series of columns."}
{"text_id": 1003591, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003592, "text": "groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]': Group the index labels by a given array of values."}
{"text_id": 1003593, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003594, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003595, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003596, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003597, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003598, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003599, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003600, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003601, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003602, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003603, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003604, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003605, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003606, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003607, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003608, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003609, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003610, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003611, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003612, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003613, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003614, "text": "holds_integer(self) -> 'bool': Whether the type is an integer type."}
{"text_id": 1003615, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003616, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003617, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003618, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003619, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003620, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003621, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003622, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003623, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003624, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003625, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003626, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003627, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003628, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003629, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003630, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003631, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003632, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003633, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003634, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003635, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003636, "text": "identical(self, other) -> 'bool': Similar to equals, but checks that object attributes and types are also equal."}
{"text_id": 1003637, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003638, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003639, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003640, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003641, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003642, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003643, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003644, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003645, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003646, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003647, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003648, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003649, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003650, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003651, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003652, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003653, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003654, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003655, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003656, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003657, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003658, "text": "intersection(self, other, sort=False): Form the intersection of two Index objects."}
{"text_id": 1003659, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003660, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003661, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003662, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003663, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003664, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003665, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003666, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003667, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003668, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003669, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003670, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003671, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003672, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003673, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003674, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003675, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003676, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003677, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003678, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003679, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003680, "text": "is_boolean(self) -> 'bool': Check if the Index only consists of booleans."}
{"text_id": 1003681, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003682, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003683, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003684, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003685, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003686, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003687, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003688, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003689, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003690, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003691, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003692, "text": "is_categorical(arr) -> 'bool': Check whether an array-like is a Categorical instance."}
{"text_id": 1003693, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003694, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003695, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003696, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003697, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003698, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003699, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003700, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003701, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003702, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003703, "text": "is_categorical(self) -> 'bool': Check if the Index holds categorical data."}
{"text_id": 1003704, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003705, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003706, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003707, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003708, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003709, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003710, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003711, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003712, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003713, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003714, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003715, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003716, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003717, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003718, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003719, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003720, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003721, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003722, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003723, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003724, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003725, "text": "is_floating(self) -> 'bool': Check if the Index is a floating type."}
{"text_id": 1003726, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003727, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003728, "text": "is_integer(self, /): Return True if the float is an integer."}
{"text_id": 1003729, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003730, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003731, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003732, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003733, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003734, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003735, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003736, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003737, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003738, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003739, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003740, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003741, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003742, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003743, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003744, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003745, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003746, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003747, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003748, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003749, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003750, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003751, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003752, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003753, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003754, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003755, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003756, "text": "is_integer(): Return True if the float is an integer."}
{"text_id": 1003757, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003758, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003759, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003760, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003761, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003762, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003763, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003764, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003765, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003766, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003767, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003768, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003769, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003770, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003771, "text": "is_integer(self) -> 'bool': Check if the Index only consists of integers."}
{"text_id": 1003772, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003773, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003774, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003775, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003776, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003777, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003778, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003779, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003780, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003781, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003782, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003783, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003784, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003785, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003786, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003787, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003788, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003789, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003790, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003791, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003792, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003793, "text": "is_interval(self) -> 'bool': Check if the Index holds Interval objects."}
{"text_id": 1003794, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003795, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003796, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003797, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003798, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003799, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003800, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003801, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003802, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003803, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003804, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003805, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003806, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003807, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003808, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003809, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003810, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003811, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003812, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003813, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003814, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003815, "text": "is_mixed(self) -> 'bool': Check if the Index holds data with mixed data types."}
{"text_id": 1003816, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003817, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003818, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003819, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003820, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003821, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003822, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003823, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003824, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003825, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003826, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003827, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003828, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003829, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003830, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003831, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003832, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003833, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003834, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003835, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003836, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003837, "text": "is_numeric(self) -> 'bool': Check if the Index only consists of numeric data."}
{"text_id": 1003838, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003839, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003840, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003841, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003842, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003843, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003844, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003845, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003846, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003847, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003848, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003849, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003850, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003851, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003852, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003853, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003854, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003855, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003856, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003857, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003858, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003859, "text": "is_object(self) -> 'bool': Check if the Index is of the object dtype."}
{"text_id": 1003860, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003861, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003862, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003863, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003864, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003865, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003866, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003867, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003868, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003869, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003870, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003871, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003872, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003873, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003874, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003875, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003876, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003877, "text": "is_type_compatible(self, kind: 'str_t') -> 'bool': Whether the index type is compatible with the provided type."}
{"text_id": 1003878, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003879, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003880, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003881, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003882, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003883, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003884, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003885, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003886, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003887, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003888, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003889, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003890, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003891, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003892, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003893, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003894, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003895, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003896, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003897, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003898, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003899, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003900, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003901, "text": "item(self): Return the first element of the underlying data as a Python scalar."}
{"text_id": 1003902, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003903, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003904, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003905, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003906, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003907, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003908, "text": "fset(self, names, level=None, validate: 'bool' = True): Set new names on index."}
{"text_id": 1003909, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003910, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003911, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003912, "text": "fset(self, values, level=None) -> 'None': Set new names on index."}
{"text_id": 1003913, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003914, "text": "nunique(self, axis: 'Axis' = 0, dropna: 'bool' = True) -> 'Series': Count number of distinct elements in specified axis."}
{"text_id": 1003915, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003916, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003917, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003918, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003919, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003920, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003921, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003922, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003923, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003924, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003925, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003926, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003927, "text": "nunique(self, axis: 'Axis' = 0, dropna: 'bool' = True) -> 'Series': Count number of distinct elements in specified axis."}
{"text_id": 1003928, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003929, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003930, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003931, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003932, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003933, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003934, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003935, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003936, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003937, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003938, "text": "nunique(self, dropna: 'bool' = True) -> 'int': Return number of unique elements in the object."}
{"text_id": 1003939, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003940, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003941, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003942, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003943, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003944, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003945, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003946, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003947, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003948, "text": "ravel(self, order='C'): Return the flattened underlying data as an ndarray."}
{"text_id": 1003949, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003950, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003951, "text": "ravel(self, order: \"Literal[('C', 'F', 'A', 'K')] | None\" = 'C') -> 'ExtensionArray': Return a flattened view on this array."}
{"text_id": 1003952, "text": "ravel(self, order: \"Literal[('C', 'F', 'A', 'K')] | None\" = 'C') -> 'ExtensionArray': Return a flattened view on this array."}
{"text_id": 1003953, "text": "ravel(self, order: \"Literal[('C', 'F', 'A', 'K')] | None\" = 'C') -> 'ExtensionArray': Return a flattened view on this array."}
{"text_id": 1003954, "text": "ravel(self, order: \"Literal[('C', 'F', 'A', 'K')] | None\" = 'C') -> 'ExtensionArray': Return a flattened view on this array."}
{"text_id": 1003955, "text": "ravel(self, order: \"Literal[('C', 'F', 'A', 'K')] | None\" = 'C') -> 'ExtensionArray': Return a flattened view on this array."}
{"text_id": 1003956, "text": "ravel(self, order: \"Literal[('C', 'F', 'A', 'K')] | None\" = 'C') -> 'ExtensionArray': Return a flattened view on this array."}
{"text_id": 1003957, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003958, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003959, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003960, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003961, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003962, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003963, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003964, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003965, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003966, "text": "ravel(self, order='C'): Return the flattened underlying data as an ndarray."}
{"text_id": 1003967, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003968, "text": "ravel(self, order='C'): Return an ndarray of the flattened values of the underlying data."}
{"text_id": 1003969, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values (move/add/delete values as necessary)."}
{"text_id": 1003970, "text": "reindex(self, labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None): Conform Series/DataFrame to new index with optional filling logic."}
{"text_id": 1003971, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003972, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003973, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003974, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003975, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003976, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create index with target's values (move/add/delete values as necessary)."}
{"text_id": 1003977, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003978, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003979, "text": "reindex(self, index=None, **kwargs): Conform Series to new index with optional filling logic."}
{"text_id": 1003980, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003981, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003982, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values (move/add/delete values as necessary)."}
{"text_id": 1003983, "text": "reindex(self, labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None): Conform Series/DataFrame to new index with optional filling logic."}
{"text_id": 1003984, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003985, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003986, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003987, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003988, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003989, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create index with target's values (move/add/delete values as necessary)."}
{"text_id": 1003990, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003991, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003992, "text": "reindex(self, index=None, **kwargs): Conform Series to new index with optional filling logic."}
{"text_id": 1003993, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003994, "text": "reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, np.ndarray | None]': Create index with target's values."}
{"text_id": 1003995, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1003996, "text": "rename(self, mapper=None, index=None, columns=None, axis=None, copy=True, inplace=False, level=None, errors='ignore'): Alter axes labels."}
{"text_id": 1003997, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1003998, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1003999, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004000, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004001, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004002, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004003, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004004, "text": "rename(self, index=None, *, axis=None, copy=True, inplace=False, level=None, errors='ignore'): Alter Series index labels or name."}
{"text_id": 1004005, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004006, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004007, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004008, "text": "rename(self, mapper=None, index=None, columns=None, axis=None, copy=True, inplace=False, level=None, errors='ignore'): Alter axes labels."}
{"text_id": 1004009, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004010, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004011, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004012, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004013, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004014, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004015, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004016, "text": "rename(self, index=None, *, axis=None, copy=True, inplace=False, level=None, errors='ignore'): Alter Series index labels or name."}
{"text_id": 1004017, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004018, "text": "rename(self, name, inplace=False): Alter Index or MultiIndex name."}
{"text_id": 1004019, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004020, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004021, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004022, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004023, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004024, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004025, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004026, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004027, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004028, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004029, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004030, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004031, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004032, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004033, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004034, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004035, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004036, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004037, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004038, "text": "set_names(self, names, level=None, inplace: 'bool' = False): Set Index or MultiIndex name."}
{"text_id": 1004039, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004040, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004041, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004042, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004043, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004044, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004045, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004046, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004047, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004048, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004049, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004050, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004051, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004052, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004053, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004054, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004055, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004056, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004057, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004058, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004059, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004060, "text": "set_value(self, arr, key, value): Fast lookup of value from 1-dimensional ndarray."}
{"text_id": 1004061, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004062, "text": "slice_indexer(self, start=None, end=None, step=None, kind=None): Return indexer for specified label slice."}
{"text_id": 1004063, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004064, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004065, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004066, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004067, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004068, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004069, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004070, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004071, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004072, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004073, "text": "slice_indexer(self, start=None, end=None, step=None, kind=None): Return indexer for specified label slice."}
{"text_id": 1004074, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004075, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004076, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004077, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004078, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004079, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004080, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004081, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004082, "text": "slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind: 'str_t | None' = None) -> 'slice': Compute the slice indexer for input labels and step."}
{"text_id": 1004083, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004084, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004085, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004086, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004087, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004088, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004089, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): For an ordered MultiIndex, compute the slice locations for input labels."}
{"text_id": 1004090, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004091, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004092, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004093, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004094, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004095, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004096, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004097, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004098, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004099, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004100, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): For an ordered MultiIndex, compute the slice locations for input labels."}
{"text_id": 1004101, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004102, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004103, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004104, "text": "slice_locs(self, start=None, end=None, step=None, kind=None): Compute slice locations for input labels."}
{"text_id": 1004105, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004106, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004107, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004108, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004109, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004110, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004111, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004112, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004113, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004114, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004115, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004116, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004117, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004118, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004119, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004120, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004121, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004122, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004123, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004124, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004125, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004126, "text": "sort(self, *args, **kwargs): Use sort_values instead."}
{"text_id": 1004127, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004128, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004129, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004130, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004131, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004132, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004133, "text": "sortlevel(self, level=0, ascending: 'bool' = True, sort_remaining: 'bool' = True) -> 'tuple[MultiIndex, np.ndarray]': Sort MultiIndex at the requested level."}
{"text_id": 1004134, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004135, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004136, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004137, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004138, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004139, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004140, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004141, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004142, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004143, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004144, "text": "sortlevel(self, level=0, ascending: 'bool' = True, sort_remaining: 'bool' = True) -> 'tuple[MultiIndex, np.ndarray]': Sort MultiIndex at the requested level."}
{"text_id": 1004145, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004146, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004147, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004148, "text": "sortlevel(self, level=None, ascending=True, sort_remaining=None): For internal compatibility with the Index API."}
{"text_id": 1004149, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004150, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004151, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004152, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004153, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004154, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004155, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004156, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004157, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004158, "text": "cat(data): Accessor object for categorical properties of the Series values."}
{"text_id": 1004159, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004160, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004161, "text": "cat(self, others=None, sep=None, na_rep=None, join='left'): Concatenate strings in the Series/Index with given separator."}
{"text_id": 1004162, "text": "cat(data): Accessor object for categorical properties of the Series values."}
{"text_id": 1004163, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004164, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004165, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004166, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004167, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004168, "text": "contains(self, *args, **kwargs): Check elementwise if the Intervals contain the value."}
{"text_id": 1004169, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004170, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004171, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004172, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004173, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004174, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004175, "text": "contains(self, pat, case=True, flags=0, na=None, regex=True): Test if pattern or regex is contained within a string of a Series or Index."}
{"text_id": 1004176, "text": "contains(self, other): Check elementwise if the Intervals contain the value."}
{"text_id": 1004177, "text": "contains(self, *args, **kwargs): Check elementwise if the Intervals contain the value."}
{"text_id": 1004178, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004179, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004180, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004181, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004182, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004183, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004184, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004185, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004186, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004187, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004188, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004189, "text": "decode(self, encoding, errors='strict'): Decode character string in the Series/Index using indicated encoding."}
{"text_id": 1004190, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004191, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004192, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004193, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004194, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004195, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004196, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004197, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004198, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004199, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004200, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004201, "text": "extract(self, pat: 'str', flags: 'int' = 0, expand: 'bool' = True) -> 'FrameOrSeriesUnion | Index': Extract capture groups in the regex `pat` as columns in a DataFrame."}
{"text_id": 1004202, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004203, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004204, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004205, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004206, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004207, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004208, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004209, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004210, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004211, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004212, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004213, "text": "extractall(self, pat, flags=0): Extract capture groups in the regex `pat` as columns in DataFrame."}
{"text_id": 1004214, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004215, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004216, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004217, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004218, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004219, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004220, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004221, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004222, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004223, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004224, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004225, "text": "findall(self, pat, flags=0): Find all occurrences of pattern or regular expression in the Series/Index."}
{"text_id": 1004226, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004227, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004228, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004229, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004230, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004231, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004232, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004233, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004234, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004235, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004236, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004237, "text": "fullmatch(self, pat, case=True, flags=0, na=None): Determine if each string entirely matches a regular expression."}
{"text_id": 1004238, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004239, "text": "get(self, key, default=None): Get item from object for given key (ex: DataFrame column)."}
{"text_id": 1004240, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004241, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004242, "text": "get(self, key: 'str'): Retrieve pandas object stored in file."}
{"text_id": 1004243, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004244, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004245, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004246, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004247, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004248, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004249, "text": "get(self, key, default=None): Get item from object for given key (ex: DataFrame column)."}
{"text_id": 1004250, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004251, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004252, "text": "get(self, i): Extract element from each component at specified position."}
{"text_id": 1004253, "text": "get(self, key, default=None): Get item from object for given key (ex: DataFrame column)."}
{"text_id": 1004254, "text": "get(self, key: 'str'): Retrieve pandas object stored in file."}
{"text_id": 1004255, "text": "get(self, key, default=None): Get item from object for given key (ex: DataFrame column)."}
{"text_id": 1004256, "text": "get(key, default=None, /): Return the value for key if key is in the dictionary, else default."}
{"text_id": 1004257, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004258, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004259, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004260, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004261, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004262, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004263, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004264, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004265, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004266, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004267, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004268, "text": "get_dummies(self, sep='|'): Return DataFrame of dummy/indicator variables for Series."}
{"text_id": 1004269, "text": "get_dummies(data, prefix=None, prefix_sep='_', dummy_na: 'bool' = False, columns=None, sparse: 'bool' = False, drop_first: 'bool' = False, dtype: 'Dtype | None' = None) -> 'DataFrame': Convert categorical variable into dummy/indicator variables."}
{"text_id": 1004270, "text": "get_dummies(data, prefix=None, prefix_sep='_', dummy_na: 'bool' = False, columns=None, sparse: 'bool' = False, drop_first: 'bool' = False, dtype: 'Dtype | None' = None) -> 'DataFrame': Convert categorical variable into dummy/indicator variables."}
{"text_id": 1004271, "text": "get_dummies(data, prefix=None, prefix_sep='_', dummy_na: 'bool' = False, columns=None, sparse: 'bool' = False, drop_first: 'bool' = False, dtype: 'Dtype | None' = None) -> 'DataFrame': Convert categorical variable into dummy/indicator variables."}
{"text_id": 1004272, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004273, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004274, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004275, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004276, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004277, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004278, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004279, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004280, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004281, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004282, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004283, "text": "len(self): Compute the length of each element in the Series/Index."}
{"text_id": 1004284, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004285, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004286, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004287, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004288, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004289, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004290, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004291, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004292, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004293, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004294, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004295, "text": "match(self, pat, case=True, flags=0, na=None): Determine if each string starts with a match of a regular expression."}
{"text_id": 1004296, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004297, "text": "normalize(self, *args, **kwargs): Convert times to midnight."}
{"text_id": 1004298, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004299, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004300, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004301, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004302, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004303, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004304, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004305, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004306, "text": "normalize(self, *args, **kwargs): Convert times to midnight."}
{"text_id": 1004307, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004308, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004309, "text": "normalize(self, form): Return the Unicode normal form for the strings in the Series/Index."}
{"text_id": 1004310, "text": "normalize(self) -> 'DatetimeArray': Convert times to midnight."}
{"text_id": 1004311, "text": "normalize(self, *args, **kwargs): Convert times to midnight."}
{"text_id": 1004312, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004313, "text": "pad(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004314, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004315, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004316, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004317, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004318, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004319, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004320, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004321, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004322, "text": "pad(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004323, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004324, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004325, "text": "pad(self, width, side='left', fillchar=' '): Pad strings in the Series/Index up to width."}
{"text_id": 1004326, "text": "pad(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004327, "text": "pad(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004328, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004329, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004330, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004331, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004332, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004333, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004334, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004335, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004336, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004337, "text": "repeat(self, repeats: 'int', axis=None) -> 'MultiIndex': Repeat elements of a MultiIndex."}
{"text_id": 1004338, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004339, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004340, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004341, "text": "repeat(self, repeats, axis=None) -> 'Series': Repeat elements of a Series."}
{"text_id": 1004342, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004343, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004344, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004345, "text": "repeat(self, repeats): Duplicate each string in the Series or Index."}
{"text_id": 1004346, "text": "repeat(self, repeats: 'int | Sequence[int]', axis: 'int | None' = None): Repeat elements of a ExtensionArray."}
{"text_id": 1004347, "text": "repeat(self, repeats: 'int | Sequence[int]', axis: 'int | None' = None): Repeat elements of a ExtensionArray."}
{"text_id": 1004348, "text": "repeat(self, repeats: 'int | Sequence[int]', axis: 'int | None' = None): Repeat elements of a ExtensionArray."}
{"text_id": 1004349, "text": "repeat(self, repeats: 'int | Sequence[int]', axis: 'int | None' = None): Repeat elements of a ExtensionArray."}
{"text_id": 1004350, "text": "repeat(self: 'IntervalArrayT', repeats: 'int | Sequence[int]', axis: 'int | None' = None) -> 'IntervalArrayT': Repeat elements of a IntervalArray."}
{"text_id": 1004351, "text": "repeat(self, repeats: 'int | Sequence[int]', axis: 'int | None' = None): Repeat elements of a ExtensionArray."}
{"text_id": 1004352, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004353, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004354, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004355, "text": "repeat(self, repeats: 'int', axis=None) -> 'MultiIndex': Repeat elements of a MultiIndex."}
{"text_id": 1004356, "text": "repeat(self, repeats, axis=None) -> 'Series': Repeat elements of a Series."}
{"text_id": 1004357, "text": "repeat(self, repeats, axis=None): Repeat elements of a Index."}
{"text_id": 1004358, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004359, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004360, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004361, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004362, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004363, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004364, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004365, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004366, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004367, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004368, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004369, "text": "slice(self, start=None, stop=None, step=None): Slice substrings from each element in the Series or Index."}
{"text_id": 1004370, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004371, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004372, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004373, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004374, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004375, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004376, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004377, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004378, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004379, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004380, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004381, "text": "slice_replace(self, start=None, stop=None, repl=None): Replace a positional slice of a string with another value."}
{"text_id": 1004382, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004383, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004384, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004385, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004386, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004387, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004388, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004389, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004390, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004391, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004392, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004393, "text": "wrap(self, width, **kwargs): Wrap strings in Series/Index at specified line width."}
{"text_id": 1004394, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004395, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004396, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004397, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004398, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004399, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004400, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004401, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004402, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004403, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004404, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004405, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004406, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004407, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004408, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004409, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004410, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004411, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004412, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004413, "text": "symmetric_difference(self, other, result_name=None, sort=None): Compute the symmetric difference of two Index objects."}
{"text_id": 1004414, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004415, "text": "take(self: 'FrameOrSeries', indices, axis=0, is_copy: 'bool_t | None' = None, **kwargs) -> 'FrameOrSeries': Return the elements in the given *positional* indices along an axis."}
{"text_id": 1004416, "text": "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004417, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004418, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004419, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004420, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004421, "text": "take(self: 'MultiIndex', indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs) -> 'MultiIndex': Return a new MultiIndex of the values selected by the indices."}
{"text_id": 1004422, "text": "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004423, "text": "take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series': Return the elements in the given *positional* indices along an axis."}
{"text_id": 1004424, "text": "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004425, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004426, "text": "take(arr, indices: 'np.ndarray', axis: 'int' = 0, allow_fill: 'bool' = False, fill_value=None): Take elements from an array."}
{"text_id": 1004427, "text": "take(self, indices: 'Sequence[int]', allow_fill: 'bool' = False, fill_value: 'Any' = None): Take elements from an array."}
{"text_id": 1004428, "text": "take(self: 'IntervalArrayT', indices, *, allow_fill: 'bool' = False, fill_value=None, axis=None, **kwargs) -> 'IntervalArrayT': Take elements from the IntervalArray."}
{"text_id": 1004429, "text": "take(arr, indices: 'np.ndarray', axis: 'int' = 0, allow_fill: 'bool' = False, fill_value=None): Take elements from an array."}
{"text_id": 1004430, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004431, "text": "take(self: 'FrameOrSeries', indices, axis=0, is_copy: 'bool_t | None' = None, **kwargs) -> 'FrameOrSeries': Return the elements in the given *positional* indices along an axis."}
{"text_id": 1004432, "text": "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004433, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004434, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004435, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004436, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004437, "text": "take(self: 'MultiIndex', indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs) -> 'MultiIndex': Return a new MultiIndex of the values selected by the indices."}
{"text_id": 1004438, "text": "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004439, "text": "take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series': Return the elements in the given *positional* indices along an axis."}
{"text_id": 1004440, "text": "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004441, "text": "take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs): Return a new Index of the values selected by the indices."}
{"text_id": 1004442, "text": "take_nd(self, *args, **kwargs): Alias for `take`."}
{"text_id": 1004443, "text": "take_nd(arr: 'ArrayLike', indexer, axis: 'int' = 0, fill_value=<no_default>, allow_fill: 'bool' = True) -> 'ArrayLike': Specialized Cython take which sets NaN values in one pass This dispatches to ``take`` defined on ExtensionArrays."}
{"text_id": 1004444, "text": "take_nd(self, *args, **kwargs): Alias for `take`."}
{"text_id": 1004445, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004446, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004447, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004448, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004449, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004450, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004451, "text": "to_flat_index(self) -> 'Index': Convert a MultiIndex to an Index of Tuples containing the level values."}
{"text_id": 1004452, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004453, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004454, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004455, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004456, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004457, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004458, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004459, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004460, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004461, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004462, "text": "to_flat_index(self) -> 'Index': Convert a MultiIndex to an Index of Tuples containing the level values."}
{"text_id": 1004463, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004464, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004465, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004466, "text": "to_flat_index(self): Identity method."}
{"text_id": 1004467, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004468, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004469, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004470, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004471, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004472, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004473, "text": "to_frame(self, index: 'bool' = True, name=None) -> 'DataFrame': Create a DataFrame with the levels of the MultiIndex as columns."}
{"text_id": 1004474, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004475, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004476, "text": "to_frame(self, name=None) -> 'DataFrame': Convert Series to DataFrame."}
{"text_id": 1004477, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004478, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004479, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004480, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004481, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004482, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004483, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004484, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004485, "text": "to_frame(self, index: 'bool' = True, name=None) -> 'DataFrame': Create a DataFrame with the levels of the MultiIndex as columns."}
{"text_id": 1004486, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004487, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004488, "text": "to_frame(self, name=None) -> 'DataFrame': Convert Series to DataFrame."}
{"text_id": 1004489, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004490, "text": "to_frame(self, index: 'bool' = True, name: 'Hashable' = None) -> 'DataFrame': Create a DataFrame with a column containing the Index."}
{"text_id": 1004491, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004492, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004493, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004494, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004495, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004496, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004497, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004498, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004499, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004500, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004501, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004502, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004503, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004504, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004505, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004506, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004507, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004508, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004509, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004510, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004511, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004512, "text": "to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray': Format specified values of `self` and return them."}
{"text_id": 1004513, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004514, "text": "to_series(self, keep_tz=<no_default>, index=None, name=None): Create a Series with both index and values equal to the index keys useful with map for returning an indexer based on an index."}
{"text_id": 1004515, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004516, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004517, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004518, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004519, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004520, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004521, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004522, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004523, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004524, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004525, "text": "to_series(self, keep_tz=<no_default>, index=None, name=None): Create a Series with both index and values equal to the index keys useful with map for returning an indexer based on an index."}
{"text_id": 1004526, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004527, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004528, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004529, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004530, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004531, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004532, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004533, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004534, "text": "to_series(self, index=None, name: 'Hashable' = None) -> 'Series': Create a Series with both index and values equal to the index keys."}
{"text_id": 1004535, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004536, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004537, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004538, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004539, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004540, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004541, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004542, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004543, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004544, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004545, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004546, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004547, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004548, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004549, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004550, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004551, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004552, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004553, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004554, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004555, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004556, "text": "union(self, other, sort=None): Form the union of two Index objects."}
{"text_id": 1004557, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004558, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004559, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004560, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004561, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004562, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004563, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004564, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004565, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004566, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004567, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004568, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004569, "text": "DataFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None): Two-dimensional, size-mutable, potentially heterogeneous tabular data."}
{"text_id": 1004570, "text": "abs(self: 'FrameOrSeries') -> 'FrameOrSeries': Return a Series/DataFrame with absolute numeric value of each element."}
{"text_id": 1004571, "text": "abs(self: 'FrameOrSeries') -> 'FrameOrSeries': Return a Series/DataFrame with absolute numeric value of each element."}
{"text_id": 1004572, "text": "abs(self: 'FrameOrSeries') -> 'FrameOrSeries': Return a Series/DataFrame with absolute numeric value of each element."}
{"text_id": 1004573, "text": "abs(self: 'FrameOrSeries') -> 'FrameOrSeries': Return a Series/DataFrame with absolute numeric value of each element."}
{"text_id": 1004574, "text": "add(self, other, axis='columns', level=None, fill_value=None): Get Addition of dataframe and other, element-wise (binary operator `add`)."}
{"text_id": 1004575, "text": "add(self, other, level=None, fill_value=None, axis=0): Return Addition of series and other, element-wise (binary operator `add`)."}
{"text_id": 1004576, "text": "add(self, other, axis='columns', level=None, fill_value=None): Get Addition of dataframe and other, element-wise (binary operator `add`)."}
{"text_id": 1004577, "text": "add(self, other, level=None, fill_value=None, axis=0): Return Addition of series and other, element-wise (binary operator `add`)."}
{"text_id": 1004578, "text": "add_prefix(self: 'FrameOrSeries', prefix: 'str') -> 'FrameOrSeries': Prefix labels with string `prefix`."}
{"text_id": 1004579, "text": "add_prefix(self: 'FrameOrSeries', prefix: 'str') -> 'FrameOrSeries': Prefix labels with string `prefix`."}
{"text_id": 1004580, "text": "add_prefix(self: 'FrameOrSeries', prefix: 'str') -> 'FrameOrSeries': Prefix labels with string `prefix`."}
{"text_id": 1004581, "text": "add_prefix(self: 'FrameOrSeries', prefix: 'str') -> 'FrameOrSeries': Prefix labels with string `prefix`."}
{"text_id": 1004582, "text": "add_suffix(self: 'FrameOrSeries', suffix: 'str') -> 'FrameOrSeries': Suffix labels with string `suffix`."}
{"text_id": 1004583, "text": "add_suffix(self: 'FrameOrSeries', suffix: 'str') -> 'FrameOrSeries': Suffix labels with string `suffix`."}
{"text_id": 1004584, "text": "add_suffix(self: 'FrameOrSeries', suffix: 'str') -> 'FrameOrSeries': Suffix labels with string `suffix`."}
{"text_id": 1004585, "text": "add_suffix(self: 'FrameOrSeries', suffix: 'str') -> 'FrameOrSeries': Suffix labels with string `suffix`."}
{"text_id": 1004586, "text": "agg(self, func=None, axis: 'Axis' = 0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004587, "text": "agg(self, func=None, axis=0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004588, "text": "agg(self, func=None, axis: 'Axis' = 0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004589, "text": "agg(self, func=None, axis=0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004590, "text": "aggregate(self, func=None, axis: 'Axis' = 0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004591, "text": "aggregate(self, func=None, axis=0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004592, "text": "aggregate(self, func=None, axis: 'Axis' = 0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004593, "text": "aggregate(self, func=None, axis=0, *args, **kwargs): Aggregate using one or more operations over the specified axis."}
{"text_id": 1004594, "text": "align(self, other, join: 'str' = 'outer', axis: 'Axis | None' = None, level: 'Level | None' = None, copy: 'bool' = True, fill_value=None, method: 'str | None' = None, limit=None, fill_axis: 'Axis' = 0, broadcast_axis: 'Axis | None' = None) -> 'DataFrame': Align two objects on their axes with the specified join method."}
{"text_id": 1004595, "text": "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None): Align two objects on their axes with the specified join method."}
{"text_id": 1004596, "text": "align(self, other, join: 'str' = 'outer', axis: 'Axis | None' = None, level: 'Level | None' = None, copy: 'bool' = True, fill_value=None, method: 'str | None' = None, limit=None, fill_axis: 'Axis' = 0, broadcast_axis: 'Axis | None' = None) -> 'DataFrame': Align two objects on their axes with the specified join method."}
{"text_id": 1004597, "text": "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None): Align two objects on their axes with the specified join method."}
{"text_id": 1004598, "text": "apply(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Apply a function along an axis of the DataFrame."}
{"text_id": 1004599, "text": "apply(self, func: 'AggFuncType', convert_dtype: 'bool' = True, args: 'tuple[Any, ...]' = (), **kwargs) -> 'FrameOrSeriesUnion': Invoke function on values of Series."}
{"text_id": 1004600, "text": "apply(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Apply a function along an axis of the DataFrame."}
{"text_id": 1004601, "text": "apply(self, func: 'AggFuncType', convert_dtype: 'bool' = True, args: 'tuple[Any, ...]' = (), **kwargs) -> 'FrameOrSeriesUnion': Invoke function on values of Series."}
{"text_id": 1004602, "text": "applymap(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'DataFrame': Apply a function to a Dataframe elementwise."}
{"text_id": 1004603, "text": "applymap(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'DataFrame': Apply a function to a Dataframe elementwise."}
{"text_id": 1004604, "text": "asfreq(self, freq: 'Frequency', method=None, how: 'str | None' = None, normalize: 'bool' = False, fill_value=None) -> 'DataFrame': Convert time series to specified frequency."}
{"text_id": 1004605, "text": "asfreq(self, freq=None, how: 'str' = 'E') -> 'PeriodIndex': Convert the PeriodArray to the specified frequency `freq`."}
{"text_id": 1004606, "text": "asfreq(self, freq, method=None, how: 'str | None' = None, normalize: 'bool' = False, fill_value=None) -> 'Series': Convert time series to specified frequency."}
{"text_id": 1004607, "text": "asfreq(self, *args, **kwargs): Convert the PeriodArray to the specified frequency `freq`."}
{"text_id": 1004608, "text": "asfreq(self, freq=None, how: 'str' = 'E') -> 'PeriodArray': Convert the PeriodArray to the specified frequency `freq`."}
{"text_id": 1004609, "text": "asfreq(self, freq: 'Frequency', method=None, how: 'str | None' = None, normalize: 'bool' = False, fill_value=None) -> 'DataFrame': Convert time series to specified frequency."}
{"text_id": 1004610, "text": "asfreq(self, freq=None, how: 'str' = 'E') -> 'PeriodIndex': Convert the PeriodArray to the specified frequency `freq`."}
{"text_id": 1004611, "text": "asfreq(self, freq, method=None, how: 'str | None' = None, normalize: 'bool' = False, fill_value=None) -> 'Series': Convert time series to specified frequency."}
{"text_id": 1004612, "text": "assign(self, **kwargs) -> 'DataFrame': Assign new columns to a DataFrame."}
{"text_id": 1004613, "text": "assign(self, **kwargs) -> 'DataFrame': Assign new columns to a DataFrame."}
{"text_id": 1004614, "text": "at_time(self: 'FrameOrSeries', time, asof: 'bool_t' = False, axis=None) -> 'FrameOrSeries': Select values at particular time of day (e."}
{"text_id": 1004615, "text": "at_time(self: 'FrameOrSeries', time, asof: 'bool_t' = False, axis=None) -> 'FrameOrSeries': Select values at particular time of day (e."}
{"text_id": 1004616, "text": "at_time(self: 'FrameOrSeries', time, asof: 'bool_t' = False, axis=None) -> 'FrameOrSeries': Select values at particular time of day (e."}
{"text_id": 1004617, "text": "at_time(self: 'FrameOrSeries', time, asof: 'bool_t' = False, axis=None) -> 'FrameOrSeries': Select values at particular time of day (e."}
{"text_id": 1004618, "text": "backfill(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004619, "text": "backfill(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004620, "text": "backfill(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004621, "text": "backfill(self: 'FrameOrSeries', axis: 'None | Axis' = None, inplace: 'bool_t' = False, limit: 'None | int' = None, downcast=None) -> 'FrameOrSeries | None': Synonym for :meth:`DataFrame."}
{"text_id": 1004622, "text": "between_time(self: 'FrameOrSeries', start_time, end_time, include_start: 'bool_t' = True, include_end: 'bool_t' = True, axis=None) -> 'FrameOrSeries': Select values between particular times of the day (e."}
{"text_id": 1004623, "text": "between_time(self: 'FrameOrSeries', start_time, end_time, include_start: 'bool_t' = True, include_end: 'bool_t' = True, axis=None) -> 'FrameOrSeries': Select values between particular times of the day (e."}
{"text_id": 1004624, "text": "between_time(self: 'FrameOrSeries', start_time, end_time, include_start: 'bool_t' = True, include_end: 'bool_t' = True, axis=None) -> 'FrameOrSeries': Select values between particular times of the day (e."}
{"text_id": 1004625, "text": "between_time(self: 'FrameOrSeries', start_time, end_time, include_start: 'bool_t' = True, include_end: 'bool_t' = True, axis=None) -> 'FrameOrSeries': Select values between particular times of the day (e."}
{"text_id": 1004626, "text": "bool(self): Return the bool of a single element Series or DataFrame."}
{"text_id": 1004627, "text": "bool(self): Return the bool of a single element Series or DataFrame."}
{"text_id": 1004628, "text": "bool(self): Return the bool of a single element Series or DataFrame."}
{"text_id": 1004629, "text": "bool(self): Return the bool of a single element Series or DataFrame."}
{"text_id": 1004630, "text": "boxplot(self, column=None, by=None, ax=None, fontsize=None, rot=0, grid=True, figsize=None, layout=None, return_type=None, backend=None, **kwargs): Make a box plot from DataFrame columns."}
{"text_id": 1004631, "text": "boxplot(self, column=None, by=None, ax=None, fontsize=None, rot=0, grid=True, figsize=None, layout=None, return_type=None, backend=None, **kwargs): Make a box plot from DataFrame columns."}
{"text_id": 1004632, "text": "boxplot(data, column=None, by=None, ax=None, fontsize=None, rot=0, grid=True, figsize=None, layout=None, return_type=None, **kwargs): Make a box plot from DataFrame columns."}
{"text_id": 1004633, "text": "boxplot(data, column=None, by=None, ax=None, fontsize=None, rot=0, grid=True, figsize=None, layout=None, return_type=None, **kwargs): Make a box plot from DataFrame columns."}
{"text_id": 1004634, "text": "combine(self, other: 'DataFrame', func, fill_value=None, overwrite: 'bool' = True) -> 'DataFrame': Perform column-wise combine with another DataFrame."}
{"text_id": 1004635, "text": "combine(*args, **kwargs): Timestamp."}
{"text_id": 1004636, "text": "combine(date, time): Timestamp."}
{"text_id": 1004637, "text": "combine(*args, **kwargs): Timestamp."}
{"text_id": 1004638, "text": "combine(self, other, func, fill_value=None) -> 'Series': Combine the Series with a Series or scalar according to `func`."}
{"text_id": 1004639, "text": "combine(date, time): Timestamp."}
{"text_id": 1004640, "text": "combine(date, time): Timestamp."}
{"text_id": 1004641, "text": "combine(date, time): Timestamp."}
{"text_id": 1004642, "text": "combine(self, other: 'DataFrame', func, fill_value=None, overwrite: 'bool' = True) -> 'DataFrame': Perform column-wise combine with another DataFrame."}
{"text_id": 1004643, "text": "combine(*args, **kwargs): Timestamp."}
{"text_id": 1004644, "text": "combine(self, other, func, fill_value=None) -> 'Series': Combine the Series with a Series or scalar according to `func`."}
{"text_id": 1004645, "text": "combine(date, time): Timestamp."}
{"text_id": 1004646, "text": "combine_first(self, other: 'DataFrame') -> 'DataFrame': Update null elements with value in the same location in `other`."}
{"text_id": 1004647, "text": "combine_first(self, other) -> 'Series': Update null elements with value in the same location in 'other'."}
{"text_id": 1004648, "text": "combine_first(self, other: 'DataFrame') -> 'DataFrame': Update null elements with value in the same location in `other`."}
{"text_id": 1004649, "text": "combine_first(self, other) -> 'Series': Update null elements with value in the same location in 'other'."}
{"text_id": 1004650, "text": "compare(self, other: 'DataFrame', align_axis: 'Axis' = 1, keep_shape: 'bool' = False, keep_equal: 'bool' = False) -> 'DataFrame': Compare to another DataFrame and show the differences."}
{"text_id": 1004651, "text": "compare(self, other: 'Series', align_axis: 'Axis' = 1, keep_shape: 'bool' = False, keep_equal: 'bool' = False) -> 'FrameOrSeriesUnion': Compare to another Series and show the differences."}
{"text_id": 1004652, "text": "compare(self, other: 'DataFrame', align_axis: 'Axis' = 1, keep_shape: 'bool' = False, keep_equal: 'bool' = False) -> 'DataFrame': Compare to another DataFrame and show the differences."}
{"text_id": 1004653, "text": "compare(self, other: 'Series', align_axis: 'Axis' = 1, keep_shape: 'bool' = False, keep_equal: 'bool' = False) -> 'FrameOrSeriesUnion': Compare to another Series and show the differences."}
{"text_id": 1004654, "text": "convert_dtypes(self: 'FrameOrSeries', infer_objects: 'bool_t' = True, convert_string: 'bool_t' = True, convert_integer: 'bool_t' = True, convert_boolean: 'bool_t' = True, convert_floating: 'bool_t' = True) -> 'FrameOrSeries': Convert columns to best possible dtypes using dtypes supporting ``pd."}
{"text_id": 1004655, "text": "convert_dtypes(self: 'FrameOrSeries', infer_objects: 'bool_t' = True, convert_string: 'bool_t' = True, convert_integer: 'bool_t' = True, convert_boolean: 'bool_t' = True, convert_floating: 'bool_t' = True) -> 'FrameOrSeries': Convert columns to best possible dtypes using dtypes supporting ``pd."}
{"text_id": 1004656, "text": "convert_dtypes(input_array: 'ArrayLike', convert_string: 'bool' = True, convert_integer: 'bool' = True, convert_boolean: 'bool' = True, convert_floating: 'bool' = True) -> 'DtypeObj': Convert objects to best possible type, and optionally, to types supporting ``pd."}
{"text_id": 1004657, "text": "convert_dtypes(self: 'FrameOrSeries', infer_objects: 'bool_t' = True, convert_string: 'bool_t' = True, convert_integer: 'bool_t' = True, convert_boolean: 'bool_t' = True, convert_floating: 'bool_t' = True) -> 'FrameOrSeries': Convert columns to best possible dtypes using dtypes supporting ``pd."}
{"text_id": 1004658, "text": "convert_dtypes(self: 'FrameOrSeries', infer_objects: 'bool_t' = True, convert_string: 'bool_t' = True, convert_integer: 'bool_t' = True, convert_boolean: 'bool_t' = True, convert_floating: 'bool_t' = True) -> 'FrameOrSeries': Convert columns to best possible dtypes using dtypes supporting ``pd."}
{"text_id": 1004659, "text": "corr(self, method: 'str | Callable[[np.ndarray, np.ndarray], float]' = 'pearson', min_periods: 'int' = 1) -> 'DataFrame': Compute pairwise correlation of columns, excluding NA/null values."}
{"text_id": 1004660, "text": "corr(self, other, method='pearson', min_periods=None) -> 'float': Compute correlation with `other` Series, excluding missing values."}
{"text_id": 1004661, "text": "corr(self, method: 'str | Callable[[np.ndarray, np.ndarray], float]' = 'pearson', min_periods: 'int' = 1) -> 'DataFrame': Compute pairwise correlation of columns, excluding NA/null values."}
{"text_id": 1004662, "text": "corr(self, other, method='pearson', min_periods=None) -> 'float': Compute correlation with `other` Series, excluding missing values."}
{"text_id": 1004663, "text": "corrwith(self, other, axis: 'Axis' = 0, drop=False, method='pearson') -> 'Series': Compute pairwise correlation."}
{"text_id": 1004664, "text": "corrwith(self, other, axis: 'Axis' = 0, drop=False, method='pearson') -> 'Series': Compute pairwise correlation."}
{"text_id": 1004665, "text": "cov(self, min_periods: 'int | None' = None, ddof: 'int | None' = 1) -> 'DataFrame': Compute pairwise covariance of columns, excluding NA/null values."}
{"text_id": 1004666, "text": "cov(self, other: 'Series', min_periods: 'int | None' = None, ddof: 'int | None' = 1) -> 'float': Compute covariance with Series, excluding missing values."}
{"text_id": 1004667, "text": "cov(self, min_periods: 'int | None' = None, ddof: 'int | None' = 1) -> 'DataFrame': Compute pairwise covariance of columns, excluding NA/null values."}
{"text_id": 1004668, "text": "cov(self, other: 'Series', min_periods: 'int | None' = None, ddof: 'int | None' = 1) -> 'float': Compute covariance with Series, excluding missing values."}
{"text_id": 1004669, "text": "cummax(self, axis=None, skipna=True, *args, **kwargs): Return cumulative maximum over a DataFrame or Series axis."}
{"text_id": 1004670, "text": "cummax(self, axis=None, skipna=True, *args, **kwargs): Return cumulative maximum over a DataFrame or Series axis."}
{"text_id": 1004671, "text": "cummax(self, axis=None, skipna=True, *args, **kwargs): Return cumulative maximum over a DataFrame or Series axis."}
{"text_id": 1004672, "text": "cummax(self, axis=None, skipna=True, *args, **kwargs): Return cumulative maximum over a DataFrame or Series axis."}
{"text_id": 1004673, "text": "cummin(self, axis=None, skipna=True, *args, **kwargs): Return cumulative minimum over a DataFrame or Series axis."}
{"text_id": 1004674, "text": "cummin(self, axis=None, skipna=True, *args, **kwargs): Return cumulative minimum over a DataFrame or Series axis."}
{"text_id": 1004675, "text": "cummin(self, axis=None, skipna=True, *args, **kwargs): Return cumulative minimum over a DataFrame or Series axis."}
{"text_id": 1004676, "text": "cummin(self, axis=None, skipna=True, *args, **kwargs): Return cumulative minimum over a DataFrame or Series axis."}
{"text_id": 1004677, "text": "cumprod(self, axis=None, skipna=True, *args, **kwargs): Return cumulative product over a DataFrame or Series axis."}
{"text_id": 1004678, "text": "cumprod(self, axis=None, skipna=True, *args, **kwargs): Return cumulative product over a DataFrame or Series axis."}
{"text_id": 1004679, "text": "cumprod(self, axis=None, skipna=True, *args, **kwargs): Return cumulative product over a DataFrame or Series axis."}
{"text_id": 1004680, "text": "cumprod(self, axis=None, skipna=True, *args, **kwargs): Return cumulative product over a DataFrame or Series axis."}
{"text_id": 1004681, "text": "cumsum(self, axis=None, skipna=True, *args, **kwargs): Return cumulative sum over a DataFrame or Series axis."}
{"text_id": 1004682, "text": "cumsum(self, axis=None, skipna=True, *args, **kwargs): Return cumulative sum over a DataFrame or Series axis."}
{"text_id": 1004683, "text": "cumsum(self, axis=0, *args, **kwargs): Cumulative sum of non-NA/null values."}
{"text_id": 1004684, "text": "cumsum(self, axis=None, skipna=True, *args, **kwargs): Return cumulative sum over a DataFrame or Series axis."}
{"text_id": 1004685, "text": "cumsum(self, axis=None, skipna=True, *args, **kwargs): Return cumulative sum over a DataFrame or Series axis."}
{"text_id": 1004686, "text": "diff(self, periods: 'int' = 1, axis: 'Axis' = 0) -> 'DataFrame': First discrete difference of element."}
{"text_id": 1004687, "text": "diff(self, periods: 'int' = 1) -> 'Series': First discrete difference of element."}
{"text_id": 1004688, "text": "diff(arr, n: 'int', axis: 'int' = 0, stacklevel: 'int' = 3): difference of n between self, analogous to s-s."}
{"text_id": 1004689, "text": "diff(self, periods: 'int' = 1, axis: 'Axis' = 0) -> 'DataFrame': First discrete difference of element."}
{"text_id": 1004690, "text": "diff(self, periods: 'int' = 1) -> 'Series': First discrete difference of element."}
{"text_id": 1004691, "text": "div(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004692, "text": "div(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004693, "text": "div(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004694, "text": "div(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004695, "text": "divide(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004696, "text": "divide(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004697, "text": "divide(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004698, "text": "divide(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `truediv`)."}
{"text_id": 1004699, "text": "dot(self, other: 'AnyArrayLike | FrameOrSeriesUnion') -> 'FrameOrSeriesUnion': Compute the matrix multiplication between the DataFrame and other."}
{"text_id": 1004700, "text": "dot(self, other): Compute the dot product between the Series and the columns of other."}
{"text_id": 1004701, "text": "dot(self, other: 'AnyArrayLike | FrameOrSeriesUnion') -> 'FrameOrSeriesUnion': Compute the matrix multiplication between the DataFrame and other."}
{"text_id": 1004702, "text": "dot(self, other): Compute the dot product between the Series and the columns of other."}
{"text_id": 1004703, "text": "eq(self, other, axis='columns', level=None): Get Equal to of dataframe and other, element-wise (binary operator `eq`)."}
{"text_id": 1004704, "text": "eq(self, other, level=None, fill_value=None, axis=0): Return Equal to of series and other, element-wise (binary operator `eq`)."}
{"text_id": 1004705, "text": "eq(self, other, axis='columns', level=None): Get Equal to of dataframe and other, element-wise (binary operator `eq`)."}
{"text_id": 1004706, "text": "eq(self, other, level=None, fill_value=None, axis=0): Return Equal to of series and other, element-wise (binary operator `eq`)."}
{"text_id": 1004707, "text": "eval(self, expr: 'str', inplace: 'bool' = False, **kwargs): Evaluate a string describing operations on DataFrame columns."}
{"text_id": 1004708, "text": "eval(expr: 'str | BinOp', parser: 'str' = 'pandas', engine: 'str | None' = None, truediv=<no_default>, local_dict=None, global_dict=None, resolvers=(), level=0, target=None, inplace=False): Evaluate a Python expression as a string using various backends."}
{"text_id": 1004709, "text": "eval(self, expr: 'str', inplace: 'bool' = False, **kwargs): Evaluate a string describing operations on DataFrame columns."}
{"text_id": 1004710, "text": "eval(expr: 'str | BinOp', parser: 'str' = 'pandas', engine: 'str | None' = None, truediv=<no_default>, local_dict=None, global_dict=None, resolvers=(), level=0, target=None, inplace=False): Evaluate a Python expression as a string using various backends."}
{"text_id": 1004711, "text": "eval(expr: 'str | BinOp', parser: 'str' = 'pandas', engine: 'str | None' = None, truediv=<no_default>, local_dict=None, global_dict=None, resolvers=(), level=0, target=None, inplace=False): Evaluate a Python expression as a string using various backends."}
{"text_id": 1004712, "text": "ewm(self, com: 'float | None' = None, span: 'float | None' = None, halflife: 'float | TimedeltaConvertibleTypes | None' = None, alpha: 'float | None' = None, min_periods: 'int | None' = 0, adjust: 'bool_t' = True, ignore_na: 'bool_t' = False, axis: 'Axis' = 0, times: 'str | np.ndarray | FrameOrSeries | None' = None) -> 'ExponentialMovingWindow': Provide exponential weighted (EW) functions."}
{"text_id": 1004713, "text": "ewm(self, com: 'float | None' = None, span: 'float | None' = None, halflife: 'float | TimedeltaConvertibleTypes | None' = None, alpha: 'float | None' = None, min_periods: 'int | None' = 0, adjust: 'bool_t' = True, ignore_na: 'bool_t' = False, axis: 'Axis' = 0, times: 'str | np.ndarray | FrameOrSeries | None' = None) -> 'ExponentialMovingWindow': Provide exponential weighted (EW) functions."}
{"text_id": 1004714, "text": "ewm(self, com: 'float | None' = None, span: 'float | None' = None, halflife: 'float | TimedeltaConvertibleTypes | None' = None, alpha: 'float | None' = None, min_periods: 'int | None' = 0, adjust: 'bool_t' = True, ignore_na: 'bool_t' = False, axis: 'Axis' = 0, times: 'str | np.ndarray | FrameOrSeries | None' = None) -> 'ExponentialMovingWindow': Provide exponential weighted (EW) functions."}
{"text_id": 1004715, "text": "ewm(self, com: 'float | None' = None, span: 'float | None' = None, halflife: 'float | TimedeltaConvertibleTypes | None' = None, alpha: 'float | None' = None, min_periods: 'int | None' = 0, adjust: 'bool_t' = True, ignore_na: 'bool_t' = False, axis: 'Axis' = 0, times: 'str | np.ndarray | FrameOrSeries | None' = None) -> 'ExponentialMovingWindow': Provide exponential weighted (EW) functions."}
{"text_id": 1004716, "text": "expanding(self, min_periods: 'int' = 1, center: 'bool_t | None' = None, axis: 'Axis' = 0, method: 'str' = 'single') -> 'Expanding': Provide expanding transformations."}
{"text_id": 1004717, "text": "expanding(self, min_periods: 'int' = 1, center: 'bool_t | None' = None, axis: 'Axis' = 0, method: 'str' = 'single') -> 'Expanding': Provide expanding transformations."}
{"text_id": 1004718, "text": "expanding(self, min_periods: 'int' = 1, center: 'bool_t | None' = None, axis: 'Axis' = 0, method: 'str' = 'single') -> 'Expanding': Provide expanding transformations."}
{"text_id": 1004719, "text": "expanding(self, min_periods: 'int' = 1, center: 'bool_t | None' = None, axis: 'Axis' = 0, method: 'str' = 'single') -> 'Expanding': Provide expanding transformations."}
{"text_id": 1004720, "text": "explode(self, column: 'IndexLabel', ignore_index: 'bool' = False) -> 'DataFrame': Transform each element of a list-like to a row, replicating index values."}
{"text_id": 1004721, "text": "explode(self, ignore_index: 'bool' = False) -> 'Series': Transform each element of a list-like to a row."}
{"text_id": 1004722, "text": "explode(self, column: 'IndexLabel', ignore_index: 'bool' = False) -> 'DataFrame': Transform each element of a list-like to a row, replicating index values."}
{"text_id": 1004723, "text": "explode(self, ignore_index: 'bool' = False) -> 'Series': Transform each element of a list-like to a row."}
{"text_id": 1004724, "text": "filter(self: 'FrameOrSeries', items=None, like: 'str | None' = None, regex: 'str | None' = None, axis=None) -> 'FrameOrSeries': Subset the dataframe rows or columns according to the specified index labels."}
{"text_id": 1004725, "text": "filter(self: 'FrameOrSeries', items=None, like: 'str | None' = None, regex: 'str | None' = None, axis=None) -> 'FrameOrSeries': Subset the dataframe rows or columns according to the specified index labels."}
{"text_id": 1004726, "text": "filter(self: 'FrameOrSeries', items=None, like: 'str | None' = None, regex: 'str | None' = None, axis=None) -> 'FrameOrSeries': Subset the dataframe rows or columns according to the specified index labels."}
{"text_id": 1004727, "text": "filter(self: 'FrameOrSeries', items=None, like: 'str | None' = None, regex: 'str | None' = None, axis=None) -> 'FrameOrSeries': Subset the dataframe rows or columns according to the specified index labels."}
{"text_id": 1004728, "text": "first(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select initial periods of time series data based on a date offset."}
{"text_id": 1004729, "text": "first(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select initial periods of time series data based on a date offset."}
{"text_id": 1004730, "text": "first(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select initial periods of time series data based on a date offset."}
{"text_id": 1004731, "text": "first(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select initial periods of time series data based on a date offset."}
{"text_id": 1004732, "text": "first_valid_index(self) -> 'Hashable | None': Return index for first non-NA value or None, if no NA value is found."}
{"text_id": 1004733, "text": "first_valid_index(self) -> 'Hashable | None': Return index for first non-NA value or None, if no NA value is found."}
{"text_id": 1004734, "text": "first_valid_index(self) -> 'Hashable | None': Return index for first non-NA value or None, if no NA value is found."}
{"text_id": 1004735, "text": "first_valid_index(self) -> 'Hashable | None': Return index for first non-NA value or None, if no NA value is found."}
{"text_id": 1004736, "text": "floordiv(self, other, axis='columns', level=None, fill_value=None): Get Integer division of dataframe and other, element-wise (binary operator `floordiv`)."}
{"text_id": 1004737, "text": "floordiv(self, other, level=None, fill_value=None, axis=0): Return Integer division of series and other, element-wise (binary operator `floordiv`)."}
{"text_id": 1004738, "text": "floordiv(self, other, axis='columns', level=None, fill_value=None): Get Integer division of dataframe and other, element-wise (binary operator `floordiv`)."}
{"text_id": 1004739, "text": "floordiv(self, other, level=None, fill_value=None, axis=0): Return Integer division of series and other, element-wise (binary operator `floordiv`)."}
{"text_id": 1004740, "text": "from_dict(data, orient: 'str' = 'columns', dtype: 'Dtype | None' = None, columns=None) -> 'DataFrame': Construct DataFrame from dict of array-like or dicts."}
{"text_id": 1004741, "text": "from_dict(data, orient: 'str' = 'columns', dtype: 'Dtype | None' = None, columns=None) -> 'DataFrame': Construct DataFrame from dict of array-like or dicts."}
{"text_id": 1004742, "text": "from_records(data, index=None, exclude=None, columns=None, coerce_float: 'bool' = False, nrows: 'int | None' = None) -> 'DataFrame': Convert structured or record ndarray to DataFrame."}
{"text_id": 1004743, "text": "from_records(data, index=None, exclude=None, columns=None, coerce_float: 'bool' = False, nrows: 'int | None' = None) -> 'DataFrame': Convert structured or record ndarray to DataFrame."}
{"text_id": 1004744, "text": "ge(self, other, axis='columns', level=None): Get Greater than or equal to of dataframe and other, element-wise (binary operator `ge`)."}
{"text_id": 1004745, "text": "ge(self, other, level=None, fill_value=None, axis=0): Return Greater than or equal to of series and other, element-wise (binary operator `ge`)."}
{"text_id": 1004746, "text": "ge(self, other, axis='columns', level=None): Get Greater than or equal to of dataframe and other, element-wise (binary operator `ge`)."}
{"text_id": 1004747, "text": "ge(self, other, level=None, fill_value=None, axis=0): Return Greater than or equal to of series and other, element-wise (binary operator `ge`)."}
{"text_id": 1004748, "text": "gt(self, other, axis='columns', level=None): Get Greater than of dataframe and other, element-wise (binary operator `gt`)."}
{"text_id": 1004749, "text": "gt(self, other, level=None, fill_value=None, axis=0): Return Greater than of series and other, element-wise (binary operator `gt`)."}
{"text_id": 1004750, "text": "gt(self, other, axis='columns', level=None): Get Greater than of dataframe and other, element-wise (binary operator `gt`)."}
{"text_id": 1004751, "text": "gt(self, other, level=None, fill_value=None, axis=0): Return Greater than of series and other, element-wise (binary operator `gt`)."}
{"text_id": 1004752, "text": "head(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the first `n` rows."}
{"text_id": 1004753, "text": "head(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the first `n` rows."}
{"text_id": 1004754, "text": "head(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the first `n` rows."}
{"text_id": 1004755, "text": "head(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the first `n` rows."}
{"text_id": 1004756, "text": "hist(data: 'DataFrame', column: 'IndexLabel' = None, by=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, ax=None, sharex: 'bool' = False, sharey: 'bool' = False, figsize: 'tuple[int, int] | None' = None, layout: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Make a histogram of the DataFrame's columns."}
{"text_id": 1004757, "text": "hist(self, by=None, bins=10, **kwargs): Draw one histogram of the DataFrame's columns."}
{"text_id": 1004758, "text": "hist(self, by=None, ax=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, figsize: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Draw histogram of the input series using matplotlib."}
{"text_id": 1004759, "text": "hist(self, by=None, bins=10, **kwargs): Draw one histogram of the DataFrame's columns."}
{"text_id": 1004760, "text": "hist(data: 'DataFrame', column: 'IndexLabel' = None, by=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, ax=None, sharex: 'bool' = False, sharey: 'bool' = False, figsize: 'tuple[int, int] | None' = None, layout: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Make a histogram of the DataFrame's columns."}
{"text_id": 1004761, "text": "hist(self, by=None, ax=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, figsize: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Draw histogram of the input series using matplotlib."}
{"text_id": 1004762, "text": "hist(self, by=None, bins=10, **kwargs): Draw one histogram of the DataFrame's columns."}
{"text_id": 1004763, "text": "idxmax(self, axis: 'Axis' = 0, skipna: 'bool' = True) -> 'Series': Return index of first occurrence of maximum over requested axis."}
{"text_id": 1004764, "text": "idxmax(self, axis=0, skipna=True, *args, **kwargs): Return the row label of the maximum value."}
{"text_id": 1004765, "text": "idxmax(self, axis: 'Axis' = 0, skipna: 'bool' = True) -> 'Series': Return index of first occurrence of maximum over requested axis."}
{"text_id": 1004766, "text": "idxmax(self, axis=0, skipna=True, *args, **kwargs): Return the row label of the maximum value."}
{"text_id": 1004767, "text": "idxmin(self, axis: 'Axis' = 0, skipna: 'bool' = True) -> 'Series': Return index of first occurrence of minimum over requested axis."}
{"text_id": 1004768, "text": "idxmin(self, axis=0, skipna=True, *args, **kwargs): Return the row label of the minimum value."}
{"text_id": 1004769, "text": "idxmin(self, axis: 'Axis' = 0, skipna: 'bool' = True) -> 'Series': Return index of first occurrence of minimum over requested axis."}
{"text_id": 1004770, "text": "idxmin(self, axis=0, skipna=True, *args, **kwargs): Return the row label of the minimum value."}
{"text_id": 1004771, "text": "infer_objects(self: 'FrameOrSeries') -> 'FrameOrSeries': Attempt to infer better dtypes for object columns."}
{"text_id": 1004772, "text": "infer_objects(self: 'FrameOrSeries') -> 'FrameOrSeries': Attempt to infer better dtypes for object columns."}
{"text_id": 1004773, "text": "infer_objects(self: 'FrameOrSeries') -> 'FrameOrSeries': Attempt to infer better dtypes for object columns."}
{"text_id": 1004774, "text": "infer_objects(self: 'FrameOrSeries') -> 'FrameOrSeries': Attempt to infer better dtypes for object columns."}
{"text_id": 1004775, "text": "info(self, verbose: 'bool | None' = None, buf: 'IO[str] | None' = None, max_cols: 'int | None' = None, memory_usage: 'bool | str | None' = None, show_counts: 'bool | None' = None, null_counts: 'bool | None' = None) -> 'None': Print a concise summary of a DataFrame."}
{"text_id": 1004776, "text": "info(self) -> 'str': Print detailed information on the store."}
{"text_id": 1004777, "text": "info(self, verbose: 'bool | None' = None, buf: 'IO[str] | None' = None, max_cols: 'int | None' = None, memory_usage: 'bool | str | None' = None, show_counts: 'bool | None' = None, null_counts: 'bool | None' = None) -> 'None': Print a concise summary of a DataFrame."}
{"text_id": 1004778, "text": "info(self) -> 'str': Print detailed information on the store."}
{"text_id": 1004779, "text": "items(self) -> 'Iterable[tuple[Hashable, Series]]': Iterate over (column name, Series) pairs."}
{"text_id": 1004780, "text": "items(self): iterate on key->group."}
{"text_id": 1004781, "text": "items(self) -> 'Iterable[tuple[Hashable, Any]]': Lazily iterate over (index, value) tuples."}
{"text_id": 1004782, "text": "items(self) -> 'Iterable[tuple[Hashable, Series]]': Iterate over (column name, Series) pairs."}
{"text_id": 1004783, "text": "items(self): iterate on key->group."}
{"text_id": 1004784, "text": "items(self) -> 'Iterable[tuple[Hashable, Any]]': Lazily iterate over (index, value) tuples."}
{"text_id": 1004785, "text": "iteritems(self) -> 'Iterable[tuple[Hashable, Series]]': Iterate over (column name, Series) pairs."}
{"text_id": 1004786, "text": "iteritems(self): iterate on key->group."}
{"text_id": 1004787, "text": "iteritems(self) -> 'Iterable[tuple[Hashable, Any]]': Lazily iterate over (index, value) tuples."}
{"text_id": 1004788, "text": "iteritems(self) -> 'Iterable[tuple[Hashable, Series]]': Iterate over (column name, Series) pairs."}
{"text_id": 1004789, "text": "iteritems(self): iterate on key->group."}
{"text_id": 1004790, "text": "iteritems(self) -> 'Iterable[tuple[Hashable, Any]]': Lazily iterate over (index, value) tuples."}
{"text_id": 1004791, "text": "iterrows(self) -> 'Iterable[tuple[Hashable, Series]]': Iterate over DataFrame rows as (index, Series) pairs."}
{"text_id": 1004792, "text": "iterrows(self) -> 'Iterable[tuple[Hashable, Series]]': Iterate over DataFrame rows as (index, Series) pairs."}
{"text_id": 1004793, "text": "itertuples(self, index: 'bool' = True, name: 'str | None' = 'Pandas') -> 'Iterable[tuple[Any, ...]]': Iterate over DataFrame rows as namedtuples."}
{"text_id": 1004794, "text": "itertuples(self, index: 'bool' = True, name: 'str | None' = 'Pandas') -> 'Iterable[tuple[Any, ...]]': Iterate over DataFrame rows as namedtuples."}
{"text_id": 1004795, "text": "keys(self): Get the 'info axis' (see Indexing for more)."}
{"text_id": 1004796, "text": "keys(self, include: 'str' = 'pandas') -> 'list[str]': Return a list of keys corresponding to objects stored in HDFStore."}
{"text_id": 1004797, "text": "keys(self) -> 'Index': Return alias for index."}
{"text_id": 1004798, "text": "keys(self): Get the 'info axis' (see Indexing for more)."}
{"text_id": 1004799, "text": "keys(self, include: 'str' = 'pandas') -> 'list[str]': Return a list of keys corresponding to objects stored in HDFStore."}
{"text_id": 1004800, "text": "keys(self) -> 'Index': Return alias for index."}
{"text_id": 1004801, "text": "kurt(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004802, "text": "kurt(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004803, "text": "kurt(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004804, "text": "kurt(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004805, "text": "kurtosis(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004806, "text": "kurtosis(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004807, "text": "kurtosis(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004808, "text": "kurtosis(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased kurtosis over requested axis."}
{"text_id": 1004809, "text": "last(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select final periods of time series data based on a date offset."}
{"text_id": 1004810, "text": "last(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select final periods of time series data based on a date offset."}
{"text_id": 1004811, "text": "last(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select final periods of time series data based on a date offset."}
{"text_id": 1004812, "text": "last(self: 'FrameOrSeries', offset) -> 'FrameOrSeries': Select final periods of time series data based on a date offset."}
{"text_id": 1004813, "text": "last_valid_index(self) -> 'Hashable | None': Return index for last non-NA value or None, if no NA value is found."}
{"text_id": 1004814, "text": "last_valid_index(self) -> 'Hashable | None': Return index for last non-NA value or None, if no NA value is found."}
{"text_id": 1004815, "text": "last_valid_index(self) -> 'Hashable | None': Return index for last non-NA value or None, if no NA value is found."}
{"text_id": 1004816, "text": "last_valid_index(self) -> 'Hashable | None': Return index for last non-NA value or None, if no NA value is found."}
{"text_id": 1004817, "text": "le(self, other, axis='columns', level=None): Get Less than or equal to of dataframe and other, element-wise (binary operator `le`)."}
{"text_id": 1004818, "text": "le(self, other, level=None, fill_value=None, axis=0): Return Less than or equal to of series and other, element-wise (binary operator `le`)."}
{"text_id": 1004819, "text": "le(self, other, axis='columns', level=None): Get Less than or equal to of dataframe and other, element-wise (binary operator `le`)."}
{"text_id": 1004820, "text": "le(self, other, level=None, fill_value=None, axis=0): Return Less than or equal to of series and other, element-wise (binary operator `le`)."}
{"text_id": 1004821, "text": "lookup(self, row_labels: 'Sequence[IndexLabel]', col_labels: 'Sequence[IndexLabel]') -> 'np.ndarray': Label-based \"fancy indexing\" function for DataFrame."}
{"text_id": 1004822, "text": "lookup(self, row_labels: 'Sequence[IndexLabel]', col_labels: 'Sequence[IndexLabel]') -> 'np.ndarray': Label-based \"fancy indexing\" function for DataFrame."}
{"text_id": 1004823, "text": "lt(self, other, axis='columns', level=None): Get Less than of dataframe and other, element-wise (binary operator `lt`)."}
{"text_id": 1004824, "text": "lt(self, other, level=None, fill_value=None, axis=0): Return Less than of series and other, element-wise (binary operator `lt`)."}
{"text_id": 1004825, "text": "lt(self, other, axis='columns', level=None): Get Less than of dataframe and other, element-wise (binary operator `lt`)."}
{"text_id": 1004826, "text": "lt(self, other, level=None, fill_value=None, axis=0): Return Less than of series and other, element-wise (binary operator `lt`)."}
{"text_id": 1004827, "text": "mad(self, axis=None, skipna=None, level=None): Return the mean absolute deviation of the values over the requested axis."}
{"text_id": 1004828, "text": "mad(self, axis=None, skipna=None, level=None): Return the mean absolute deviation of the values over the requested axis."}
{"text_id": 1004829, "text": "mad(self, axis=None, skipna=None, level=None): Return the mean absolute deviation of the values over the requested axis."}
{"text_id": 1004830, "text": "mad(self, axis=None, skipna=None, level=None): Return the mean absolute deviation of the values over the requested axis."}
{"text_id": 1004831, "text": "mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the mean of the values over the requested axis."}
{"text_id": 1004832, "text": "mean(self, *args, **kwargs): Return the mean value of the Array."}
{"text_id": 1004833, "text": "mean(self, *args, **kwargs): Return the mean value of the Array."}
{"text_id": 1004834, "text": "mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the mean of the values over the requested axis."}
{"text_id": 1004835, "text": "mean(self, *args, **kwargs): Return the mean value of the Array."}
{"text_id": 1004836, "text": "mean(self, *, skipna: 'bool' = True, axis: 'int | None' = 0): Return the mean value of the Array."}
{"text_id": 1004837, "text": "mean(self, *, skipna: 'bool' = True, axis: 'int | None' = 0): Return the mean value of the Array."}
{"text_id": 1004838, "text": "mean(self, axis=0, *args, **kwargs): Mean of non-NA/null values."}
{"text_id": 1004839, "text": "mean(self, *, skipna: 'bool' = True, axis: 'int | None' = 0): Return the mean value of the Array."}
{"text_id": 1004840, "text": "mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the mean of the values over the requested axis."}
{"text_id": 1004841, "text": "mean(self, *args, **kwargs): Return the mean value of the Array."}
{"text_id": 1004842, "text": "mean(self, *args, **kwargs): Return the mean value of the Array."}
{"text_id": 1004843, "text": "mean(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the mean of the values over the requested axis."}
{"text_id": 1004844, "text": "mean(self, *args, **kwargs): Return the mean value of the Array."}
{"text_id": 1004845, "text": "median(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the median of the values over the requested axis."}
{"text_id": 1004846, "text": "median(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the median of the values over the requested axis."}
{"text_id": 1004847, "text": "median(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the median of the values over the requested axis."}
{"text_id": 1004848, "text": "median(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the median of the values over the requested axis."}
{"text_id": 1004849, "text": "melt(self, id_vars=None, value_vars=None, var_name=None, value_name='value', col_level: 'Level | None' = None, ignore_index: 'bool' = True) -> 'DataFrame': Unpivot a DataFrame from wide to long format, optionally leaving identifiers set."}
{"text_id": 1004850, "text": "melt(frame: 'DataFrame', id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None, ignore_index: 'bool' = True) -> 'DataFrame': Unpivot a DataFrame from wide to long format, optionally leaving identifiers set."}
{"text_id": 1004851, "text": "melt(frame: 'DataFrame', id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None, ignore_index: 'bool' = True) -> 'DataFrame': Unpivot a DataFrame from wide to long format, optionally leaving identifiers set."}
{"text_id": 1004852, "text": "melt(self, id_vars=None, value_vars=None, var_name=None, value_name='value', col_level: 'Level | None' = None, ignore_index: 'bool' = True) -> 'DataFrame': Unpivot a DataFrame from wide to long format, optionally leaving identifiers set."}
{"text_id": 1004853, "text": "melt(frame: 'DataFrame', id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None, ignore_index: 'bool' = True) -> 'DataFrame': Unpivot a DataFrame from wide to long format, optionally leaving identifiers set."}
{"text_id": 1004854, "text": "melt(frame: 'DataFrame', id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None, ignore_index: 'bool' = True) -> 'DataFrame': Unpivot a DataFrame from wide to long format, optionally leaving identifiers set."}
{"text_id": 1004855, "text": "merge(self, right: 'FrameOrSeriesUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), copy: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'DataFrame': Merge DataFrame or named Series objects with a database-style join."}
{"text_id": 1004856, "text": "merge(left: 'DataFrame | Series', right: 'DataFrame | Series', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), copy: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'DataFrame': Merge DataFrame or named Series objects with a database-style join."}
{"text_id": 1004857, "text": "merge(self, right: 'FrameOrSeriesUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), copy: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'DataFrame': Merge DataFrame or named Series objects with a database-style join."}
{"text_id": 1004858, "text": "merge(left: 'DataFrame | Series', right: 'DataFrame | Series', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), copy: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'DataFrame': Merge DataFrame or named Series objects with a database-style join."}
{"text_id": 1004859, "text": "merge(left: 'DataFrame | Series', right: 'DataFrame | Series', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), copy: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'DataFrame': Merge DataFrame or named Series objects with a database-style join."}
{"text_id": 1004860, "text": "mod(self, other, axis='columns', level=None, fill_value=None): Get Modulo of dataframe and other, element-wise (binary operator `mod`)."}
{"text_id": 1004861, "text": "mod(self, other, level=None, fill_value=None, axis=0): Return Modulo of series and other, element-wise (binary operator `mod`)."}
{"text_id": 1004862, "text": "mod(self, other, axis='columns', level=None, fill_value=None): Get Modulo of dataframe and other, element-wise (binary operator `mod`)."}
{"text_id": 1004863, "text": "mod(self, other, level=None, fill_value=None, axis=0): Return Modulo of series and other, element-wise (binary operator `mod`)."}
{"text_id": 1004864, "text": "mul(self, other, axis='columns', level=None, fill_value=None): Get Multiplication of dataframe and other, element-wise (binary operator `mul`)."}
{"text_id": 1004865, "text": "mul(self, other, level=None, fill_value=None, axis=0): Return Multiplication of series and other, element-wise (binary operator `mul`)."}
{"text_id": 1004866, "text": "mul(self, other, axis='columns', level=None, fill_value=None): Get Multiplication of dataframe and other, element-wise (binary operator `mul`)."}
{"text_id": 1004867, "text": "mul(self, other, level=None, fill_value=None, axis=0): Return Multiplication of series and other, element-wise (binary operator `mul`)."}
{"text_id": 1004868, "text": "multiply(self, other, axis='columns', level=None, fill_value=None): Get Multiplication of dataframe and other, element-wise (binary operator `mul`)."}
{"text_id": 1004869, "text": "multiply(self, other, level=None, fill_value=None, axis=0): Return Multiplication of series and other, element-wise (binary operator `mul`)."}
{"text_id": 1004870, "text": "multiply(self, other, axis='columns', level=None, fill_value=None): Get Multiplication of dataframe and other, element-wise (binary operator `mul`)."}
{"text_id": 1004871, "text": "multiply(self, other, level=None, fill_value=None, axis=0): Return Multiplication of series and other, element-wise (binary operator `mul`)."}
{"text_id": 1004872, "text": "ne(self, other, axis='columns', level=None): Get Not equal to of dataframe and other, element-wise (binary operator `ne`)."}
{"text_id": 1004873, "text": "ne(self, other, level=None, fill_value=None, axis=0): Return Not equal to of series and other, element-wise (binary operator `ne`)."}
{"text_id": 1004874, "text": "ne(self, other, axis='columns', level=None): Get Not equal to of dataframe and other, element-wise (binary operator `ne`)."}
{"text_id": 1004875, "text": "ne(self, other, level=None, fill_value=None, axis=0): Return Not equal to of series and other, element-wise (binary operator `ne`)."}
{"text_id": 1004876, "text": "nlargest(self, n, columns, keep: 'str' = 'first') -> 'DataFrame': Return the first `n` rows ordered by `columns` in descending order."}
{"text_id": 1004877, "text": "nlargest(self, n=5, keep='first') -> 'Series': Return the largest `n` elements."}
{"text_id": 1004878, "text": "nlargest(self, n, columns, keep: 'str' = 'first') -> 'DataFrame': Return the first `n` rows ordered by `columns` in descending order."}
{"text_id": 1004879, "text": "nlargest(self, n=5, keep='first') -> 'Series': Return the largest `n` elements."}
{"text_id": 1004880, "text": "nsmallest(self, n, columns, keep: 'str' = 'first') -> 'DataFrame': Return the first `n` rows ordered by `columns` in ascending order."}
{"text_id": 1004881, "text": "nsmallest(self, n: 'int' = 5, keep: 'str' = 'first') -> 'Series': Return the smallest `n` elements."}
{"text_id": 1004882, "text": "nsmallest(self, n, columns, keep: 'str' = 'first') -> 'DataFrame': Return the first `n` rows ordered by `columns` in ascending order."}
{"text_id": 1004883, "text": "nsmallest(self, n: 'int' = 5, keep: 'str' = 'first') -> 'Series': Return the smallest `n` elements."}
{"text_id": 1004884, "text": "pct_change(self: 'FrameOrSeries', periods=1, fill_method='pad', limit=None, freq=None, **kwargs) -> 'FrameOrSeries': Percentage change between the current and a prior element."}
{"text_id": 1004885, "text": "pct_change(self: 'FrameOrSeries', periods=1, fill_method='pad', limit=None, freq=None, **kwargs) -> 'FrameOrSeries': Percentage change between the current and a prior element."}
{"text_id": 1004886, "text": "pct_change(self: 'FrameOrSeries', periods=1, fill_method='pad', limit=None, freq=None, **kwargs) -> 'FrameOrSeries': Percentage change between the current and a prior element."}
{"text_id": 1004887, "text": "pct_change(self: 'FrameOrSeries', periods=1, fill_method='pad', limit=None, freq=None, **kwargs) -> 'FrameOrSeries': Percentage change between the current and a prior element."}
{"text_id": 1004888, "text": "pipe(self, func: 'Callable[..., T] | tuple[Callable[..., T], str]', *args, **kwargs) -> 'T': Apply func(self, \\*args, \\*\\*kwargs)."}
{"text_id": 1004889, "text": "pipe(self, func: 'Callable[..., T] | tuple[Callable[..., T], str]', *args, **kwargs) -> 'T': Apply func(self, \\*args, \\*\\*kwargs)."}
{"text_id": 1004890, "text": "pipe(obj, func: 'Callable[..., T] | tuple[Callable[..., T], str]', *args, **kwargs) -> 'T': Apply a function ``func`` to object ``obj`` either by passing obj as the first argument to the function or, in the case that the func is a tuple, interpret the first element of the tuple as a function and pass the obj to that function as a keyword argument whose key is the value of the second element of the tuple."}
{"text_id": 1004891, "text": "pipe(self, func: 'Callable[..., T] | tuple[Callable[..., T], str]', *args, **kwargs) -> 'T': Apply func(self, \\*args, \\*\\*kwargs)."}
{"text_id": 1004892, "text": "pipe(self, func: 'Callable[..., T] | tuple[Callable[..., T], str]', *args, **kwargs) -> 'T': Apply func(self, \\*args, \\*\\*kwargs)."}
{"text_id": 1004893, "text": "pivot(self, index=None, columns=None, values=None) -> 'DataFrame': Return reshaped DataFrame organized by given index / column values."}
{"text_id": 1004894, "text": "pivot(self, index=None, columns=None, values=None) -> 'DataFrame': Return reshaped DataFrame organized by given index / column values."}
{"text_id": 1004895, "text": "pivot(data: 'DataFrame', index: 'IndexLabel | None' = None, columns: 'IndexLabel | None' = None, values: 'IndexLabel | None' = None) -> 'DataFrame': Return reshaped DataFrame organized by given index / column values."}
{"text_id": 1004896, "text": "pivot(data: 'DataFrame', index: 'IndexLabel | None' = None, columns: 'IndexLabel | None' = None, values: 'IndexLabel | None' = None) -> 'DataFrame': Return reshaped DataFrame organized by given index / column values."}
{"text_id": 1004897, "text": "pivot(data: 'DataFrame', index: 'IndexLabel | None' = None, columns: 'IndexLabel | None' = None, values: 'IndexLabel | None' = None) -> 'DataFrame': Return reshaped DataFrame organized by given index / column values."}
{"text_id": 1004898, "text": "pivot_table(self, values=None, index=None, columns=None, aggfunc='mean', fill_value=None, margins=False, dropna=True, margins_name='All', observed=False, sort=True) -> 'DataFrame': Create a spreadsheet-style pivot table as a DataFrame."}
{"text_id": 1004899, "text": "pivot_table(self, values=None, index=None, columns=None, aggfunc='mean', fill_value=None, margins=False, dropna=True, margins_name='All', observed=False, sort=True) -> 'DataFrame': Create a spreadsheet-style pivot table as a DataFrame."}
{"text_id": 1004900, "text": "pivot_table(data: 'DataFrame', values=None, index=None, columns=None, aggfunc: 'AggFuncType' = 'mean', fill_value=None, margins=False, dropna=True, margins_name='All', observed=False, sort=True) -> 'DataFrame': Create a spreadsheet-style pivot table as a DataFrame."}
{"text_id": 1004901, "text": "pivot_table(data: 'DataFrame', values=None, index=None, columns=None, aggfunc: 'AggFuncType' = 'mean', fill_value=None, margins=False, dropna=True, margins_name='All', observed=False, sort=True) -> 'DataFrame': Create a spreadsheet-style pivot table as a DataFrame."}
{"text_id": 1004902, "text": "pivot_table(data: 'DataFrame', values=None, index=None, columns=None, aggfunc: 'AggFuncType' = 'mean', fill_value=None, margins=False, dropna=True, margins_name='All', observed=False, sort=True) -> 'DataFrame': Create a spreadsheet-style pivot table as a DataFrame."}
{"text_id": 1004903, "text": "plot(data): Make plots of Series or DataFrame."}
{"text_id": 1004904, "text": "plot(data): Make plots of Series or DataFrame."}
{"text_id": 1004905, "text": "plot(data): Make plots of Series or DataFrame."}
{"text_id": 1004906, "text": "plot(data): Make plots of Series or DataFrame."}
{"text_id": 1004907, "text": "area(self, x=None, y=None, **kwargs): Draw a stacked area plot."}
{"text_id": 1004908, "text": "area(self, x=None, y=None, **kwargs): Draw a stacked area plot."}
{"text_id": 1004909, "text": "area(self, x=None, y=None, **kwargs): Draw a stacked area plot."}
{"text_id": 1004910, "text": "bar(self, x=None, y=None, **kwargs): Vertical bar plot."}
{"text_id": 1004911, "text": "bar(self, x=None, y=None, **kwargs): Vertical bar plot."}
{"text_id": 1004912, "text": "bar(self, x=None, y=None, **kwargs): Vertical bar plot."}
{"text_id": 1004913, "text": "barh(self, x=None, y=None, **kwargs): Make a horizontal bar plot."}
{"text_id": 1004914, "text": "barh(self, x=None, y=None, **kwargs): Make a horizontal bar plot."}
{"text_id": 1004915, "text": "barh(self, x=None, y=None, **kwargs): Make a horizontal bar plot."}
{"text_id": 1004916, "text": "box(self, by=None, **kwargs): Make a box plot of the DataFrame columns."}
{"text_id": 1004917, "text": "box(self, by=None, **kwargs): Make a box plot of the DataFrame columns."}
{"text_id": 1004918, "text": "box(self, by=None, **kwargs): Make a box plot of the DataFrame columns."}
{"text_id": 1004919, "text": "density(self, bw_method=None, ind=None, **kwargs): Generate Kernel Density Estimate plot using Gaussian kernels."}
{"text_id": 1004920, "text": "density(self, bw_method=None, ind=None, **kwargs): Generate Kernel Density Estimate plot using Gaussian kernels."}
{"text_id": 1004921, "text": "density(self, bw_method=None, ind=None, **kwargs): Generate Kernel Density Estimate plot using Gaussian kernels."}
{"text_id": 1004922, "text": "hexbin(self, x, y, C=None, reduce_C_function=None, gridsize=None, **kwargs): Generate a hexagonal binning plot."}
{"text_id": 1004923, "text": "hexbin(self, x, y, C=None, reduce_C_function=None, gridsize=None, **kwargs): Generate a hexagonal binning plot."}
{"text_id": 1004924, "text": "hexbin(self, x, y, C=None, reduce_C_function=None, gridsize=None, **kwargs): Generate a hexagonal binning plot."}
{"text_id": 1004925, "text": "kde(self, bw_method=None, ind=None, **kwargs): Generate Kernel Density Estimate plot using Gaussian kernels."}
{"text_id": 1004926, "text": "kde(self, bw_method=None, ind=None, **kwargs): Generate Kernel Density Estimate plot using Gaussian kernels."}
{"text_id": 1004927, "text": "kde(self, bw_method=None, ind=None, **kwargs): Generate Kernel Density Estimate plot using Gaussian kernels."}
{"text_id": 1004928, "text": "line(self, x=None, y=None, **kwargs): Plot Series or DataFrame as lines."}
{"text_id": 1004929, "text": "line(self, x=None, y=None, **kwargs): Plot Series or DataFrame as lines."}
{"text_id": 1004930, "text": "line(self, x=None, y=None, **kwargs): Plot Series or DataFrame as lines."}
{"text_id": 1004931, "text": "pie(self, **kwargs): Generate a pie plot."}
{"text_id": 1004932, "text": "pie(self, **kwargs): Generate a pie plot."}
{"text_id": 1004933, "text": "pie(self, **kwargs): Generate a pie plot."}
{"text_id": 1004934, "text": "scatter(self, x, y, s=None, c=None, **kwargs): Create a scatter plot with varying marker point size and color."}
{"text_id": 1004935, "text": "scatter(self, x, y, s=None, c=None, **kwargs): Create a scatter plot with varying marker point size and color."}
{"text_id": 1004936, "text": "scatter(self, x, y, s=None, c=None, **kwargs): Create a scatter plot with varying marker point size and color."}
{"text_id": 1004937, "text": "pop(self, item: 'Hashable') -> 'Series': Return item and drop from frame."}
{"text_id": 1004938, "text": "pop(self, item: 'Hashable') -> 'Any': Return item and drops from series."}
{"text_id": 1004939, "text": "pop(self, item: 'Hashable') -> 'Series': Return item and drop from frame."}
{"text_id": 1004940, "text": "pop(self, item: 'Hashable') -> 'Any': Return item and drops from series."}
{"text_id": 1004941, "text": "pow(self, other, axis='columns', level=None, fill_value=None): Get Exponential power of dataframe and other, element-wise (binary operator `pow`)."}
{"text_id": 1004942, "text": "pow(self, other, level=None, fill_value=None, axis=0): Return Exponential power of series and other, element-wise (binary operator `pow`)."}
{"text_id": 1004943, "text": "pow(self, other, axis='columns', level=None, fill_value=None): Get Exponential power of dataframe and other, element-wise (binary operator `pow`)."}
{"text_id": 1004944, "text": "pow(self, other, level=None, fill_value=None, axis=0): Return Exponential power of series and other, element-wise (binary operator `pow`)."}
{"text_id": 1004945, "text": "prod(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004946, "text": "prod(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004947, "text": "prod(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004948, "text": "prod(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004949, "text": "product(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004950, "text": "product(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004951, "text": "product(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004952, "text": "product(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the product of the values over the requested axis."}
{"text_id": 1004953, "text": "quantile(self, q=0.5, axis: 'Axis' = 0, numeric_only: 'bool' = True, interpolation: 'str' = 'linear'): Return values at the given quantile over requested axis."}
{"text_id": 1004954, "text": "quantile(self, q=0.5, interpolation='linear'): Return value at the given quantile."}
{"text_id": 1004955, "text": "quantile(x, q, interpolation_method='fraction'): Compute sample quantile or quantiles of the input array."}
{"text_id": 1004956, "text": "quantile(self, q=0.5, axis: 'Axis' = 0, numeric_only: 'bool' = True, interpolation: 'str' = 'linear'): Return values at the given quantile over requested axis."}
{"text_id": 1004957, "text": "quantile(self, q=0.5, interpolation='linear'): Return value at the given quantile."}
{"text_id": 1004958, "text": "query(self, expr: 'str', inplace: 'bool' = False, **kwargs): Query the columns of a DataFrame with a boolean expression."}
{"text_id": 1004959, "text": "query(self, expr: 'str', inplace: 'bool' = False, **kwargs): Query the columns of a DataFrame with a boolean expression."}
{"text_id": 1004960, "text": "radd(self, other, axis='columns', level=None, fill_value=None): Get Addition of dataframe and other, element-wise (binary operator `radd`)."}
{"text_id": 1004961, "text": "radd(self, other, level=None, fill_value=None, axis=0): Return Addition of series and other, element-wise (binary operator `radd`)."}
{"text_id": 1004962, "text": "radd(self, other, axis='columns', level=None, fill_value=None): Get Addition of dataframe and other, element-wise (binary operator `radd`)."}
{"text_id": 1004963, "text": "radd(self, other, level=None, fill_value=None, axis=0): Return Addition of series and other, element-wise (binary operator `radd`)."}
{"text_id": 1004964, "text": "rank(self: 'FrameOrSeries', axis=0, method: 'str' = 'average', numeric_only: 'bool_t | None' = None, na_option: 'str' = 'keep', ascending: 'bool_t' = True, pct: 'bool_t' = False) -> 'FrameOrSeries': Compute numerical data ranks (1 through n) along axis."}
{"text_id": 1004965, "text": "rank(self: 'FrameOrSeries', axis=0, method: 'str' = 'average', numeric_only: 'bool_t | None' = None, na_option: 'str' = 'keep', ascending: 'bool_t' = True, pct: 'bool_t' = False) -> 'FrameOrSeries': Compute numerical data ranks (1 through n) along axis."}
{"text_id": 1004966, "text": "rank(values: 'ArrayLike', axis: 'int' = 0, method: 'str' = 'average', na_option: 'str' = 'keep', ascending: 'bool' = True, pct: 'bool' = False) -> 'np.ndarray': Rank the values along a given axis."}
{"text_id": 1004967, "text": "rank(self: 'FrameOrSeries', axis=0, method: 'str' = 'average', numeric_only: 'bool_t | None' = None, na_option: 'str' = 'keep', ascending: 'bool_t' = True, pct: 'bool_t' = False) -> 'FrameOrSeries': Compute numerical data ranks (1 through n) along axis."}
{"text_id": 1004968, "text": "rank(self: 'FrameOrSeries', axis=0, method: 'str' = 'average', numeric_only: 'bool_t | None' = None, na_option: 'str' = 'keep', ascending: 'bool_t' = True, pct: 'bool_t' = False) -> 'FrameOrSeries': Compute numerical data ranks (1 through n) along axis."}
{"text_id": 1004969, "text": "rdiv(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1004970, "text": "rdiv(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1004971, "text": "rdiv(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1004972, "text": "rdiv(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1004973, "text": "reindex_like(self: 'FrameOrSeries', other, method: 'str | None' = None, copy: 'bool_t' = True, limit=None, tolerance=None) -> 'FrameOrSeries': Return an object with matching indices as other object."}
{"text_id": 1004974, "text": "reindex_like(self: 'FrameOrSeries', other, method: 'str | None' = None, copy: 'bool_t' = True, limit=None, tolerance=None) -> 'FrameOrSeries': Return an object with matching indices as other object."}
{"text_id": 1004975, "text": "reindex_like(self: 'FrameOrSeries', other, method: 'str | None' = None, copy: 'bool_t' = True, limit=None, tolerance=None) -> 'FrameOrSeries': Return an object with matching indices as other object."}
{"text_id": 1004976, "text": "reindex_like(self: 'FrameOrSeries', other, method: 'str | None' = None, copy: 'bool_t' = True, limit=None, tolerance=None) -> 'FrameOrSeries': Return an object with matching indices as other object."}
{"text_id": 1004977, "text": "rename_axis(self, mapper=None, index=None, columns=None, axis=None, copy=True, inplace=False): Set the name of the axis for the index or columns."}
{"text_id": 1004978, "text": "rename_axis(self, mapper=None, index=None, columns=None, axis=None, copy=True, inplace=False): Set the name of the axis for the index or columns."}
{"text_id": 1004979, "text": "rename_axis(self, mapper=None, index=None, columns=None, axis=None, copy=True, inplace=False): Set the name of the axis for the index or columns."}
{"text_id": 1004980, "text": "rename_axis(self, mapper=None, index=None, columns=None, axis=None, copy=True, inplace=False): Set the name of the axis for the index or columns."}
{"text_id": 1004981, "text": "reorder_levels(self, order: 'Sequence[Axis]', axis: 'Axis' = 0) -> 'DataFrame': Rearrange index levels using input order."}
{"text_id": 1004982, "text": "reorder_levels(self, order) -> 'MultiIndex': Rearrange levels using input order."}
{"text_id": 1004983, "text": "reorder_levels(self, order) -> 'Series': Rearrange index levels using input order."}
{"text_id": 1004984, "text": "reorder_levels(self, order: 'Sequence[Axis]', axis: 'Axis' = 0) -> 'DataFrame': Rearrange index levels using input order."}
{"text_id": 1004985, "text": "reorder_levels(self, order) -> 'MultiIndex': Rearrange levels using input order."}
{"text_id": 1004986, "text": "reorder_levels(self, order) -> 'Series': Rearrange index levels using input order."}
{"text_id": 1004987, "text": "resample(self, rule, axis=0, closed: 'str | None' = None, label: 'str | None' = None, convention: 'str' = 'start', kind: 'str | None' = None, loffset=None, base: 'int | None' = None, on=None, level=None, origin: 'str | TimestampConvertibleTypes' = 'start_day', offset: 'TimedeltaConvertibleTypes | None' = None) -> 'Resampler': Resample time-series data."}
{"text_id": 1004988, "text": "resample(self, rule, axis=0, closed: 'str | None' = None, label: 'str | None' = None, convention: 'str' = 'start', kind: 'str | None' = None, loffset=None, base: 'int | None' = None, on=None, level=None, origin: 'str | TimestampConvertibleTypes' = 'start_day', offset: 'TimedeltaConvertibleTypes | None' = None) -> 'Resampler': Resample time-series data."}
{"text_id": 1004989, "text": "resample(self, rule, axis=0, closed: 'str | None' = None, label: 'str | None' = None, convention: 'str' = 'start', kind: 'str | None' = None, loffset=None, base: 'int | None' = None, on=None, level=None, origin: 'str | TimestampConvertibleTypes' = 'start_day', offset: 'TimedeltaConvertibleTypes | None' = None) -> 'Resampler': Resample time-series data."}
{"text_id": 1004990, "text": "resample(self, rule, axis=0, closed: 'str | None' = None, label: 'str | None' = None, convention: 'str' = 'start', kind: 'str | None' = None, loffset=None, base: 'int | None' = None, on=None, level=None, origin: 'str | TimestampConvertibleTypes' = 'start_day', offset: 'TimedeltaConvertibleTypes | None' = None) -> 'Resampler': Resample time-series data."}
{"text_id": 1004991, "text": "reset_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, drop: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'DataFrame | None': Reset the index, or a level of it."}
{"text_id": 1004992, "text": "reset_index(self, level=None, drop=False, name=None, inplace=False): Generate a new DataFrame or Series with the index reset."}
{"text_id": 1004993, "text": "reset_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, drop: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'DataFrame | None': Reset the index, or a level of it."}
{"text_id": 1004994, "text": "reset_index(self, level=None, drop=False, name=None, inplace=False): Generate a new DataFrame or Series with the index reset."}
{"text_id": 1004995, "text": "rfloordiv(self, other, axis='columns', level=None, fill_value=None): Get Integer division of dataframe and other, element-wise (binary operator `rfloordiv`)."}
{"text_id": 1004996, "text": "rfloordiv(self, other, level=None, fill_value=None, axis=0): Return Integer division of series and other, element-wise (binary operator `rfloordiv`)."}
{"text_id": 1004997, "text": "rfloordiv(self, other, axis='columns', level=None, fill_value=None): Get Integer division of dataframe and other, element-wise (binary operator `rfloordiv`)."}
{"text_id": 1004998, "text": "rfloordiv(self, other, level=None, fill_value=None, axis=0): Return Integer division of series and other, element-wise (binary operator `rfloordiv`)."}
{"text_id": 1004999, "text": "rmod(self, other, axis='columns', level=None, fill_value=None): Get Modulo of dataframe and other, element-wise (binary operator `rmod`)."}
{"text_id": 1005000, "text": "rmod(self, other, level=None, fill_value=None, axis=0): Return Modulo of series and other, element-wise (binary operator `rmod`)."}
{"text_id": 1005001, "text": "rmod(self, other, axis='columns', level=None, fill_value=None): Get Modulo of dataframe and other, element-wise (binary operator `rmod`)."}
{"text_id": 1005002, "text": "rmod(self, other, level=None, fill_value=None, axis=0): Return Modulo of series and other, element-wise (binary operator `rmod`)."}
{"text_id": 1005003, "text": "rmul(self, other, axis='columns', level=None, fill_value=None): Get Multiplication of dataframe and other, element-wise (binary operator `rmul`)."}
{"text_id": 1005004, "text": "rmul(self, other, level=None, fill_value=None, axis=0): Return Multiplication of series and other, element-wise (binary operator `rmul`)."}
{"text_id": 1005005, "text": "rmul(self, other, axis='columns', level=None, fill_value=None): Get Multiplication of dataframe and other, element-wise (binary operator `rmul`)."}
{"text_id": 1005006, "text": "rmul(self, other, level=None, fill_value=None, axis=0): Return Multiplication of series and other, element-wise (binary operator `rmul`)."}
{"text_id": 1005007, "text": "rolling(self, window: 'int | timedelta | BaseOffset | BaseIndexer', min_periods: 'int | None' = None, center: 'bool_t' = False, win_type: 'str | None' = None, on: 'str | None' = None, axis: 'Axis' = 0, closed: 'str | None' = None, method: 'str' = 'single'): Provide rolling window calculations."}
{"text_id": 1005008, "text": "rolling(self, window: 'int | timedelta | BaseOffset | BaseIndexer', min_periods: 'int | None' = None, center: 'bool_t' = False, win_type: 'str | None' = None, on: 'str | None' = None, axis: 'Axis' = 0, closed: 'str | None' = None, method: 'str' = 'single'): Provide rolling window calculations."}
{"text_id": 1005009, "text": "rolling(self, window: 'int | timedelta | BaseOffset | BaseIndexer', min_periods: 'int | None' = None, center: 'bool_t' = False, win_type: 'str | None' = None, on: 'str | None' = None, axis: 'Axis' = 0, closed: 'str | None' = None, method: 'str' = 'single'): Provide rolling window calculations."}
{"text_id": 1005010, "text": "rolling(self, window: 'int | timedelta | BaseOffset | BaseIndexer', min_periods: 'int | None' = None, center: 'bool_t' = False, win_type: 'str | None' = None, on: 'str | None' = None, axis: 'Axis' = 0, closed: 'str | None' = None, method: 'str' = 'single'): Provide rolling window calculations."}
{"text_id": 1005011, "text": "round(self, decimals: 'int | dict[IndexLabel, int] | Series' = 0, *args, **kwargs) -> 'DataFrame': Round a DataFrame to a variable number of decimal places."}
{"text_id": 1005012, "text": "round(self, *args, **kwargs): Perform round operation on the data to the specified `freq`."}
{"text_id": 1005013, "text": "round(*args, **kwargs): Round the Timestamp to the specified resolution."}
{"text_id": 1005014, "text": "round(self, freq, ambiguous='raise', nonexistent='raise'): Round the Timestamp to the specified resolution."}
{"text_id": 1005015, "text": "round(*args, **kwargs): Round the Timestamp to the specified resolution."}
{"text_id": 1005016, "text": "round(self, *args, **kwargs): Perform round operation on the data to the specified `freq`."}
{"text_id": 1005017, "text": "round(self, decimals=0, *args, **kwargs) -> 'Series': Round each value in a Series to the given number of decimals."}
{"text_id": 1005018, "text": "round(freq): Round the Timedelta to the specified resolution."}
{"text_id": 1005019, "text": "round(freq): Round the Timedelta to the specified resolution."}
{"text_id": 1005020, "text": "round(freq): Round the Timedelta to the specified resolution."}
{"text_id": 1005021, "text": "round(self, freq): Round the Timedelta to the specified resolution."}
{"text_id": 1005022, "text": "round(self, *args, **kwargs): Perform round operation on the data to the specified `freq`."}
{"text_id": 1005023, "text": "round(freq, ambiguous='raise', nonexistent='raise'): Round the Timestamp to the specified resolution."}
{"text_id": 1005024, "text": "round(freq, ambiguous='raise', nonexistent='raise'): Round the Timestamp to the specified resolution."}
{"text_id": 1005025, "text": "round(freq): Round the Timedelta to the specified resolution."}
{"text_id": 1005026, "text": "round(self, freq, ambiguous='raise', nonexistent='raise'): Round the Timestamp to the specified resolution."}
{"text_id": 1005027, "text": "round(self, freq, ambiguous='raise', nonexistent='raise'): Perform round operation on the data to the specified `freq`."}
{"text_id": 1005028, "text": "round(self: 'T', decimals: 'int' = 0, *args, **kwargs) -> 'T': Round each value in the array a to the given number of decimals."}
{"text_id": 1005029, "text": "round(self: 'T', decimals: 'int' = 0, *args, **kwargs) -> 'T': Round each value in the array a to the given number of decimals."}
{"text_id": 1005030, "text": "round(self, freq, ambiguous='raise', nonexistent='raise'): Perform round operation on the data to the specified `freq`."}
{"text_id": 1005031, "text": "round(self, decimals: 'int | dict[IndexLabel, int] | Series' = 0, *args, **kwargs) -> 'DataFrame': Round a DataFrame to a variable number of decimal places."}
{"text_id": 1005032, "text": "round(self, *args, **kwargs): Perform round operation on the data to the specified `freq`."}
{"text_id": 1005033, "text": "round(*args, **kwargs): Round the Timestamp to the specified resolution."}
{"text_id": 1005034, "text": "round(self, decimals=0, *args, **kwargs) -> 'Series': Round each value in a Series to the given number of decimals."}
{"text_id": 1005035, "text": "round(self, freq): Round the Timedelta to the specified resolution."}
{"text_id": 1005036, "text": "round(self, *args, **kwargs): Perform round operation on the data to the specified `freq`."}
{"text_id": 1005037, "text": "round(self, freq, ambiguous='raise', nonexistent='raise'): Round the Timestamp to the specified resolution."}
{"text_id": 1005038, "text": "rpow(self, other, axis='columns', level=None, fill_value=None): Get Exponential power of dataframe and other, element-wise (binary operator `rpow`)."}
{"text_id": 1005039, "text": "rpow(self, other, level=None, fill_value=None, axis=0): Return Exponential power of series and other, element-wise (binary operator `rpow`)."}
{"text_id": 1005040, "text": "rpow(self, other, axis='columns', level=None, fill_value=None): Get Exponential power of dataframe and other, element-wise (binary operator `rpow`)."}
{"text_id": 1005041, "text": "rpow(self, other, level=None, fill_value=None, axis=0): Return Exponential power of series and other, element-wise (binary operator `rpow`)."}
{"text_id": 1005042, "text": "rsub(self, other, axis='columns', level=None, fill_value=None): Get Subtraction of dataframe and other, element-wise (binary operator `rsub`)."}
{"text_id": 1005043, "text": "rsub(self, other, level=None, fill_value=None, axis=0): Return Subtraction of series and other, element-wise (binary operator `rsub`)."}
{"text_id": 1005044, "text": "rsub(self, other, axis='columns', level=None, fill_value=None): Get Subtraction of dataframe and other, element-wise (binary operator `rsub`)."}
{"text_id": 1005045, "text": "rsub(self, other, level=None, fill_value=None, axis=0): Return Subtraction of series and other, element-wise (binary operator `rsub`)."}
{"text_id": 1005046, "text": "rtruediv(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1005047, "text": "rtruediv(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1005048, "text": "rtruediv(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1005049, "text": "rtruediv(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `rtruediv`)."}
{"text_id": 1005050, "text": "sample(self: 'FrameOrSeries', n=None, frac: 'float | None' = None, replace: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrSeries': Return a random sample of items from an axis of object."}
{"text_id": 1005051, "text": "sample(self: 'FrameOrSeries', n=None, frac: 'float | None' = None, replace: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrSeries': Return a random sample of items from an axis of object."}
{"text_id": 1005052, "text": "sample(self: 'FrameOrSeries', n=None, frac: 'float | None' = None, replace: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrSeries': Return a random sample of items from an axis of object."}
{"text_id": 1005053, "text": "sample(self: 'FrameOrSeries', n=None, frac: 'float | None' = None, replace: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrSeries': Return a random sample of items from an axis of object."}
{"text_id": 1005054, "text": "select_dtypes(self, include=None, exclude=None) -> 'DataFrame': Return a subset of the DataFrame's columns based on the column dtypes."}
{"text_id": 1005055, "text": "select_dtypes(self, include=None, exclude=None) -> 'DataFrame': Return a subset of the DataFrame's columns based on the column dtypes."}
{"text_id": 1005056, "text": "sem(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased standard error of the mean over requested axis."}
{"text_id": 1005057, "text": "sem(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased standard error of the mean over requested axis."}
{"text_id": 1005058, "text": "sem(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased standard error of the mean over requested axis."}
{"text_id": 1005059, "text": "sem(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased standard error of the mean over requested axis."}
{"text_id": 1005060, "text": "set_axis(self, labels, axis: 'Axis' = 0, inplace: 'bool' = False): Assign desired index to given axis."}
{"text_id": 1005061, "text": "set_axis(self, labels, axis: 'Axis' = 0, inplace: 'bool' = False): Assign desired index to given axis."}
{"text_id": 1005062, "text": "set_axis(self, labels, axis: 'Axis' = 0, inplace: 'bool' = False): Assign desired index to given axis."}
{"text_id": 1005063, "text": "set_axis(self, labels, axis: 'Axis' = 0, inplace: 'bool' = False): Assign desired index to given axis."}
{"text_id": 1005064, "text": "set_flags(self: 'FrameOrSeries', *, copy: 'bool_t' = False, allows_duplicate_labels: 'bool_t | None' = None) -> 'FrameOrSeries': Return a new object with updated flags."}
{"text_id": 1005065, "text": "set_flags(self: 'FrameOrSeries', *, copy: 'bool_t' = False, allows_duplicate_labels: 'bool_t | None' = None) -> 'FrameOrSeries': Return a new object with updated flags."}
{"text_id": 1005066, "text": "set_flags(self: 'FrameOrSeries', *, copy: 'bool_t' = False, allows_duplicate_labels: 'bool_t | None' = None) -> 'FrameOrSeries': Return a new object with updated flags."}
{"text_id": 1005067, "text": "set_flags(self: 'FrameOrSeries', *, copy: 'bool_t' = False, allows_duplicate_labels: 'bool_t | None' = None) -> 'FrameOrSeries': Return a new object with updated flags."}
{"text_id": 1005068, "text": "set_index(self, keys, drop: 'bool' = True, append: 'bool' = False, inplace: 'bool' = False, verify_integrity: 'bool' = False): Set the DataFrame index using existing columns."}
{"text_id": 1005069, "text": "set_index(self, keys, drop: 'bool' = True, append: 'bool' = False, inplace: 'bool' = False, verify_integrity: 'bool' = False): Set the DataFrame index using existing columns."}
{"text_id": 1005070, "text": "skew(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased skew over requested axis."}
{"text_id": 1005071, "text": "skew(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased skew over requested axis."}
{"text_id": 1005072, "text": "skew(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased skew over requested axis."}
{"text_id": 1005073, "text": "skew(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return unbiased skew over requested axis."}
{"text_id": 1005074, "text": "slice_shift(self: 'FrameOrSeries', periods: 'int' = 1, axis=0) -> 'FrameOrSeries': Equivalent to `shift` without copying data."}
{"text_id": 1005075, "text": "slice_shift(self: 'FrameOrSeries', periods: 'int' = 1, axis=0) -> 'FrameOrSeries': Equivalent to `shift` without copying data."}
{"text_id": 1005076, "text": "slice_shift(self: 'FrameOrSeries', periods: 'int' = 1, axis=0) -> 'FrameOrSeries': Equivalent to `shift` without copying data."}
{"text_id": 1005077, "text": "slice_shift(self: 'FrameOrSeries', periods: 'int' = 1, axis=0) -> 'FrameOrSeries': Equivalent to `shift` without copying data."}
{"text_id": 1005078, "text": "sort_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Sort object by labels (along an axis)."}
{"text_id": 1005079, "text": "sort_index(self, axis=0, level=None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Sort Series by index labels."}
{"text_id": 1005080, "text": "sort_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Sort object by labels (along an axis)."}
{"text_id": 1005081, "text": "sort_index(self, axis=0, level=None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'last', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Sort Series by index labels."}
{"text_id": 1005082, "text": "sparse(data=None): DataFrame accessor for sparse data."}
{"text_id": 1005083, "text": "sparse(data=None): Accessor for SparseSparse from other sparse matrix data types."}
{"text_id": 1005084, "text": "sparse(data=None): DataFrame accessor for sparse data."}
{"text_id": 1005085, "text": "sparse(data=None): Accessor for SparseSparse from other sparse matrix data types."}
{"text_id": 1005086, "text": "from_spmatrix(data, index=None, columns=None): Create a new DataFrame from a scipy sparse matrix."}
{"text_id": 1005087, "text": "from_spmatrix(data): Create a SparseArray from a scipy."}
{"text_id": 1005088, "text": "to_coo(self): Return the contents of the frame as a sparse SciPy COO matrix."}
{"text_id": 1005089, "text": "to_coo(self, row_levels=(0,), column_levels=(1,), sort_labels=False): Create a scipy."}
{"text_id": 1005090, "text": "squeeze(self, axis=None): Squeeze 1 dimensional axis objects into scalars."}
{"text_id": 1005091, "text": "squeeze(self, axis=None): Squeeze 1 dimensional axis objects into scalars."}
{"text_id": 1005092, "text": "squeeze(self, axis=None): Squeeze 1 dimensional axis objects into scalars."}
{"text_id": 1005093, "text": "squeeze(self, axis=None): Squeeze 1 dimensional axis objects into scalars."}
{"text_id": 1005094, "text": "stack(self, level: 'Level' = -1, dropna: 'bool' = True): Stack the prescribed level(s) from columns to index."}
{"text_id": 1005095, "text": "stack(self, level: 'Level' = -1, dropna: 'bool' = True): Stack the prescribed level(s) from columns to index."}
{"text_id": 1005096, "text": "std(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return sample standard deviation over requested axis."}
{"text_id": 1005097, "text": "std(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return sample standard deviation over requested axis."}
{"text_id": 1005098, "text": "std(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return sample standard deviation over requested axis."}
{"text_id": 1005099, "text": "std(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return sample standard deviation over requested axis."}
{"text_id": 1005100, "text": "sub(self, other, axis='columns', level=None, fill_value=None): Get Subtraction of dataframe and other, element-wise (binary operator `sub`)."}
{"text_id": 1005101, "text": "sub(self, other, level=None, fill_value=None, axis=0): Return Subtraction of series and other, element-wise (binary operator `sub`)."}
{"text_id": 1005102, "text": "sub(self, other, axis='columns', level=None, fill_value=None): Get Subtraction of dataframe and other, element-wise (binary operator `sub`)."}
{"text_id": 1005103, "text": "sub(self, other, level=None, fill_value=None, axis=0): Return Subtraction of series and other, element-wise (binary operator `sub`)."}
{"text_id": 1005104, "text": "subtract(self, other, axis='columns', level=None, fill_value=None): Get Subtraction of dataframe and other, element-wise (binary operator `sub`)."}
{"text_id": 1005105, "text": "subtract(self, other, level=None, fill_value=None, axis=0): Return Subtraction of series and other, element-wise (binary operator `sub`)."}
{"text_id": 1005106, "text": "subtract(self, other, axis='columns', level=None, fill_value=None): Get Subtraction of dataframe and other, element-wise (binary operator `sub`)."}
{"text_id": 1005107, "text": "subtract(self, other, level=None, fill_value=None, axis=0): Return Subtraction of series and other, element-wise (binary operator `sub`)."}
{"text_id": 1005108, "text": "sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the sum of the values over the requested axis."}
{"text_id": 1005109, "text": "sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the sum of the values over the requested axis."}
{"text_id": 1005110, "text": "sum(self, axis: 'int' = 0, min_count: 'int' = 0, *args, **kwargs) -> 'Scalar': Sum of non-NA/null values."}
{"text_id": 1005111, "text": "sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the sum of the values over the requested axis."}
{"text_id": 1005112, "text": "sum(self, axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs): Return the sum of the values over the requested axis."}
{"text_id": 1005113, "text": "swapaxes(self: 'FrameOrSeries', axis1, axis2, copy=True) -> 'FrameOrSeries': Interchange axes and swap values axes appropriately."}
{"text_id": 1005114, "text": "swapaxes(self: 'FrameOrSeries', axis1, axis2, copy=True) -> 'FrameOrSeries': Interchange axes and swap values axes appropriately."}
{"text_id": 1005115, "text": "swapaxes(self: 'FrameOrSeries', axis1, axis2, copy=True) -> 'FrameOrSeries': Interchange axes and swap values axes appropriately."}
{"text_id": 1005116, "text": "swapaxes(self: 'FrameOrSeries', axis1, axis2, copy=True) -> 'FrameOrSeries': Interchange axes and swap values axes appropriately."}
{"text_id": 1005117, "text": "swaplevel(self, i: 'Axis' = -2, j: 'Axis' = -1, axis: 'Axis' = 0) -> 'DataFrame': Swap levels i and j in a :class:`MultiIndex`."}
{"text_id": 1005118, "text": "swaplevel(self, i=-2, j=-1) -> 'MultiIndex': Swap level i with level j."}
{"text_id": 1005119, "text": "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series': Swap levels i and j in a :class:`MultiIndex`."}
{"text_id": 1005120, "text": "swaplevel(self, i: 'Axis' = -2, j: 'Axis' = -1, axis: 'Axis' = 0) -> 'DataFrame': Swap levels i and j in a :class:`MultiIndex`."}
{"text_id": 1005121, "text": "swaplevel(self, i=-2, j=-1) -> 'MultiIndex': Swap level i with level j."}
{"text_id": 1005122, "text": "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series': Swap levels i and j in a :class:`MultiIndex`."}
{"text_id": 1005123, "text": "tail(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the last `n` rows."}
{"text_id": 1005124, "text": "tail(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the last `n` rows."}
{"text_id": 1005125, "text": "tail(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the last `n` rows."}
{"text_id": 1005126, "text": "tail(self: 'FrameOrSeries', n: 'int' = 5) -> 'FrameOrSeries': Return the last `n` rows."}
{"text_id": 1005127, "text": "to_clipboard(self, excel: 'bool_t' = True, sep: 'str | None' = None, **kwargs) -> 'None': Copy object to the system clipboard."}
{"text_id": 1005128, "text": "to_clipboard(self, excel: 'bool_t' = True, sep: 'str | None' = None, **kwargs) -> 'None': Copy object to the system clipboard."}
{"text_id": 1005129, "text": "to_clipboard(obj, excel=True, sep=None, **kwargs): Attempt to write text representation of object to the system clipboard The clipboard can be then pasted into Excel for example."}
{"text_id": 1005130, "text": "to_clipboard(self, excel: 'bool_t' = True, sep: 'str | None' = None, **kwargs) -> 'None': Copy object to the system clipboard."}
{"text_id": 1005131, "text": "to_clipboard(self, excel: 'bool_t' = True, sep: 'str | None' = None, **kwargs) -> 'None': Copy object to the system clipboard."}
{"text_id": 1005132, "text": "to_csv(self, path_or_buf: 'FilePathOrBuffer[AnyStr] | None' = None, sep: 'str' = ',', na_rep: 'str' = '', float_format: 'str | None' = None, columns: 'Sequence[Hashable] | None' = None, header: 'bool_t | list[str]' = True, index: 'bool_t' = True, index_label: 'IndexLabel | None' = None, mode: 'str' = 'w', encoding: 'str | None' = None, compression: 'CompressionOptions' = 'infer', quoting: 'int | None' = None, quotechar: 'str' = '\"', line_terminator: 'str | None' = None, chunksize: 'int | None' = None, date_format: 'str | None' = None, doublequote: 'bool_t' = True, escapechar: 'str | None' = None, decimal: 'str' = '.', errors: 'str' = 'strict', storage_options: 'StorageOptions' = None) -> 'str | None': Write object to a comma-separated values (csv) file."}
{"text_id": 1005133, "text": "to_csv(self, path_or_buf: 'FilePathOrBuffer[AnyStr] | None' = None, sep: 'str' = ',', na_rep: 'str' = '', float_format: 'str | None' = None, columns: 'Sequence[Hashable] | None' = None, header: 'bool_t | list[str]' = True, index: 'bool_t' = True, index_label: 'IndexLabel | None' = None, mode: 'str' = 'w', encoding: 'str | None' = None, compression: 'CompressionOptions' = 'infer', quoting: 'int | None' = None, quotechar: 'str' = '\"', line_terminator: 'str | None' = None, chunksize: 'int | None' = None, date_format: 'str | None' = None, doublequote: 'bool_t' = True, escapechar: 'str | None' = None, decimal: 'str' = '.', errors: 'str' = 'strict', storage_options: 'StorageOptions' = None) -> 'str | None': Write object to a comma-separated values (csv) file."}
{"text_id": 1005134, "text": "to_csv(self, path_or_buf: 'FilePathOrBuffer[AnyStr] | None' = None, sep: 'str' = ',', na_rep: 'str' = '', float_format: 'str | None' = None, columns: 'Sequence[Hashable] | None' = None, header: 'bool_t | list[str]' = True, index: 'bool_t' = True, index_label: 'IndexLabel | None' = None, mode: 'str' = 'w', encoding: 'str | None' = None, compression: 'CompressionOptions' = 'infer', quoting: 'int | None' = None, quotechar: 'str' = '\"', line_terminator: 'str | None' = None, chunksize: 'int | None' = None, date_format: 'str | None' = None, doublequote: 'bool_t' = True, escapechar: 'str | None' = None, decimal: 'str' = '.', errors: 'str' = 'strict', storage_options: 'StorageOptions' = None) -> 'str | None': Write object to a comma-separated values (csv) file."}
{"text_id": 1005135, "text": "to_csv(self, path_or_buf: 'FilePathOrBuffer[AnyStr] | None' = None, sep: 'str' = ',', na_rep: 'str' = '', float_format: 'str | None' = None, columns: 'Sequence[Hashable] | None' = None, header: 'bool_t | list[str]' = True, index: 'bool_t' = True, index_label: 'IndexLabel | None' = None, mode: 'str' = 'w', encoding: 'str | None' = None, compression: 'CompressionOptions' = 'infer', quoting: 'int | None' = None, quotechar: 'str' = '\"', line_terminator: 'str | None' = None, chunksize: 'int | None' = None, date_format: 'str | None' = None, doublequote: 'bool_t' = True, escapechar: 'str | None' = None, decimal: 'str' = '.', errors: 'str' = 'strict', storage_options: 'StorageOptions' = None) -> 'str | None': Write object to a comma-separated values (csv) file."}
{"text_id": 1005136, "text": "to_dict(self, orient: 'str' = 'dict', into=<class 'dict'>): Convert the DataFrame to a dictionary."}
{"text_id": 1005137, "text": "to_dict(self, into=<class 'dict'>): Convert Series to {label -> value} dict or dict-like object."}
{"text_id": 1005138, "text": "to_dict(self, orient: 'str' = 'dict', into=<class 'dict'>): Convert the DataFrame to a dictionary."}
{"text_id": 1005139, "text": "to_dict(self, into=<class 'dict'>): Convert Series to {label -> value} dict or dict-like object."}
{"text_id": 1005140, "text": "to_excel(self, excel_writer, sheet_name: 'str' = 'Sheet1', na_rep: 'str' = '', float_format: 'str | None' = None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep='inf', verbose=True, freeze_panes=None, storage_options: 'StorageOptions' = None) -> 'None': Write object to an Excel sheet."}
{"text_id": 1005141, "text": "to_excel(self, excel_writer, sheet_name: 'str' = 'Sheet1', na_rep: 'str' = '', float_format: 'str | None' = None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep='inf', verbose=True, freeze_panes=None, storage_options: 'StorageOptions' = None) -> 'None': Write object to an Excel sheet."}
{"text_id": 1005142, "text": "to_excel(self, excel_writer, sheet_name: 'str' = 'Sheet1', na_rep: 'str' = '', float_format: 'str | None' = None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep='inf', verbose=True, freeze_panes=None, storage_options: 'StorageOptions' = None) -> 'None': Write object to an Excel sheet."}
{"text_id": 1005143, "text": "to_excel(self, excel_writer, sheet_name: 'str' = 'Sheet1', na_rep: 'str' = '', float_format: 'str | None' = None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep='inf', verbose=True, freeze_panes=None, storage_options: 'StorageOptions' = None) -> 'None': Write object to an Excel sheet."}
{"text_id": 1005144, "text": "to_feather(self, path: 'FilePathOrBuffer[AnyStr]', **kwargs) -> 'None': Write a DataFrame to the binary Feather format."}
{"text_id": 1005145, "text": "to_feather(df: pandas.core.frame.DataFrame, path: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], storage_options: Union[Dict[str, Any], NoneType] = None, **kwargs): Write a DataFrame to the binary Feather format."}
{"text_id": 1005146, "text": "to_feather(self, path: 'FilePathOrBuffer[AnyStr]', **kwargs) -> 'None': Write a DataFrame to the binary Feather format."}
{"text_id": 1005147, "text": "to_gbq(self, destination_table: 'str', project_id: 'str | None' = None, chunksize: 'int | None' = None, reauth: 'bool' = False, if_exists: 'str' = 'fail', auth_local_webserver: 'bool' = False, table_schema: 'list[dict[str, str]] | None' = None, location: 'str | None' = None, progress_bar: 'bool' = True, credentials=None) -> 'None': Write a DataFrame to a Google BigQuery table."}
{"text_id": 1005148, "text": "to_gbq(self, destination_table: 'str', project_id: 'str | None' = None, chunksize: 'int | None' = None, reauth: 'bool' = False, if_exists: 'str' = 'fail', auth_local_webserver: 'bool' = False, table_schema: 'list[dict[str, str]] | None' = None, location: 'str | None' = None, progress_bar: 'bool' = True, credentials=None) -> 'None': Write a DataFrame to a Google BigQuery table."}
{"text_id": 1005149, "text": "to_hdf(self, path_or_buf, key: 'str', mode: 'str' = 'a', complevel: 'int | None' = None, complib: 'str | None' = None, append: 'bool_t' = False, format: 'str | None' = None, index: 'bool_t' = True, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, dropna: 'bool_t | None' = None, data_columns: 'bool_t | list[str] | None' = None, errors: 'str' = 'strict', encoding: 'str' = 'UTF-8') -> 'None': Write the contained data to an HDF5 file using HDFStore."}
{"text_id": 1005150, "text": "to_hdf(self, path_or_buf, key: 'str', mode: 'str' = 'a', complevel: 'int | None' = None, complib: 'str | None' = None, append: 'bool_t' = False, format: 'str | None' = None, index: 'bool_t' = True, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, dropna: 'bool_t | None' = None, data_columns: 'bool_t | list[str] | None' = None, errors: 'str' = 'strict', encoding: 'str' = 'UTF-8') -> 'None': Write the contained data to an HDF5 file using HDFStore."}
{"text_id": 1005151, "text": "to_hdf(path_or_buf, key: 'str', value: 'FrameOrSeries', mode: 'str' = 'a', complevel: 'int | None' = None, complib: 'str | None' = None, append: 'bool' = False, format: 'str | None' = None, index: 'bool' = True, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, dropna: 'bool | None' = None, data_columns: 'bool | list[str] | None' = None, errors: 'str' = 'strict', encoding: 'str' = 'UTF-8'): store this object, close it if we opened it."}
{"text_id": 1005152, "text": "to_hdf(self, path_or_buf, key: 'str', mode: 'str' = 'a', complevel: 'int | None' = None, complib: 'str | None' = None, append: 'bool_t' = False, format: 'str | None' = None, index: 'bool_t' = True, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, dropna: 'bool_t | None' = None, data_columns: 'bool_t | list[str] | None' = None, errors: 'str' = 'strict', encoding: 'str' = 'UTF-8') -> 'None': Write the contained data to an HDF5 file using HDFStore."}
{"text_id": 1005153, "text": "to_hdf(self, path_or_buf, key: 'str', mode: 'str' = 'a', complevel: 'int | None' = None, complib: 'str | None' = None, append: 'bool_t' = False, format: 'str | None' = None, index: 'bool_t' = True, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, dropna: 'bool_t | None' = None, data_columns: 'bool_t | list[str] | None' = None, errors: 'str' = 'strict', encoding: 'str' = 'UTF-8') -> 'None': Write the contained data to an HDF5 file using HDFStore."}
{"text_id": 1005154, "text": "to_html(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'ColspaceArgType | None' = None, header: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatters: 'FormattersType | None' = None, float_format: 'FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, max_rows: 'int | None' = None, max_cols: 'int | None' = None, show_dimensions: 'bool | str' = False, decimal: 'str' = '.', bold_rows: 'bool' = True, classes: 'str | list | tuple | None' = None, escape: 'bool' = True, notebook: 'bool' = False, border: 'int | None' = None, table_id: 'str | None' = None, render_links: 'bool' = False, encoding: 'str | None' = None): Render a DataFrame as an HTML table."}
{"text_id": 1005155, "text": "to_html(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'ColspaceArgType | None' = None, header: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatters: 'FormattersType | None' = None, float_format: 'FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, max_rows: 'int | None' = None, max_cols: 'int | None' = None, show_dimensions: 'bool | str' = False, decimal: 'str' = '.', bold_rows: 'bool' = True, classes: 'str | list | tuple | None' = None, escape: 'bool' = True, notebook: 'bool' = False, border: 'int | None' = None, table_id: 'str | None' = None, render_links: 'bool' = False, encoding: 'str | None' = None): Render a DataFrame as an HTML table."}
{"text_id": 1005156, "text": "to_json(self, path_or_buf: 'FilePathOrBuffer | None' = None, orient: 'str | None' = None, date_format: 'str | None' = None, double_precision: 'int' = 10, force_ascii: 'bool_t' = True, date_unit: 'str' = 'ms', default_handler: 'Callable[[Any], JSONSerializable] | None' = None, lines: 'bool_t' = False, compression: 'CompressionOptions' = 'infer', index: 'bool_t' = True, indent: 'int | None' = None, storage_options: 'StorageOptions' = None) -> 'str | None': Convert the object to a JSON string."}
{"text_id": 1005157, "text": "to_json(self, path_or_buf: 'FilePathOrBuffer | None' = None, orient: 'str | None' = None, date_format: 'str | None' = None, double_precision: 'int' = 10, force_ascii: 'bool_t' = True, date_unit: 'str' = 'ms', default_handler: 'Callable[[Any], JSONSerializable] | None' = None, lines: 'bool_t' = False, compression: 'CompressionOptions' = 'infer', index: 'bool_t' = True, indent: 'int | None' = None, storage_options: 'StorageOptions' = None) -> 'str | None': Convert the object to a JSON string."}
{"text_id": 1005158, "text": "to_json(self, path_or_buf: 'FilePathOrBuffer | None' = None, orient: 'str | None' = None, date_format: 'str | None' = None, double_precision: 'int' = 10, force_ascii: 'bool_t' = True, date_unit: 'str' = 'ms', default_handler: 'Callable[[Any], JSONSerializable] | None' = None, lines: 'bool_t' = False, compression: 'CompressionOptions' = 'infer', index: 'bool_t' = True, indent: 'int | None' = None, storage_options: 'StorageOptions' = None) -> 'str | None': Convert the object to a JSON string."}
{"text_id": 1005159, "text": "to_json(self, path_or_buf: 'FilePathOrBuffer | None' = None, orient: 'str | None' = None, date_format: 'str | None' = None, double_precision: 'int' = 10, force_ascii: 'bool_t' = True, date_unit: 'str' = 'ms', default_handler: 'Callable[[Any], JSONSerializable] | None' = None, lines: 'bool_t' = False, compression: 'CompressionOptions' = 'infer', index: 'bool_t' = True, indent: 'int | None' = None, storage_options: 'StorageOptions' = None) -> 'str | None': Convert the object to a JSON string."}
{"text_id": 1005160, "text": "to_latex(self, buf=None, columns=None, col_space=None, header=True, index=True, na_rep='NaN', formatters=None, float_format=None, sparsify=None, index_names=True, bold_rows=False, column_format=None, longtable=None, escape=None, encoding=None, decimal='.', multicolumn=None, multicolumn_format=None, multirow=None, caption=None, label=None, position=None): Render object to a LaTeX tabular, longtable, or nested table/tabular."}
{"text_id": 1005161, "text": "to_latex(self, buf=None, columns=None, col_space=None, header=True, index=True, na_rep='NaN', formatters=None, float_format=None, sparsify=None, index_names=True, bold_rows=False, column_format=None, longtable=None, escape=None, encoding=None, decimal='.', multicolumn=None, multicolumn_format=None, multirow=None, caption=None, label=None, position=None): Render object to a LaTeX tabular, longtable, or nested table/tabular."}
{"text_id": 1005162, "text": "to_latex(self, buf=None, columns=None, col_space=None, header=True, index=True, na_rep='NaN', formatters=None, float_format=None, sparsify=None, index_names=True, bold_rows=False, column_format=None, longtable=None, escape=None, encoding=None, decimal='.', multicolumn=None, multicolumn_format=None, multirow=None, caption=None, label=None, position=None): Render object to a LaTeX tabular, longtable, or nested table/tabular."}
{"text_id": 1005163, "text": "to_latex(self, buf=None, columns=None, col_space=None, header=True, index=True, na_rep='NaN', formatters=None, float_format=None, sparsify=None, index_names=True, bold_rows=False, column_format=None, longtable=None, escape=None, encoding=None, decimal='.', multicolumn=None, multicolumn_format=None, multirow=None, caption=None, label=None, position=None): Render object to a LaTeX tabular, longtable, or nested table/tabular."}
{"text_id": 1005164, "text": "to_markdown(self, buf: 'IO[str] | str | None' = None, mode: 'str' = 'wt', index: 'bool' = True, storage_options: 'StorageOptions' = None, **kwargs) -> 'str | None': Print DataFrame in Markdown-friendly format."}
{"text_id": 1005165, "text": "to_markdown(self, buf: 'IO[str] | None' = None, mode: 'str' = 'wt', index: 'bool' = True, storage_options: 'StorageOptions' = None, **kwargs) -> 'str | None': Print Series in Markdown-friendly format."}
{"text_id": 1005166, "text": "to_markdown(self, buf: 'IO[str] | str | None' = None, mode: 'str' = 'wt', index: 'bool' = True, storage_options: 'StorageOptions' = None, **kwargs) -> 'str | None': Print DataFrame in Markdown-friendly format."}
{"text_id": 1005167, "text": "to_markdown(self, buf: 'IO[str] | None' = None, mode: 'str' = 'wt', index: 'bool' = True, storage_options: 'StorageOptions' = None, **kwargs) -> 'str | None': Print Series in Markdown-friendly format."}
{"text_id": 1005168, "text": "to_parquet(self, path: 'FilePathOrBuffer | None' = None, engine: 'str' = 'auto', compression: 'str | None' = 'snappy', index: 'bool | None' = None, partition_cols: 'list[str] | None' = None, storage_options: 'StorageOptions' = None, **kwargs) -> 'bytes | None': Write a DataFrame to the binary parquet format."}
{"text_id": 1005169, "text": "to_parquet(df: 'DataFrame', path: 'FilePathOrBuffer | None' = None, engine: 'str' = 'auto', compression: 'str | None' = 'snappy', index: 'bool | None' = None, storage_options: 'StorageOptions' = None, partition_cols: 'list[str] | None' = None, **kwargs) -> 'bytes | None': Write a DataFrame to the parquet format."}
{"text_id": 1005170, "text": "to_parquet(self, path: 'FilePathOrBuffer | None' = None, engine: 'str' = 'auto', compression: 'str | None' = 'snappy', index: 'bool | None' = None, partition_cols: 'list[str] | None' = None, storage_options: 'StorageOptions' = None, **kwargs) -> 'bytes | None': Write a DataFrame to the binary parquet format."}
{"text_id": 1005171, "text": "to_period(self, freq: 'Frequency | None' = None, axis: 'Axis' = 0, copy: 'bool' = True) -> 'DataFrame': Convert DataFrame from DatetimeIndex to PeriodIndex."}
{"text_id": 1005172, "text": "to_period(self, *args, **kwargs): Cast to PeriodArray/Index at a particular frequency."}
{"text_id": 1005173, "text": "to_period(self, *args, **kwargs): Cast to PeriodArray/Index at a particular frequency."}
{"text_id": 1005174, "text": "to_period(self, freq=None, copy=True) -> 'Series': Convert Series from DatetimeIndex to PeriodIndex."}
{"text_id": 1005175, "text": "to_period(self, freq=None) -> 'PeriodArray': Cast to PeriodArray/Index at a particular frequency."}
{"text_id": 1005176, "text": "to_period(self, freq: 'Frequency | None' = None, axis: 'Axis' = 0, copy: 'bool' = True) -> 'DataFrame': Convert DataFrame from DatetimeIndex to PeriodIndex."}
{"text_id": 1005177, "text": "to_period(self, *args, **kwargs): Cast to PeriodArray/Index at a particular frequency."}
{"text_id": 1005178, "text": "to_period(self, freq=None, copy=True) -> 'Series': Convert Series from DatetimeIndex to PeriodIndex."}
{"text_id": 1005179, "text": "to_pickle(self, path, compression: 'CompressionOptions' = 'infer', protocol: 'int' = 5, storage_options: 'StorageOptions' = None) -> 'None': Pickle (serialize) object to file."}
{"text_id": 1005180, "text": "to_pickle(self, path, compression: 'CompressionOptions' = 'infer', protocol: 'int' = 5, storage_options: 'StorageOptions' = None) -> 'None': Pickle (serialize) object to file."}
{"text_id": 1005181, "text": "to_pickle(obj: Any, filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', protocol: int = 5, storage_options: Union[Dict[str, Any], NoneType] = None): Pickle (serialize) object to file."}
{"text_id": 1005182, "text": "to_pickle(obj: Any, filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', protocol: int = 5, storage_options: Union[Dict[str, Any], NoneType] = None): Pickle (serialize) object to file."}
{"text_id": 1005183, "text": "to_pickle(self, path, compression: 'CompressionOptions' = 'infer', protocol: 'int' = 5, storage_options: 'StorageOptions' = None) -> 'None': Pickle (serialize) object to file."}
{"text_id": 1005184, "text": "to_pickle(self, path, compression: 'CompressionOptions' = 'infer', protocol: 'int' = 5, storage_options: 'StorageOptions' = None) -> 'None': Pickle (serialize) object to file."}
{"text_id": 1005185, "text": "to_pickle(obj: Any, filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', protocol: int = 5, storage_options: Union[Dict[str, Any], NoneType] = None): Pickle (serialize) object to file."}
{"text_id": 1005186, "text": "to_pickle(obj: Any, filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', protocol: int = 5, storage_options: Union[Dict[str, Any], NoneType] = None): Pickle (serialize) object to file."}
{"text_id": 1005187, "text": "to_pickle(obj: Any, filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', protocol: int = 5, storage_options: Union[Dict[str, Any], NoneType] = None): Pickle (serialize) object to file."}
{"text_id": 1005188, "text": "to_records(self, index=True, column_dtypes=None, index_dtypes=None) -> 'np.recarray': Convert DataFrame to a NumPy record array."}
{"text_id": 1005189, "text": "to_records(self, index=True, column_dtypes=None, index_dtypes=None) -> 'np.recarray': Convert DataFrame to a NumPy record array."}
{"text_id": 1005190, "text": "to_sql(self, name: 'str', con, schema=None, if_exists: 'str' = 'fail', index: 'bool_t' = True, index_label=None, chunksize=None, dtype: 'DtypeArg | None' = None, method=None) -> 'None': Write records stored in a DataFrame to a SQL database."}
{"text_id": 1005191, "text": "to_sql(self, name: 'str', con, schema=None, if_exists: 'str' = 'fail', index: 'bool_t' = True, index_label=None, chunksize=None, dtype: 'DtypeArg | None' = None, method=None) -> 'None': Write records stored in a DataFrame to a SQL database."}
{"text_id": 1005192, "text": "to_sql(frame, name: 'str', con, schema: 'str | None' = None, if_exists: 'str' = 'fail', index: 'bool' = True, index_label=None, chunksize: 'int | None' = None, dtype: 'DtypeArg | None' = None, method: 'str | None' = None, engine: 'str' = 'auto', **engine_kwargs) -> 'None': Write records stored in a DataFrame to a SQL database."}
{"text_id": 1005193, "text": "to_sql(self, name: 'str', con, schema=None, if_exists: 'str' = 'fail', index: 'bool_t' = True, index_label=None, chunksize=None, dtype: 'DtypeArg | None' = None, method=None) -> 'None': Write records stored in a DataFrame to a SQL database."}
{"text_id": 1005194, "text": "to_sql(self, name: 'str', con, schema=None, if_exists: 'str' = 'fail', index: 'bool_t' = True, index_label=None, chunksize=None, dtype: 'DtypeArg | None' = None, method=None) -> 'None': Write records stored in a DataFrame to a SQL database."}
{"text_id": 1005195, "text": "to_stata(self, path: 'FilePathOrBuffer', convert_dates: 'dict[Hashable, str] | None' = None, write_index: 'bool' = True, byteorder: 'str | None' = None, time_stamp: 'datetime.datetime | None' = None, data_label: 'str | None' = None, variable_labels: 'dict[Hashable, str] | None' = None, version: 'int | None' = 114, convert_strl: 'Sequence[Hashable] | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'None': Export DataFrame object to Stata dta format."}
{"text_id": 1005196, "text": "to_stata(self, path: 'FilePathOrBuffer', convert_dates: 'dict[Hashable, str] | None' = None, write_index: 'bool' = True, byteorder: 'str | None' = None, time_stamp: 'datetime.datetime | None' = None, data_label: 'str | None' = None, variable_labels: 'dict[Hashable, str] | None' = None, version: 'int | None' = 114, convert_strl: 'Sequence[Hashable] | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'None': Export DataFrame object to Stata dta format."}
{"text_id": 1005197, "text": "to_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatters: 'fmt.FormattersType | None' = None, float_format: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, max_rows: 'int | None' = None, min_rows: 'int | None' = None, max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Render a DataFrame to a console-friendly tabular output."}
{"text_id": 1005198, "text": "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None): Render a string representation of the Series."}
{"text_id": 1005199, "text": "to_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatters: 'fmt.FormattersType | None' = None, float_format: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, max_rows: 'int | None' = None, min_rows: 'int | None' = None, max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Render a DataFrame to a console-friendly tabular output."}
{"text_id": 1005200, "text": "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None): Render a string representation of the Series."}
{"text_id": 1005201, "text": "to_timestamp(self, freq: 'Frequency | None' = None, how: 'str' = 'start', axis: 'Axis' = 0, copy: 'bool' = True) -> 'DataFrame': Cast to DatetimeIndex of timestamps, at *beginning* of period."}
{"text_id": 1005202, "text": "to_timestamp(self, freq=None, how='start') -> 'DatetimeIndex': Cast to DatetimeArray/Index."}
{"text_id": 1005203, "text": "to_timestamp(self, *args, **kwargs): Cast to DatetimeArray/Index."}
{"text_id": 1005204, "text": "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series': Cast to DatetimeIndex of Timestamps, at *beginning* of period."}
{"text_id": 1005205, "text": "to_timestamp(self, freq=None, how: 'str' = 'start') -> 'DatetimeArray': Cast to DatetimeArray/Index."}
{"text_id": 1005206, "text": "to_timestamp(self, freq: 'Frequency | None' = None, how: 'str' = 'start', axis: 'Axis' = 0, copy: 'bool' = True) -> 'DataFrame': Cast to DatetimeIndex of timestamps, at *beginning* of period."}
{"text_id": 1005207, "text": "to_timestamp(self, freq=None, how='start') -> 'DatetimeIndex': Cast to DatetimeArray/Index."}
{"text_id": 1005208, "text": "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series': Cast to DatetimeIndex of Timestamps, at *beginning* of period."}
{"text_id": 1005209, "text": "to_xarray(self): Return an xarray object from the pandas object."}
{"text_id": 1005210, "text": "to_xarray(self): Return an xarray object from the pandas object."}
{"text_id": 1005211, "text": "to_xarray(self): Return an xarray object from the pandas object."}
{"text_id": 1005212, "text": "to_xarray(self): Return an xarray object from the pandas object."}
{"text_id": 1005213, "text": "to_xml(self, path_or_buffer: 'FilePathOrBuffer | None' = None, index: 'bool' = True, root_name: 'str | None' = 'data', row_name: 'str | None' = 'row', na_rep: 'str | None' = None, attr_cols: 'str | list[str] | None' = None, elem_cols: 'str | list[str] | None' = None, namespaces: 'dict[str | None, str] | None' = None, prefix: 'str | None' = None, encoding: 'str' = 'utf-8', xml_declaration: 'bool | None' = True, pretty_print: 'bool | None' = True, parser: 'str | None' = 'lxml', stylesheet: 'FilePathOrBuffer | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'str | None': Render a DataFrame to an XML document."}
{"text_id": 1005214, "text": "to_xml(self, path_or_buffer: 'FilePathOrBuffer | None' = None, index: 'bool' = True, root_name: 'str | None' = 'data', row_name: 'str | None' = 'row', na_rep: 'str | None' = None, attr_cols: 'str | list[str] | None' = None, elem_cols: 'str | list[str] | None' = None, namespaces: 'dict[str | None, str] | None' = None, prefix: 'str | None' = None, encoding: 'str' = 'utf-8', xml_declaration: 'bool | None' = True, pretty_print: 'bool | None' = True, parser: 'str | None' = 'lxml', stylesheet: 'FilePathOrBuffer | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'str | None': Render a DataFrame to an XML document."}
{"text_id": 1005215, "text": "transform(self, func: 'AggFuncType', axis: 'Axis' = 0, *args, **kwargs) -> 'DataFrame': Call ``func`` on self producing a DataFrame with transformed values."}
{"text_id": 1005216, "text": "transform(self, func: 'AggFuncType', axis: 'Axis' = 0, *args, **kwargs) -> 'FrameOrSeriesUnion': Call ``func`` on self producing a Series with transformed values."}
{"text_id": 1005217, "text": "transform(self, func: 'AggFuncType', axis: 'Axis' = 0, *args, **kwargs) -> 'DataFrame': Call ``func`` on self producing a DataFrame with transformed values."}
{"text_id": 1005218, "text": "transform(self, func: 'AggFuncType', axis: 'Axis' = 0, *args, **kwargs) -> 'FrameOrSeriesUnion': Call ``func`` on self producing a Series with transformed values."}
{"text_id": 1005219, "text": "truediv(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `truediv`)."}
{"text_id": 1005220, "text": "truediv(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `truediv`)."}
{"text_id": 1005221, "text": "truediv(self, other, axis='columns', level=None, fill_value=None): Get Floating division of dataframe and other, element-wise (binary operator `truediv`)."}
{"text_id": 1005222, "text": "truediv(self, other, level=None, fill_value=None, axis=0): Return Floating division of series and other, element-wise (binary operator `truediv`)."}
{"text_id": 1005223, "text": "truncate(self: 'FrameOrSeries', before=None, after=None, axis=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Truncate a Series or DataFrame before and after some index value."}
{"text_id": 1005224, "text": "truncate(self, before=None, after=None) -> 'MultiIndex': Slice index between two labels / tuples, return new MultiIndex."}
{"text_id": 1005225, "text": "truncate(self: 'FrameOrSeries', before=None, after=None, axis=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Truncate a Series or DataFrame before and after some index value."}
{"text_id": 1005226, "text": "truncate(self: 'FrameOrSeries', before=None, after=None, axis=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Truncate a Series or DataFrame before and after some index value."}
{"text_id": 1005227, "text": "truncate(self, before=None, after=None) -> 'MultiIndex': Slice index between two labels / tuples, return new MultiIndex."}
{"text_id": 1005228, "text": "truncate(self: 'FrameOrSeries', before=None, after=None, axis=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Truncate a Series or DataFrame before and after some index value."}
{"text_id": 1005229, "text": "tshift(self: 'FrameOrSeries', periods: 'int' = 1, freq=None, axis: 'Axis' = 0) -> 'FrameOrSeries': Shift the time index, using the index's frequency if available."}
{"text_id": 1005230, "text": "tshift(self: 'FrameOrSeries', periods: 'int' = 1, freq=None, axis: 'Axis' = 0) -> 'FrameOrSeries': Shift the time index, using the index's frequency if available."}
{"text_id": 1005231, "text": "tshift(self: 'FrameOrSeries', periods: 'int' = 1, freq=None, axis: 'Axis' = 0) -> 'FrameOrSeries': Shift the time index, using the index's frequency if available."}
{"text_id": 1005232, "text": "tshift(self: 'FrameOrSeries', periods: 'int' = 1, freq=None, axis: 'Axis' = 0) -> 'FrameOrSeries': Shift the time index, using the index's frequency if available."}
{"text_id": 1005233, "text": "tz_convert(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Convert tz-aware axis to target time zone."}
{"text_id": 1005234, "text": "tz_convert(self, tz) -> 'DatetimeIndex': Convert tz-aware Datetime Array/Index from one time zone to another."}
{"text_id": 1005235, "text": "tz_convert(*args, **kwargs): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005236, "text": "tz_convert(self, tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005237, "text": "tz_convert(*args, **kwargs): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005238, "text": "tz_convert(self, *args, **kwargs): Convert tz-aware Datetime Array/Index from one time zone to another."}
{"text_id": 1005239, "text": "tz_convert(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Convert tz-aware axis to target time zone."}
{"text_id": 1005240, "text": "tz_convert(tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005241, "text": "tz_convert(tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005242, "text": "tz_convert(self, tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005243, "text": "tz_convert(self, tz) -> 'DatetimeArray': Convert tz-aware Datetime Array/Index from one time zone to another."}
{"text_id": 1005244, "text": "tz_convert(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Convert tz-aware axis to target time zone."}
{"text_id": 1005245, "text": "tz_convert(self, tz) -> 'DatetimeIndex': Convert tz-aware Datetime Array/Index from one time zone to another."}
{"text_id": 1005246, "text": "tz_convert(*args, **kwargs): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005247, "text": "tz_convert(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True) -> 'FrameOrSeries': Convert tz-aware axis to target time zone."}
{"text_id": 1005248, "text": "tz_convert(self, tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005249, "text": "tz_localize(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True, ambiguous='raise', nonexistent: 'str' = 'raise') -> 'FrameOrSeries': Localize tz-naive index of a Series or DataFrame to target time zone."}
{"text_id": 1005250, "text": "tz_localize(self, tz, ambiguous='raise', nonexistent='raise') -> 'DatetimeIndex': Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index."}
{"text_id": 1005251, "text": "tz_localize(*args, **kwargs): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005252, "text": "tz_localize(self, tz, ambiguous='raise', nonexistent='raise'): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005253, "text": "tz_localize(*args, **kwargs): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005254, "text": "tz_localize(self, *args, **kwargs): Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index."}
{"text_id": 1005255, "text": "tz_localize(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True, ambiguous='raise', nonexistent: 'str' = 'raise') -> 'FrameOrSeries': Localize tz-naive index of a Series or DataFrame to target time zone."}
{"text_id": 1005256, "text": "tz_localize(tz, ambiguous='raise', nonexistent='raise'): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005257, "text": "tz_localize(tz, ambiguous='raise', nonexistent='raise'): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005258, "text": "tz_localize(self, tz, ambiguous='raise', nonexistent='raise'): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005259, "text": "tz_localize(self, tz, ambiguous='raise', nonexistent='raise') -> 'DatetimeArray': Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index."}
{"text_id": 1005260, "text": "tz_localize(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True, ambiguous='raise', nonexistent: 'str' = 'raise') -> 'FrameOrSeries': Localize tz-naive index of a Series or DataFrame to target time zone."}
{"text_id": 1005261, "text": "tz_localize(self, tz, ambiguous='raise', nonexistent='raise') -> 'DatetimeIndex': Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index."}
{"text_id": 1005262, "text": "tz_localize(*args, **kwargs): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005263, "text": "tz_localize(self: 'FrameOrSeries', tz, axis=0, level=None, copy: 'bool_t' = True, ambiguous='raise', nonexistent: 'str' = 'raise') -> 'FrameOrSeries': Localize tz-naive index of a Series or DataFrame to target time zone."}
{"text_id": 1005264, "text": "tz_localize(self, tz, ambiguous='raise', nonexistent='raise'): Convert naive Timestamp to local time zone, or remove timezone from tz-aware Timestamp."}
{"text_id": 1005265, "text": "unstack(self, level: 'Level' = -1, fill_value=None): Pivot a level of the (necessarily hierarchical) index labels."}
{"text_id": 1005266, "text": "unstack(self, level=-1, fill_value=None) -> 'DataFrame': Unstack, also known as pivot, Series with MultiIndex to produce DataFrame."}
{"text_id": 1005267, "text": "unstack(self, level: 'Level' = -1, fill_value=None): Pivot a level of the (necessarily hierarchical) index labels."}
{"text_id": 1005268, "text": "unstack(self, level=-1, fill_value=None) -> 'DataFrame': Unstack, also known as pivot, Series with MultiIndex to produce DataFrame."}
{"text_id": 1005269, "text": "update(self, other, join: 'str' = 'left', overwrite: 'bool' = True, filter_func=None, errors: 'str' = 'ignore') -> 'None': Modify in place using non-NA values from another DataFrame."}
{"text_id": 1005270, "text": "update(self, other) -> 'None': Modify Series in place using values from passed Series."}
{"text_id": 1005271, "text": "update(self, other, join: 'str' = 'left', overwrite: 'bool' = True, filter_func=None, errors: 'str' = 'ignore') -> 'None': Modify in place using non-NA values from another DataFrame."}
{"text_id": 1005272, "text": "update(self, other) -> 'None': Modify Series in place using values from passed Series."}
{"text_id": 1005273, "text": "update(self, *args, **kwargs) -> 'None': Update self."}
{"text_id": 1005274, "text": "var(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased variance over requested axis."}
{"text_id": 1005275, "text": "var(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased variance over requested axis."}
{"text_id": 1005276, "text": "var(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased variance over requested axis."}
{"text_id": 1005277, "text": "var(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return unbiased variance over requested axis."}
{"text_id": 1005278, "text": "xs(self, key, axis=0, level=None, drop_level: 'bool_t' = True): Return cross-section from the Series/DataFrame."}
{"text_id": 1005279, "text": "xs(self, key, axis=0, level=None, drop_level: 'bool_t' = True): Return cross-section from the Series/DataFrame."}
{"text_id": 1005280, "text": "xs(self, key, axis=0, level=None, drop_level: 'bool_t' = True): Return cross-section from the Series/DataFrame."}
{"text_id": 1005281, "text": "xs(self, key, axis=0, level=None, drop_level: 'bool_t' = True): Return cross-section from the Series/DataFrame."}
{"text_id": 1005282, "text": "rollback(self, other): Roll provided date backward to next offset only if not on offset."}
{"text_id": 1005283, "text": "rollback(self, other): Roll provided date backward to next offset only if not on offset."}
{"text_id": 1005284, "text": "rollforward(self, other): Roll provided date forward to next offset only if not on offset."}
{"text_id": 1005285, "text": "rollforward(self, other): Roll provided date forward to next offset only if not on offset."}
{"text_id": 1005286, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005287, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005288, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005289, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005290, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005291, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005292, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005293, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005294, "text": "DatetimeIndex(data=None, freq=<no_default>, tz=None, normalize: 'bool' = False, closed=None, ambiguous='raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'DatetimeIndex': Immutable ndarray-like of datetime64 data."}
{"text_id": 1005295, "text": "ceil(self, *args, **kwargs): Perform ceil operation on the data to the specified `freq`."}
{"text_id": 1005296, "text": "ceil(*args, **kwargs): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005297, "text": "ceil(self, freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005298, "text": "ceil(*args, **kwargs): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005299, "text": "ceil(self, *args, **kwargs): Perform ceil operation on the data to the specified `freq`."}
{"text_id": 1005300, "text": "ceil(self, freq): Return a new Timedelta ceiled to this resolution."}
{"text_id": 1005301, "text": "ceil(freq): Return a new Timedelta ceiled to this resolution."}
{"text_id": 1005302, "text": "ceil(freq): Return a new Timedelta ceiled to this resolution."}
{"text_id": 1005303, "text": "ceil(freq): Return a new Timedelta ceiled to this resolution."}
{"text_id": 1005304, "text": "ceil(self, *args, **kwargs): Perform ceil operation on the data to the specified `freq`."}
{"text_id": 1005305, "text": "ceil(self, freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005306, "text": "ceil(freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005307, "text": "ceil(freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005308, "text": "ceil(freq): Return a new Timedelta ceiled to this resolution."}
{"text_id": 1005309, "text": "ceil(self, freq, ambiguous='raise', nonexistent='raise'): Perform ceil operation on the data to the specified `freq`."}
{"text_id": 1005310, "text": "ceil(self, freq, ambiguous='raise', nonexistent='raise'): Perform ceil operation on the data to the specified `freq`."}
{"text_id": 1005311, "text": "ceil(self, *args, **kwargs): Perform ceil operation on the data to the specified `freq`."}
{"text_id": 1005312, "text": "ceil(*args, **kwargs): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005313, "text": "ceil(self, freq): Return a new Timedelta ceiled to this resolution."}
{"text_id": 1005314, "text": "ceil(self, *args, **kwargs): Perform ceil operation on the data to the specified `freq`."}
{"text_id": 1005315, "text": "ceil(self, freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp ceiled to this resolution."}
{"text_id": 1005316, "text": "date(*args, **kwargs): Return date object with same year, month and day."}
{"text_id": 1005317, "text": "date(*args, **kwargs): Return date object with same year, month and day."}
{"text_id": 1005318, "text": "date(*args, **kwargs): Return date object with same year, month and day."}
{"text_id": 1005319, "text": "day_name(self, *args, **kwargs): Return the day names of the DateTimeIndex with specified locale."}
{"text_id": 1005320, "text": "day_name(*args, **kwargs): Return the day name of the Timestamp with specified locale."}
{"text_id": 1005321, "text": "day_name(*args, **kwargs): Return the day name of the Timestamp with specified locale."}
{"text_id": 1005322, "text": "day_name(self, *args, **kwargs): Return the day names of the DateTimeIndex with specified locale."}
{"text_id": 1005323, "text": "day_name(self, locale=None): Return the day names of the DateTimeIndex with specified locale."}
{"text_id": 1005324, "text": "day_name(self, *args, **kwargs): Return the day names of the DateTimeIndex with specified locale."}
{"text_id": 1005325, "text": "day_name(*args, **kwargs): Return the day name of the Timestamp with specified locale."}
{"text_id": 1005326, "text": "floor(self, *args, **kwargs): Perform floor operation on the data to the specified `freq`."}
{"text_id": 1005327, "text": "floor(*args, **kwargs): Return a new Timestamp floored to this resolution."}
{"text_id": 1005328, "text": "floor(self, freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp floored to this resolution."}
{"text_id": 1005329, "text": "floor(*args, **kwargs): Return a new Timestamp floored to this resolution."}
{"text_id": 1005330, "text": "floor(self, *args, **kwargs): Perform floor operation on the data to the specified `freq`."}
{"text_id": 1005331, "text": "floor(self, freq): Return a new Timedelta floored to this resolution."}
{"text_id": 1005332, "text": "floor(freq): Return a new Timedelta floored to this resolution."}
{"text_id": 1005333, "text": "floor(freq): Return a new Timedelta floored to this resolution."}
{"text_id": 1005334, "text": "floor(freq): Return a new Timedelta floored to this resolution."}
{"text_id": 1005335, "text": "floor(self, *args, **kwargs): Perform floor operation on the data to the specified `freq`."}
{"text_id": 1005336, "text": "floor(self, freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp floored to this resolution."}
{"text_id": 1005337, "text": "floor(freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp floored to this resolution."}
{"text_id": 1005338, "text": "floor(freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp floored to this resolution."}
{"text_id": 1005339, "text": "floor(freq): Return a new Timedelta floored to this resolution."}
{"text_id": 1005340, "text": "floor(self, freq, ambiguous='raise', nonexistent='raise'): Perform floor operation on the data to the specified `freq`."}
{"text_id": 1005341, "text": "floor(self, freq, ambiguous='raise', nonexistent='raise'): Perform floor operation on the data to the specified `freq`."}
{"text_id": 1005342, "text": "floor(self, *args, **kwargs): Perform floor operation on the data to the specified `freq`."}
{"text_id": 1005343, "text": "floor(*args, **kwargs): Return a new Timestamp floored to this resolution."}
{"text_id": 1005344, "text": "floor(self, freq): Return a new Timedelta floored to this resolution."}
{"text_id": 1005345, "text": "floor(self, *args, **kwargs): Perform floor operation on the data to the specified `freq`."}
{"text_id": 1005346, "text": "floor(self, freq, ambiguous='raise', nonexistent='raise'): Return a new Timestamp floored to this resolution."}
{"text_id": 1005347, "text": "indexer_at_time(self, time, asof: 'bool' = False) -> 'np.ndarray': Return index locations of values at particular time of day (e."}
{"text_id": 1005348, "text": "indexer_at_time(self, time, asof: 'bool' = False) -> 'np.ndarray': Return index locations of values at particular time of day (e."}
{"text_id": 1005349, "text": "indexer_between_time(self, start_time, end_time, include_start: 'bool' = True, include_end: 'bool' = True) -> 'np.ndarray': Return index locations of values between particular times of day (e."}
{"text_id": 1005350, "text": "indexer_between_time(self, start_time, end_time, include_start: 'bool' = True, include_end: 'bool' = True) -> 'np.ndarray': Return index locations of values between particular times of day (e."}
{"text_id": 1005351, "text": "isocalendar(self) -> 'DataFrame': Returns a DataFrame with the year, week, and day calculated according to the ISO 8601 standard."}
{"text_id": 1005352, "text": "isocalendar(*args, **kwargs): Return a 3-tuple containing ISO year, week number, and weekday."}
{"text_id": 1005353, "text": "isocalendar(*args, **kwargs): Return a 3-tuple containing ISO year, week number, and weekday."}
{"text_id": 1005354, "text": "isocalendar(self): Returns a DataFrame with the year, week, and day calculated according to the ISO 8601 standard."}
{"text_id": 1005355, "text": "isocalendar(self) -> 'DataFrame': Returns a DataFrame with the year, week, and day calculated according to the ISO 8601 standard."}
{"text_id": 1005356, "text": "isocalendar(self) -> 'DataFrame': Returns a DataFrame with the year, week, and day calculated according to the ISO 8601 standard."}
{"text_id": 1005357, "text": "isocalendar(*args, **kwargs): Return a 3-tuple containing ISO year, week number, and weekday."}
{"text_id": 1005358, "text": "month_name(self, *args, **kwargs): Return the month names of the DateTimeIndex with specified locale."}
{"text_id": 1005359, "text": "month_name(*args, **kwargs): Return the month name of the Timestamp with specified locale."}
{"text_id": 1005360, "text": "month_name(*args, **kwargs): Return the month name of the Timestamp with specified locale."}
{"text_id": 1005361, "text": "month_name(self, *args, **kwargs): Return the month names of the DateTimeIndex with specified locale."}
{"text_id": 1005362, "text": "month_name(self, locale=None): Return the month names of the DateTimeIndex with specified locale."}
{"text_id": 1005363, "text": "month_name(self, *args, **kwargs): Return the month names of the DateTimeIndex with specified locale."}
{"text_id": 1005364, "text": "month_name(*args, **kwargs): Return the month name of the Timestamp with specified locale."}
{"text_id": 1005365, "text": "snap(self, freq='S') -> 'DatetimeIndex': Snap time stamps to nearest occurring frequency."}
{"text_id": 1005366, "text": "snap(self, freq='S') -> 'DatetimeIndex': Snap time stamps to nearest occurring frequency."}
{"text_id": 1005367, "text": "strftime(self, *args, **kwargs): Convert to Index using specified date_format."}
{"text_id": 1005368, "text": "strftime(*args, **kwargs): Timestamp."}
{"text_id": 1005369, "text": "strftime(self, format): Timestamp."}
{"text_id": 1005370, "text": "strftime(*args, **kwargs): Timestamp."}
{"text_id": 1005371, "text": "strftime(self, *args, **kwargs): Convert to Index using specified date_format."}
{"text_id": 1005372, "text": "strftime(self, *args, **kwargs): Convert to Index using specified date_format."}
{"text_id": 1005373, "text": "strftime(format): Timestamp."}
{"text_id": 1005374, "text": "strftime(format): Timestamp."}
{"text_id": 1005375, "text": "strftime(self, format): Timestamp."}
{"text_id": 1005376, "text": "strftime(self, date_format: 'str') -> 'np.ndarray': Convert to Index using specified date_format."}
{"text_id": 1005377, "text": "strftime(self, date_format: 'str') -> 'np.ndarray': Convert to Index using specified date_format."}
{"text_id": 1005378, "text": "strftime(self, *args, **kwargs): Convert to Index using specified date_format."}
{"text_id": 1005379, "text": "strftime(*args, **kwargs): Timestamp."}
{"text_id": 1005380, "text": "strftime(self, *args, **kwargs): Convert to Index using specified date_format."}
{"text_id": 1005381, "text": "strftime(self, format): Timestamp."}
{"text_id": 1005382, "text": "time(*args, **kwargs): Return time object with same time but with tzinfo=None."}
{"text_id": 1005383, "text": "time(*args, **kwargs): Return time object with same time but with tzinfo=None."}
{"text_id": 1005384, "text": "time(*args, **kwargs): Return time object with same time but with tzinfo=None."}
{"text_id": 1005385, "text": "timetz(*args, **kwargs): Return time object with same time and tzinfo."}
{"text_id": 1005386, "text": "timetz(*args, **kwargs): Return time object with same time and tzinfo."}
{"text_id": 1005387, "text": "timetz(*args, **kwargs): Return time object with same time and tzinfo."}
{"text_id": 1005388, "text": "to_julian_date(self) -> 'Float64Index': Convert Datetime Array to float64 ndarray of Julian Dates."}
{"text_id": 1005389, "text": "to_julian_date(self) -> numpy.float64: Convert TimeStamp to a Julian Date."}
{"text_id": 1005390, "text": "to_julian_date() -> numpy.float64: Convert TimeStamp to a Julian Date."}
{"text_id": 1005391, "text": "to_julian_date() -> numpy.float64: Convert TimeStamp to a Julian Date."}
{"text_id": 1005392, "text": "to_julian_date(self) -> numpy.float64: Convert TimeStamp to a Julian Date."}
{"text_id": 1005393, "text": "to_julian_date(self) -> 'np.ndarray': Convert Datetime Array to float64 ndarray of Julian Dates."}
{"text_id": 1005394, "text": "to_julian_date(self) -> 'Float64Index': Convert Datetime Array to float64 ndarray of Julian Dates."}
{"text_id": 1005395, "text": "to_julian_date(self) -> numpy.float64: Convert TimeStamp to a Julian Date."}
{"text_id": 1005396, "text": "to_perioddelta(self, freq) -> 'TimedeltaIndex': Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified freq."}
{"text_id": 1005397, "text": "to_perioddelta(self, freq) -> 'TimedeltaArray': Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified freq."}
{"text_id": 1005398, "text": "to_perioddelta(self, freq) -> 'TimedeltaIndex': Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified freq."}
{"text_id": 1005399, "text": "to_pydatetime(self, *args, **kwargs): Return Datetime Array/Index as object ndarray of datetime."}
{"text_id": 1005400, "text": "to_pydatetime(*args, **kwargs): Convert a Timestamp object to a native Python datetime object."}
{"text_id": 1005401, "text": "to_pydatetime(*args, **kwargs): Convert a Timestamp object to a native Python datetime object."}
{"text_id": 1005402, "text": "to_pydatetime(self) -> 'np.ndarray': Return the data as an array of native Python datetime objects."}
{"text_id": 1005403, "text": "to_pydatetime(self) -> 'np.ndarray': Return Datetime Array/Index as object ndarray of datetime."}
{"text_id": 1005404, "text": "to_pydatetime(self, *args, **kwargs): Return Datetime Array/Index as object ndarray of datetime."}
{"text_id": 1005405, "text": "to_pydatetime(*args, **kwargs): Convert a Timestamp object to a native Python datetime object."}
{"text_id": 1005406, "text": "union_many(self, others): A bit of a hack to accelerate unioning a collection of indexes."}
{"text_id": 1005407, "text": "union_many(self, others): A bit of a hack to accelerate unioning a collection of indexes."}
{"text_id": 1005408, "text": "weekday(*args, **kwargs): Return the day of the week represented by the date."}
{"text_id": 1005409, "text": "weekday(*args, **kwargs): Return the day of the week represented by the date."}
{"text_id": 1005410, "text": "weekday(*args, **kwargs): Return the day of the week represented by the date."}
{"text_id": 1005411, "text": "DatetimeTZDtype(unit: 'str_type | DatetimeTZDtype' = 'ns', tz=None): An ExtensionDtype for timezone-aware datetime data."}
{"text_id": 1005412, "text": "DatetimeTZDtype(unit: 'str_type | DatetimeTZDtype' = 'ns', tz=None): An ExtensionDtype for timezone-aware datetime data."}
{"text_id": 1005413, "text": "DatetimeTZDtype(unit: 'str_type | DatetimeTZDtype' = 'ns', tz=None): An ExtensionDtype for timezone-aware datetime data."}
{"text_id": 1005414, "text": "DatetimeTZDtype(unit: 'str_type | DatetimeTZDtype' = 'ns', tz=None): An ExtensionDtype for timezone-aware datetime data."}
{"text_id": 1005415, "text": "DatetimeTZDtype(unit: 'str_type | DatetimeTZDtype' = 'ns', tz=None): An ExtensionDtype for timezone-aware datetime data."}
{"text_id": 1005416, "text": "DatetimeTZDtype(unit: 'str_type | DatetimeTZDtype' = 'ns', tz=None): An ExtensionDtype for timezone-aware datetime data."}
{"text_id": 1005417, "text": "DatetimeTZDtype(unit: 'str_type | DatetimeTZDtype' = 'ns', tz=None): An ExtensionDtype for timezone-aware datetime data."}
{"text_id": 1005418, "text": "astimezone(*args, **kwargs): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005419, "text": "astimezone(self, tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005420, "text": "astimezone(*args, **kwargs): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005421, "text": "astimezone(self, tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005422, "text": "astimezone(tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005423, "text": "astimezone(tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005424, "text": "astimezone(*args, **kwargs): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005425, "text": "astimezone(self, tz): Convert tz-aware Timestamp to another time zone."}
{"text_id": 1005426, "text": "ctime(*args, **kwargs): Return ctime() style string."}
{"text_id": 1005427, "text": "ctime(*args, **kwargs): Return ctime() style string."}
{"text_id": 1005428, "text": "ctime(*args, **kwargs): Return ctime() style string."}
{"text_id": 1005429, "text": "dst(*args, **kwargs): Return self."}
{"text_id": 1005430, "text": "dst(*args, **kwargs): Return self."}
{"text_id": 1005431, "text": "dst(*args, **kwargs): Return self."}
{"text_id": 1005432, "text": "fromisocalendar(*args, **kwargs): int, int, int -> Construct a date from the ISO year, week number and weekday."}
{"text_id": 1005433, "text": "fromisocalendar(*args, **kwargs): int, int, int -> Construct a date from the ISO year, week number and weekday."}
{"text_id": 1005434, "text": "fromisocalendar(*args, **kwargs): int, int, int -> Construct a date from the ISO year, week number and weekday."}
{"text_id": 1005435, "text": "fromordinal(*args, **kwargs): Timestamp."}
{"text_id": 1005436, "text": "fromordinal(ordinal, freq=None, tz=None): Timestamp."}
{"text_id": 1005437, "text": "fromordinal(*args, **kwargs): Timestamp."}
{"text_id": 1005438, "text": "fromordinal(ordinal, freq=None, tz=None): Timestamp."}
{"text_id": 1005439, "text": "fromordinal(ordinal, freq=None, tz=None): Timestamp."}
{"text_id": 1005440, "text": "fromordinal(ordinal, freq=None, tz=None): Timestamp."}
{"text_id": 1005441, "text": "fromordinal(*args, **kwargs): Timestamp."}
{"text_id": 1005442, "text": "fromordinal(ordinal, freq=None, tz=None): Timestamp."}
{"text_id": 1005443, "text": "fromtimestamp(*args, **kwargs): Timestamp."}
{"text_id": 1005444, "text": "fromtimestamp(ts): Timestamp."}
{"text_id": 1005445, "text": "fromtimestamp(*args, **kwargs): Timestamp."}
{"text_id": 1005446, "text": "fromtimestamp(ts): Timestamp."}
{"text_id": 1005447, "text": "fromtimestamp(ts): Timestamp."}
{"text_id": 1005448, "text": "fromtimestamp(ts): Timestamp."}
{"text_id": 1005449, "text": "fromtimestamp(*args, **kwargs): Timestamp."}
{"text_id": 1005450, "text": "fromtimestamp(ts): Timestamp."}
{"text_id": 1005451, "text": "isoweekday(*args, **kwargs): Return the day of the week represented by the date."}
{"text_id": 1005452, "text": "isoweekday(*args, **kwargs): Return the day of the week represented by the date."}
{"text_id": 1005453, "text": "isoweekday(*args, **kwargs): Return the day of the week represented by the date."}
{"text_id": 1005454, "text": "now(*args, **kwargs): Timestamp."}
{"text_id": 1005455, "text": "now(tz=None): Timestamp."}
{"text_id": 1005456, "text": "now(tz=None): Returns new datetime object representing current time local to tz."}
{"text_id": 1005457, "text": "now(tz=None): Returns new datetime object representing current time local to tz."}
{"text_id": 1005458, "text": "now(*args, **kwargs): Timestamp."}
{"text_id": 1005459, "text": "now(tz=None): Timestamp."}
{"text_id": 1005460, "text": "now(tz=None): Timestamp."}
{"text_id": 1005461, "text": "now(tz=None): Timestamp."}
{"text_id": 1005462, "text": "now(*args, **kwargs): Timestamp."}
{"text_id": 1005463, "text": "now(tz=None): Timestamp."}
{"text_id": 1005464, "text": "strptime(*args, **kwargs): Timestamp."}
{"text_id": 1005465, "text": "strptime(date_string, format): Timestamp."}
{"text_id": 1005466, "text": "strptime(*args, **kwargs): Timestamp."}
{"text_id": 1005467, "text": "strptime(date_string, format): Timestamp."}
{"text_id": 1005468, "text": "strptime(date_string, format): Timestamp."}
{"text_id": 1005469, "text": "strptime(date_string, format): Timestamp."}
{"text_id": 1005470, "text": "strptime(*args, **kwargs): Timestamp."}
{"text_id": 1005471, "text": "strptime(date_string, format): Timestamp."}
{"text_id": 1005472, "text": "timestamp(*args, **kwargs): Return POSIX timestamp as float."}
{"text_id": 1005473, "text": "timestamp(*args, **kwargs): Return POSIX timestamp as float."}
{"text_id": 1005474, "text": "timestamp(*args, **kwargs): Return POSIX timestamp as float."}
{"text_id": 1005475, "text": "timetuple(*args, **kwargs): Return time tuple, compatible with time."}
{"text_id": 1005476, "text": "timetuple(*args, **kwargs): Return time tuple, compatible with time."}
{"text_id": 1005477, "text": "timetuple(*args, **kwargs): Return time tuple, compatible with time."}
{"text_id": 1005478, "text": "today(*args, **kwargs): Timestamp."}
{"text_id": 1005479, "text": "today(tz=None): Timestamp."}
{"text_id": 1005480, "text": "today(*args, **kwargs): Timestamp."}
{"text_id": 1005481, "text": "today(tz=None): Timestamp."}
{"text_id": 1005482, "text": "today(tz=None): Timestamp."}
{"text_id": 1005483, "text": "today(tz=None): Timestamp."}
{"text_id": 1005484, "text": "today(*args, **kwargs): Timestamp."}
{"text_id": 1005485, "text": "today(tz=None): Timestamp."}
{"text_id": 1005486, "text": "toordinal(*args, **kwargs): Return proleptic Gregorian ordinal."}
{"text_id": 1005487, "text": "toordinal(*args, **kwargs): Return proleptic Gregorian ordinal."}
{"text_id": 1005488, "text": "toordinal(*args, **kwargs): Return proleptic Gregorian ordinal."}
{"text_id": 1005489, "text": "total_seconds(*args, **kwargs): Total seconds in the duration."}
{"text_id": 1005490, "text": "total_seconds(*args, **kwargs): Total seconds in the duration."}
{"text_id": 1005491, "text": "total_seconds(self, *args, **kwargs): Return total duration of each element expressed in seconds."}
{"text_id": 1005492, "text": "total_seconds(self, *args, **kwargs): Return total duration of each element expressed in seconds."}
{"text_id": 1005493, "text": "total_seconds(self) -> 'np.ndarray': Return total duration of each element expressed in seconds."}
{"text_id": 1005494, "text": "total_seconds(*args, **kwargs): Total seconds in the duration."}
{"text_id": 1005495, "text": "total_seconds(self, *args, **kwargs): Return total duration of each element expressed in seconds."}
{"text_id": 1005496, "text": "tzname(*args, **kwargs): Return self."}
{"text_id": 1005497, "text": "tzname(*args, **kwargs): Return self."}
{"text_id": 1005498, "text": "tzname(*args, **kwargs): Return self."}
{"text_id": 1005499, "text": "utcfromtimestamp(*args, **kwargs): Timestamp."}
{"text_id": 1005500, "text": "utcfromtimestamp(ts): Timestamp."}
{"text_id": 1005501, "text": "utcfromtimestamp(*args, **kwargs): Timestamp."}
{"text_id": 1005502, "text": "utcfromtimestamp(ts): Timestamp."}
{"text_id": 1005503, "text": "utcfromtimestamp(ts): Timestamp."}
{"text_id": 1005504, "text": "utcfromtimestamp(ts): Timestamp."}
{"text_id": 1005505, "text": "utcfromtimestamp(*args, **kwargs): Timestamp."}
{"text_id": 1005506, "text": "utcfromtimestamp(ts): Timestamp."}
{"text_id": 1005507, "text": "utcnow(*args, **kwargs): Timestamp."}
{"text_id": 1005508, "text": "utcnow(): Timestamp."}
{"text_id": 1005509, "text": "utcnow(*args, **kwargs): Timestamp."}
{"text_id": 1005510, "text": "utcnow(): Timestamp."}
{"text_id": 1005511, "text": "utcnow(): Timestamp."}
{"text_id": 1005512, "text": "utcnow(): Timestamp."}
{"text_id": 1005513, "text": "utcnow(*args, **kwargs): Timestamp."}
{"text_id": 1005514, "text": "utcnow(): Timestamp."}
{"text_id": 1005515, "text": "utcoffset(*args, **kwargs): Return self."}
{"text_id": 1005516, "text": "utcoffset(*args, **kwargs): Return self."}
{"text_id": 1005517, "text": "utcoffset(*args, **kwargs): Return self."}
{"text_id": 1005518, "text": "utctimetuple(*args, **kwargs): Return UTC time tuple, compatible with time."}
{"text_id": 1005519, "text": "utctimetuple(*args, **kwargs): Return UTC time tuple, compatible with time."}
{"text_id": 1005520, "text": "utctimetuple(*args, **kwargs): Return UTC time tuple, compatible with time."}
{"text_id": 1005521, "text": "ExcelFile(path_or_buffer, engine=None, storage_options: 'StorageOptions' = None): Class for parsing tabular excel sheets into DataFrame objects."}
{"text_id": 1005522, "text": "ExcelFile(path_or_buffer, engine=None, storage_options: 'StorageOptions' = None): Class for parsing tabular excel sheets into DataFrame objects."}
{"text_id": 1005523, "text": "ExcelFile(path_or_buffer, engine=None, storage_options: 'StorageOptions' = None): Class for parsing tabular excel sheets into DataFrame objects."}
{"text_id": 1005524, "text": "ExcelFile(path_or_buffer, engine=None, storage_options: 'StorageOptions' = None): Class for parsing tabular excel sheets into DataFrame objects."}
{"text_id": 1005525, "text": "ExcelFile(path_or_buffer, engine=None, storage_options: 'StorageOptions' = None): Class for parsing tabular excel sheets into DataFrame objects."}
{"text_id": 1005526, "text": "ODFReader(filepath_or_buffer: 'FilePathOrBuffer', storage_options: 'StorageOptions' = None): Read tables out of OpenDocument formatted files."}
{"text_id": 1005527, "text": "ODFReader(filepath_or_buffer: 'FilePathOrBuffer', storage_options: 'StorageOptions' = None): Read tables out of OpenDocument formatted files."}
{"text_id": 1005528, "text": "get_sheet_data(self, sheet, convert_float: 'bool') -> 'list[list[Scalar]]': Parse an ODF Table into a list of lists."}
{"text_id": 1005529, "text": "close(self): close io if necessary."}
{"text_id": 1005530, "text": "close(self): synonym for save, to make it more file-like."}
{"text_id": 1005531, "text": "close(self): Close the PyTables file handle."}
{"text_id": 1005532, "text": "close(self): close io if necessary."}
{"text_id": 1005533, "text": "close(self): synonym for save, to make it more file-like."}
{"text_id": 1005534, "text": "close(self): Close the PyTables file handle."}
{"text_id": 1005535, "text": "parse(self, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, **kwds): Parse specified sheet(s) into a DataFrame."}
{"text_id": 1005536, "text": "parse(self, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, **kwds): Parse specified sheet(s) into a DataFrame."}
{"text_id": 1005537, "text": "parse(version: 'str') -> 'LegacyVersion | Version': Parse the given version string and return either a :class:`Version` object or a :class:`LegacyVersion` object depending on if the given version is a valid PEP 440 version or a legacy version."}
{"text_id": 1005538, "text": "ExcelWriter(path: 'FilePathOrBuffer | ExcelWriter', engine=None, date_format=None, datetime_format=None, mode: 'str' = 'w', storage_options: 'StorageOptions' = None, if_sheet_exists: 'str | None' = None, engine_kwargs: 'dict | None' = None, **kwargs): Class for writing DataFrame objects into excel sheets."}
{"text_id": 1005539, "text": "ExcelWriter(path: 'FilePathOrBuffer | ExcelWriter', engine=None, date_format=None, datetime_format=None, mode: 'str' = 'w', storage_options: 'StorageOptions' = None, if_sheet_exists: 'str | None' = None, engine_kwargs: 'dict | None' = None, **kwargs): Class for writing DataFrame objects into excel sheets."}
{"text_id": 1005540, "text": "ExcelWriter(path: 'FilePathOrBuffer | ExcelWriter', engine=None, date_format=None, datetime_format=None, mode: 'str' = 'w', storage_options: 'StorageOptions' = None, if_sheet_exists: 'str | None' = None, engine_kwargs: 'dict | None' = None, **kwargs): Class for writing DataFrame objects into excel sheets."}
{"text_id": 1005541, "text": "ExcelWriter(path: 'FilePathOrBuffer | ExcelWriter', engine=None, date_format=None, datetime_format=None, mode: 'str' = 'w', storage_options: 'StorageOptions' = None, if_sheet_exists: 'str | None' = None, engine_kwargs: 'dict | None' = None, **kwargs): Class for writing DataFrame objects into excel sheets."}
{"text_id": 1005542, "text": "ExcelWriter(path: 'FilePathOrBuffer | ExcelWriter', engine=None, date_format=None, datetime_format=None, mode: 'str' = 'w', storage_options: 'StorageOptions' = None, if_sheet_exists: 'str | None' = None, engine_kwargs: 'dict | None' = None, **kwargs): Class for writing DataFrame objects into excel sheets."}
{"text_id": 1005543, "text": "check_extension(ext: 'str'): checks that path's extension against the Writer's supported extensions."}
{"text_id": 1005544, "text": "check_extension(ext: 'str'): checks that path's extension against the Writer's supported extensions."}
{"text_id": 1005545, "text": "save(self): Save workbook to disk."}
{"text_id": 1005546, "text": "save(self): Save workbook to disk."}
{"text_id": 1005547, "text": "write_cells(self, cells, sheet_name=None, startrow=0, startcol=0, freeze_panes=None): Write given formatted cells into Excel an excel sheet."}
{"text_id": 1005548, "text": "write_cells(self, cells, sheet_name=None, startrow=0, startcol=0, freeze_panes=None): Write given formatted cells into Excel an excel sheet."}
{"text_id": 1005549, "text": "Flags(obj, *, allows_duplicate_labels): Flags that apply to pandas objects."}
{"text_id": 1005550, "text": "Flags(obj, *, allows_duplicate_labels): Flags that apply to pandas objects."}
{"text_id": 1005551, "text": "Flags(obj, *, allows_duplicate_labels): Flags that apply to pandas objects."}
{"text_id": 1005552, "text": "Flags(obj, *, allows_duplicate_labels): Flags that apply to pandas objects."}
{"text_id": 1005553, "text": "Flags(obj, *, allows_duplicate_labels): Flags that apply to pandas objects."}
{"text_id": 1005554, "text": "Flags(obj, *, allows_duplicate_labels): Flags that apply to pandas objects."}
{"text_id": 1005555, "text": "Float32Dtype(): An ExtensionDtype for float32 data."}
{"text_id": 1005556, "text": "Float32Dtype(): An ExtensionDtype for float32 data."}
{"text_id": 1005557, "text": "Float32Dtype(): An ExtensionDtype for float32 data."}
{"text_id": 1005558, "text": "Float32Dtype(): An ExtensionDtype for float32 data."}
{"text_id": 1005559, "text": "flatten(line): Flatten an arbitrarily nested sequence."}
{"text_id": 1005560, "text": "put(self, key: 'str', value: 'FrameOrSeries', format=None, index=True, append=False, complib=None, complevel: 'int | None' = None, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, data_columns: 'list[str] | None' = None, encoding=None, errors: 'str' = 'strict', track_times: 'bool' = True, dropna: 'bool' = False): Store object in HDFStore."}
{"text_id": 1005561, "text": "put(self, key: 'str', value: 'FrameOrSeries', format=None, index=True, append=False, complib=None, complevel: 'int | None' = None, min_itemsize: 'int | dict[str, int] | None' = None, nan_rep=None, data_columns: 'list[str] | None' = None, encoding=None, errors: 'str' = 'strict', track_times: 'bool' = True, dropna: 'bool' = False): Store object in HDFStore."}
{"text_id": 1005562, "text": "view(self, cls=None): this is defined as a copy with the same identity."}
{"text_id": 1005563, "text": "view(self, dtype: 'Dtype | None' = None) -> 'Series': Create a new view of the Series."}
{"text_id": 1005564, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005565, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005566, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005567, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005568, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005569, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005570, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005571, "text": "view(self, dtype: 'Dtype | None' = None) -> 'ArrayLike': Return a view on the array."}
{"text_id": 1005572, "text": "view(self, cls=None): this is defined as a copy with the same identity."}
{"text_id": 1005573, "text": "view(self, dtype: 'Dtype | None' = None) -> 'Series': Create a new view of the Series."}
{"text_id": 1005574, "text": "Float64Dtype(): An ExtensionDtype for float64 data."}
{"text_id": 1005575, "text": "Float64Dtype(): An ExtensionDtype for float64 data."}
{"text_id": 1005576, "text": "Float64Dtype(): An ExtensionDtype for float64 data."}
{"text_id": 1005577, "text": "Float64Dtype(): An ExtensionDtype for float64 data."}
{"text_id": 1005578, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005579, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005580, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005581, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005582, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005583, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005584, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005585, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005586, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005587, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005588, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005589, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005590, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005591, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005592, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005593, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005594, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005595, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005596, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005597, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005598, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005599, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005600, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005601, "text": "fromhex(string, /): Create a floating-point number from a hexadecimal string."}
{"text_id": 1005602, "text": "hex(self, /): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005603, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005604, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005605, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005606, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005607, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005608, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005609, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005610, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005611, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005612, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005613, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005614, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005615, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005616, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005617, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005618, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005619, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005620, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005621, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005622, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005623, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005624, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005625, "text": "hex(): Return a hexadecimal representation of a floating-point number."}
{"text_id": 1005626, "text": "Float64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005627, "text": "Float64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005628, "text": "Float64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005629, "text": "Float64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005630, "text": "Float64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005631, "text": "Grouper(*args, **kwargs): A Grouper allows the user to specify a groupby instruction for an object."}
{"text_id": 1005632, "text": "Grouper(*args, **kwargs): A Grouper allows the user to specify a groupby instruction for an object."}
{"text_id": 1005633, "text": "Grouper(*args, **kwargs): A Grouper allows the user to specify a groupby instruction for an object."}
{"text_id": 1005634, "text": "Grouper(*args, **kwargs): A Grouper allows the user to specify a groupby instruction for an object."}
{"text_id": 1005635, "text": "Grouper(*args, **kwargs): A Grouper allows the user to specify a groupby instruction for an object."}
{"text_id": 1005636, "text": "HDFStore(path, mode: 'str' = 'a', complevel: 'int | None' = None, complib=None, fletcher32: 'bool' = False, **kwargs): Dict-like IO interface for storing pandas objects in PyTables."}
{"text_id": 1005637, "text": "HDFStore(path, mode: 'str' = 'a', complevel: 'int | None' = None, complib=None, fletcher32: 'bool' = False, **kwargs): Dict-like IO interface for storing pandas objects in PyTables."}
{"text_id": 1005638, "text": "HDFStore(path, mode: 'str' = 'a', complevel: 'int | None' = None, complib=None, fletcher32: 'bool' = False, **kwargs): Dict-like IO interface for storing pandas objects in PyTables."}
{"text_id": 1005639, "text": "HDFStore(path, mode: 'str' = 'a', complevel: 'int | None' = None, complib=None, fletcher32: 'bool' = False, **kwargs): Dict-like IO interface for storing pandas objects in PyTables."}
{"text_id": 1005640, "text": "HDFStore(path, mode: 'str' = 'a', complevel: 'int | None' = None, complib=None, fletcher32: 'bool' = False, **kwargs): Dict-like IO interface for storing pandas objects in PyTables."}
{"text_id": 1005641, "text": "append_to_multiple(self, d: 'dict', value, selector, data_columns=None, axes=None, dropna=False, **kwargs): Append to multiple tables."}
{"text_id": 1005642, "text": "append_to_multiple(self, d: 'dict', value, selector, data_columns=None, axes=None, dropna=False, **kwargs): Append to multiple tables."}
{"text_id": 1005643, "text": "create_table_index(self, key: 'str', columns=None, optlevel: 'int | None' = None, kind: 'str | None' = None): Create a pytables index on the table."}
{"text_id": 1005644, "text": "create_table_index(self, key: 'str', columns=None, optlevel: 'int | None' = None, kind: 'str | None' = None): Create a pytables index on the table."}
{"text_id": 1005645, "text": "flush(self, fsync: 'bool' = False): Force all buffered modifications to be written to disk."}
{"text_id": 1005646, "text": "flush(self, fsync: 'bool' = False): Force all buffered modifications to be written to disk."}
{"text_id": 1005647, "text": "get_node(self, key: 'str') -> 'Node | None': return the node with the key or None if it does not exist."}
{"text_id": 1005648, "text": "get_node(self, key: 'str') -> 'Node | None': return the node with the key or None if it does not exist."}
{"text_id": 1005649, "text": "get_storer(self, key: 'str') -> 'GenericFixed | Table': return the storer object for a key, raise if not in the file."}
{"text_id": 1005650, "text": "get_storer(self, key: 'str') -> 'GenericFixed | Table': return the storer object for a key, raise if not in the file."}
{"text_id": 1005651, "text": "groups(self): Return a list of all the top-level nodes."}
{"text_id": 1005652, "text": "groups(self): Return a list of all the top-level nodes."}
{"text_id": 1005653, "text": "open(self, mode: 'str' = 'a', **kwargs): Open the file in the specified mode."}
{"text_id": 1005654, "text": "open(self, mode: 'str' = 'a', **kwargs): Open the file in the specified mode."}
{"text_id": 1005655, "text": "remove(self, key: 'str', where=None, start=None, stop=None): Remove pandas object partially by specifying the where condition."}
{"text_id": 1005656, "text": "remove(self, key: 'str', where=None, start=None, stop=None): Remove pandas object partially by specifying the where condition."}
{"text_id": 1005657, "text": "select(self, key: 'str', where=None, start=None, stop=None, columns=None, iterator=False, chunksize=None, auto_close: 'bool' = False): Retrieve pandas object stored in file, optionally based on where criteria."}
{"text_id": 1005658, "text": "select(self, key: 'str', where=None, start=None, stop=None, columns=None, iterator=False, chunksize=None, auto_close: 'bool' = False): Retrieve pandas object stored in file, optionally based on where criteria."}
{"text_id": 1005659, "text": "select_as_coordinates(self, key: 'str', where=None, start: 'int | None' = None, stop: 'int | None' = None): return the selection as an Index."}
{"text_id": 1005660, "text": "select_as_coordinates(self, key: 'str', where=None, start: 'int | None' = None, stop: 'int | None' = None): return the selection as an Index."}
{"text_id": 1005661, "text": "select_as_multiple(self, keys, where=None, selector=None, columns=None, start=None, stop=None, iterator=False, chunksize=None, auto_close: 'bool' = False): Retrieve pandas objects from multiple tables."}
{"text_id": 1005662, "text": "select_as_multiple(self, keys, where=None, selector=None, columns=None, start=None, stop=None, iterator=False, chunksize=None, auto_close: 'bool' = False): Retrieve pandas objects from multiple tables."}
{"text_id": 1005663, "text": "select_column(self, key: 'str', column: 'str', start: 'int | None' = None, stop: 'int | None' = None): return a single column from the table."}
{"text_id": 1005664, "text": "select_column(self, key: 'str', column: 'str', start: 'int | None' = None, stop: 'int | None' = None): return a single column from the table."}
{"text_id": 1005665, "text": "walk(self, where='/'): Walk the pytables group hierarchy for pandas objects."}
{"text_id": 1005666, "text": "walk(self, where='/'): Walk the pytables group hierarchy for pandas objects."}
{"text_id": 1005667, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005668, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005669, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005670, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005671, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005672, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005673, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005674, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005675, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005676, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005677, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005678, "text": "Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index': Immutable sequence used for indexing and alignment."}
{"text_id": 1005679, "text": "Int16Dtype(): An ExtensionDtype for int16 integer data."}
{"text_id": 1005680, "text": "Int16Dtype(): An ExtensionDtype for int16 integer data."}
{"text_id": 1005681, "text": "Int16Dtype(): An ExtensionDtype for int16 integer data."}
{"text_id": 1005682, "text": "Int16Dtype(): An ExtensionDtype for int16 integer data."}
{"text_id": 1005683, "text": "Int32Dtype(): An ExtensionDtype for int32 integer data."}
{"text_id": 1005684, "text": "Int32Dtype(): An ExtensionDtype for int32 integer data."}
{"text_id": 1005685, "text": "Int32Dtype(): An ExtensionDtype for int32 integer data."}
{"text_id": 1005686, "text": "Int32Dtype(): An ExtensionDtype for int32 integer data."}
{"text_id": 1005687, "text": "Int64Dtype(): An ExtensionDtype for int64 integer data."}
{"text_id": 1005688, "text": "Int64Dtype(): An ExtensionDtype for int64 integer data."}
{"text_id": 1005689, "text": "Int64Dtype(): An ExtensionDtype for int64 integer data."}
{"text_id": 1005690, "text": "Int64Dtype(): An ExtensionDtype for int64 integer data."}
{"text_id": 1005691, "text": "Int64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005692, "text": "Int64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005693, "text": "Int64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005694, "text": "Int64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005695, "text": "Int64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005696, "text": "Int64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005697, "text": "Int8Dtype(): An ExtensionDtype for int8 integer data."}
{"text_id": 1005698, "text": "Int8Dtype(): An ExtensionDtype for int8 integer data."}
{"text_id": 1005699, "text": "Int8Dtype(): An ExtensionDtype for int8 integer data."}
{"text_id": 1005700, "text": "Int8Dtype(): An ExtensionDtype for int8 integer data."}
{"text_id": 1005701, "text": "overlaps(self, *args, **kwargs): Check elementwise if an Interval overlaps the values in the IntervalArray."}
{"text_id": 1005702, "text": "overlaps(self, other): Check elementwise if an Interval overlaps the values in the IntervalArray."}
{"text_id": 1005703, "text": "overlaps(self, *args, **kwargs): Check elementwise if an Interval overlaps the values in the IntervalArray."}
{"text_id": 1005704, "text": "IntervalDtype(subtype=None, closed: 'str_type | None' = None): An ExtensionDtype for Interval data."}
{"text_id": 1005705, "text": "IntervalDtype(subtype=None, closed: 'str_type | None' = None): An ExtensionDtype for Interval data."}
{"text_id": 1005706, "text": "IntervalDtype(subtype=None, closed: 'str_type | None' = None): An ExtensionDtype for Interval data."}
{"text_id": 1005707, "text": "IntervalDtype(subtype=None, closed: 'str_type | None' = None): An ExtensionDtype for Interval data."}
{"text_id": 1005708, "text": "IntervalDtype(subtype=None, closed: 'str_type | None' = None): An ExtensionDtype for Interval data."}
{"text_id": 1005709, "text": "IntervalIndex(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, verify_integrity: 'bool' = True) -> 'IntervalIndex': Immutable index of intervals that are closed on the same side."}
{"text_id": 1005710, "text": "IntervalIndex(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, verify_integrity: 'bool' = True) -> 'IntervalIndex': Immutable index of intervals that are closed on the same side."}
{"text_id": 1005711, "text": "IntervalIndex(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, verify_integrity: 'bool' = True) -> 'IntervalIndex': Immutable index of intervals that are closed on the same side."}
{"text_id": 1005712, "text": "IntervalIndex(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, verify_integrity: 'bool' = True) -> 'IntervalIndex': Immutable index of intervals that are closed on the same side."}
{"text_id": 1005713, "text": "IntervalIndex(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, verify_integrity: 'bool' = True) -> 'IntervalIndex': Immutable index of intervals that are closed on the same side."}
{"text_id": 1005714, "text": "from_arrays(left, right, closed: 'str' = 'right', name: 'Hashable' = None, copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalIndex': Construct from two arrays defining the left and right bounds."}
{"text_id": 1005715, "text": "from_arrays(arrays, sortorder=None, names=<no_default>) -> 'MultiIndex': Convert arrays to MultiIndex."}
{"text_id": 1005716, "text": "from_arrays(left, right, closed='right', copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalArrayT': Construct from two arrays defining the left and right bounds."}
{"text_id": 1005717, "text": "from_arrays(left, right, closed: 'str' = 'right', name: 'Hashable' = None, copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalIndex': Construct from two arrays defining the left and right bounds."}
{"text_id": 1005718, "text": "from_arrays(arrays, sortorder=None, names=<no_default>) -> 'MultiIndex': Convert arrays to MultiIndex."}
{"text_id": 1005719, "text": "from_breaks(breaks, closed: 'str' = 'right', name: 'Hashable' = None, copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalIndex': Construct an IntervalIndex from an array of splits."}
{"text_id": 1005720, "text": "from_breaks(breaks, closed='right', copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalArrayT': Construct an IntervalArray from an array of splits."}
{"text_id": 1005721, "text": "from_breaks(breaks, closed: 'str' = 'right', name: 'Hashable' = None, copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalIndex': Construct an IntervalIndex from an array of splits."}
{"text_id": 1005722, "text": "from_tuples(data, closed: 'str' = 'right', name: 'Hashable' = None, copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalIndex': Construct an IntervalIndex from an array-like of tuples."}
{"text_id": 1005723, "text": "from_tuples(tuples: 'Iterable[tuple[Hashable, ...]]', sortorder: 'int | None' = None, names: 'Sequence[Hashable] | None' = None) -> 'MultiIndex': Convert list of tuples to MultiIndex."}
{"text_id": 1005724, "text": "from_tuples(data, closed='right', copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalArrayT': Construct an IntervalArray from an array-like of tuples."}
{"text_id": 1005725, "text": "from_tuples(data, closed: 'str' = 'right', name: 'Hashable' = None, copy: 'bool' = False, dtype: 'Dtype | None' = None) -> 'IntervalIndex': Construct an IntervalIndex from an array-like of tuples."}
{"text_id": 1005726, "text": "from_tuples(tuples: 'Iterable[tuple[Hashable, ...]]', sortorder: 'int | None' = None, names: 'Sequence[Hashable] | None' = None) -> 'MultiIndex': Convert list of tuples to MultiIndex."}
{"text_id": 1005727, "text": "set_closed(self, *args, **kwargs): Return an IntervalArray identical to the current one, but closed on the specified side."}
{"text_id": 1005728, "text": "set_closed(self: 'IntervalArrayT', closed) -> 'IntervalArrayT': Return an IntervalArray identical to the current one, but closed on the specified side."}
{"text_id": 1005729, "text": "set_closed(self, *args, **kwargs): Return an IntervalArray identical to the current one, but closed on the specified side."}
{"text_id": 1005730, "text": "to_tuples(self, *args, **kwargs): Return an ndarray of tuples of the form (left, right)."}
{"text_id": 1005731, "text": "to_tuples(self, na_tuple=True) -> 'np.ndarray': Return an ndarray of tuples of the form (left, right)."}
{"text_id": 1005732, "text": "to_tuples(self, *args, **kwargs): Return an ndarray of tuples of the form (left, right)."}
{"text_id": 1005733, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005734, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005735, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005736, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005737, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005738, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005739, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005740, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005741, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005742, "text": "MultiIndex(levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: 'bool' = True): A multi-level, or hierarchical, index object for pandas objects."}
{"text_id": 1005743, "text": "equal_levels(self, other: 'MultiIndex') -> 'bool': Return True if the levels of both MultiIndex objects are the same."}
{"text_id": 1005744, "text": "equal_levels(self, other: 'MultiIndex') -> 'bool': Return True if the levels of both MultiIndex objects are the same."}
{"text_id": 1005745, "text": "from_frame(df: 'DataFrame', sortorder=None, names=None) -> 'MultiIndex': Make a MultiIndex from a DataFrame."}
{"text_id": 1005746, "text": "from_frame(df: 'DataFrame', sortorder=None, names=None) -> 'MultiIndex': Make a MultiIndex from a DataFrame."}
{"text_id": 1005747, "text": "from_product(iterables, sortorder=None, names=<no_default>) -> 'MultiIndex': Make a MultiIndex from the cartesian product of multiple iterables."}
{"text_id": 1005748, "text": "from_product(iterables, sortorder=None, names=<no_default>) -> 'MultiIndex': Make a MultiIndex from the cartesian product of multiple iterables."}
{"text_id": 1005749, "text": "get_loc_level(self, key, level=0, drop_level: 'bool' = True): Get location and sliced index for requested label(s)/level(s)."}
{"text_id": 1005750, "text": "get_loc_level(self, key, level=0, drop_level: 'bool' = True): Get location and sliced index for requested label(s)/level(s)."}
{"text_id": 1005751, "text": "get_locs(self, seq): Get location for a sequence of labels."}
{"text_id": 1005752, "text": "get_locs(self, seq): Get location for a sequence of labels."}
{"text_id": 1005753, "text": "remove_unused_levels(self) -> 'MultiIndex': Create new MultiIndex from current that removes unused levels."}
{"text_id": 1005754, "text": "remove_unused_levels(self) -> 'MultiIndex': Create new MultiIndex from current that removes unused levels."}
{"text_id": 1005755, "text": "set_codes(self, codes, level=None, inplace=None, verify_integrity: 'bool' = True): Set new codes on MultiIndex."}
{"text_id": 1005756, "text": "set_codes(self, codes, level=None, inplace=None, verify_integrity: 'bool' = True): Set new codes on MultiIndex."}
{"text_id": 1005757, "text": "set_levels(self, levels, level=None, inplace=None, verify_integrity: 'bool' = True): Set new levels on MultiIndex."}
{"text_id": 1005758, "text": "set_levels(self, levels, level=None, inplace=None, verify_integrity: 'bool' = True): Set new levels on MultiIndex."}
{"text_id": 1005759, "text": "NamedAgg(column, aggfunc): NamedAgg(column, aggfunc)."}
{"text_id": 1005760, "text": "NamedAgg(column, aggfunc): NamedAgg(column, aggfunc)."}
{"text_id": 1005761, "text": "NamedAgg(column, aggfunc): NamedAgg(column, aggfunc)."}
{"text_id": 1005762, "text": "NamedAgg(column, aggfunc): NamedAgg(column, aggfunc)."}
{"text_id": 1005763, "text": "NamedAgg(column, aggfunc): NamedAgg(column, aggfunc)."}
{"text_id": 1005764, "text": "Period(value=None, freq=None, ordinal=None, year=None, month=None, quarter=None, day=None, hour=None, minute=None, second=None): Represents a period of time."}
{"text_id": 1005765, "text": "Period(value=None, freq=None, ordinal=None, year=None, month=None, quarter=None, day=None, hour=None, minute=None, second=None): Represents a period of time."}
{"text_id": 1005766, "text": "Period(value=None, freq=None, ordinal=None, year=None, month=None, quarter=None, day=None, hour=None, minute=None, second=None): Represents a period of time."}
{"text_id": 1005767, "text": "Period(value=None, freq=None, ordinal=None, year=None, month=None, quarter=None, day=None, hour=None, minute=None, second=None): Represents a period of time."}
{"text_id": 1005768, "text": "Period(value=None, freq=None, ordinal=None, year=None, month=None, quarter=None, day=None, hour=None, minute=None, second=None): Represents a period of time."}
{"text_id": 1005769, "text": "PeriodDtype(freq=None): An ExtensionDtype for Period data."}
{"text_id": 1005770, "text": "PeriodDtype(freq=None): An ExtensionDtype for Period data."}
{"text_id": 1005771, "text": "PeriodDtype(freq=None): An ExtensionDtype for Period data."}
{"text_id": 1005772, "text": "PeriodDtype(freq=None): An ExtensionDtype for Period data."}
{"text_id": 1005773, "text": "PeriodDtype(freq=None): An ExtensionDtype for Period data."}
{"text_id": 1005774, "text": "PeriodDtype(freq=None): An ExtensionDtype for Period data."}
{"text_id": 1005775, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005776, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005777, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005778, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005779, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005780, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005781, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005782, "text": "PeriodIndex(data=None, ordinal=None, freq=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None, **fields) -> 'PeriodIndex': Immutable ndarray holding ordinal values indicating regular periods in time."}
{"text_id": 1005783, "text": "RangeIndex(start=None, stop=None, step=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'RangeIndex': Immutable Index implementing a monotonic integer range."}
{"text_id": 1005784, "text": "RangeIndex(start=None, stop=None, step=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'RangeIndex': Immutable Index implementing a monotonic integer range."}
{"text_id": 1005785, "text": "RangeIndex(start=None, stop=None, step=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'RangeIndex': Immutable Index implementing a monotonic integer range."}
{"text_id": 1005786, "text": "RangeIndex(start=None, stop=None, step=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'RangeIndex': Immutable Index implementing a monotonic integer range."}
{"text_id": 1005787, "text": "RangeIndex(start=None, stop=None, step=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'RangeIndex': Immutable Index implementing a monotonic integer range."}
{"text_id": 1005788, "text": "RangeIndex(start=None, stop=None, step=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, name: 'Hashable' = None) -> 'RangeIndex': Immutable Index implementing a monotonic integer range."}
{"text_id": 1005789, "text": "from_range(data: 'range', name=None, dtype: 'Dtype | None' = None) -> 'RangeIndex': Create RangeIndex from a range object."}
{"text_id": 1005790, "text": "from_range(data: 'range', name=None, dtype: 'Dtype | None' = None) -> 'RangeIndex': Create RangeIndex from a range object."}
{"text_id": 1005791, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005792, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005793, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005794, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005795, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005796, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005797, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005798, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005799, "text": "Series(data=None, index=None, dtype: 'Dtype | None' = None, name=None, copy: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time series)."}
{"text_id": 1005800, "text": "autocorr(self, lag=1) -> 'float': Compute the lag-N autocorrelation."}
{"text_id": 1005801, "text": "autocorr(self, lag=1) -> 'float': Compute the lag-N autocorrelation."}
{"text_id": 1005802, "text": "between(self, left, right, inclusive='both') -> 'Series': Return boolean Series equivalent to left <= series <= right."}
{"text_id": 1005803, "text": "between(self, left, right, inclusive='both') -> 'Series': Return boolean Series equivalent to left <= series <= right."}
{"text_id": 1005804, "text": "divmod(self, other, level=None, fill_value=None, axis=0): Return Integer division and modulo of series and other, element-wise (binary operator `divmod`)."}
{"text_id": 1005805, "text": "divmod(self, other, level=None, fill_value=None, axis=0): Return Integer division and modulo of series and other, element-wise (binary operator `divmod`)."}
{"text_id": 1005806, "text": "to_pytimedelta(self) -> 'np.ndarray': Return an array of native `datetime."}
{"text_id": 1005807, "text": "to_pytimedelta(self, *args, **kwargs): Return Timedelta Array/Index as object ndarray of datetime."}
{"text_id": 1005808, "text": "to_pytimedelta(self) -> 'np.ndarray': Return Timedelta Array/Index as object ndarray of datetime."}
{"text_id": 1005809, "text": "to_pytimedelta(self, *args, **kwargs): Return Timedelta Array/Index as object ndarray of datetime."}
{"text_id": 1005810, "text": "rdivmod(self, other, level=None, fill_value=None, axis=0): Return Integer division and modulo of series and other, element-wise (binary operator `rdivmod`)."}
{"text_id": 1005811, "text": "rdivmod(self, other, level=None, fill_value=None, axis=0): Return Integer division and modulo of series and other, element-wise (binary operator `rdivmod`)."}
{"text_id": 1005812, "text": "from_coo(A, dense_index=False): Create a Series with sparse values from a scipy."}
{"text_id": 1005813, "text": "SparseDtype(dtype: 'Dtype' = <class 'numpy.float64'>, fill_value: 'Any' = None): Dtype for data stored in :class:`SparseArray`."}
{"text_id": 1005814, "text": "SparseDtype(dtype: 'Dtype' = <class 'numpy.float64'>, fill_value: 'Any' = None): Dtype for data stored in :class:`SparseArray`."}
{"text_id": 1005815, "text": "SparseDtype(dtype: 'Dtype' = <class 'numpy.float64'>, fill_value: 'Any' = None): Dtype for data stored in :class:`SparseArray`."}
{"text_id": 1005816, "text": "StringDtype(storage=None): Extension dtype for string data."}
{"text_id": 1005817, "text": "StringDtype(storage=None): Extension dtype for string data."}
{"text_id": 1005818, "text": "StringDtype(storage=None): Extension dtype for string data."}
{"text_id": 1005819, "text": "StringDtype(storage=None): Extension dtype for string data."}
{"text_id": 1005820, "text": "Timedelta(value=<object object at 0x7f7ee994dc80>, unit=None, **kwargs): Represents a duration, the difference between two dates or times."}
{"text_id": 1005821, "text": "Timedelta(value=<object object at 0x7f7ee994dc80>, unit=None, **kwargs): Represents a duration, the difference between two dates or times."}
{"text_id": 1005822, "text": "Timedelta(value=<object object at 0x7f7ee994dc80>, unit=None, **kwargs): Represents a duration, the difference between two dates or times."}
{"text_id": 1005823, "text": "Timedelta(value=<object object at 0x7f7ee994dc80>, unit=None, **kwargs): Represents a duration, the difference between two dates or times."}
{"text_id": 1005824, "text": "Timedelta(value=<object object at 0x7f7ee994dc80>, unit=None, **kwargs): Represents a duration, the difference between two dates or times."}
{"text_id": 1005825, "text": "TimedeltaIndex(data=None, unit=None, freq=<no_default>, closed=None, dtype=dtype('<m8[ns]'), copy=False, name=None): Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects."}
{"text_id": 1005826, "text": "TimedeltaIndex(data=None, unit=None, freq=<no_default>, closed=None, dtype=dtype('<m8[ns]'), copy=False, name=None): Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects."}
{"text_id": 1005827, "text": "TimedeltaIndex(data=None, unit=None, freq=<no_default>, closed=None, dtype=dtype('<m8[ns]'), copy=False, name=None): Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects."}
{"text_id": 1005828, "text": "TimedeltaIndex(data=None, unit=None, freq=<no_default>, closed=None, dtype=dtype('<m8[ns]'), copy=False, name=None): Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects."}
{"text_id": 1005829, "text": "TimedeltaIndex(data=None, unit=None, freq=<no_default>, closed=None, dtype=dtype('<m8[ns]'), copy=False, name=None): Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects."}
{"text_id": 1005830, "text": "TimedeltaIndex(data=None, unit=None, freq=<no_default>, closed=None, dtype=dtype('<m8[ns]'), copy=False, name=None): Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects."}
{"text_id": 1005831, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005832, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005833, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005834, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005835, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005836, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005837, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005838, "text": "Timestamp(ts_input=<object object at 0x7f7ee73f5310>, freq=None, tz=None, unit=None, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, nanosecond=None, tzinfo=None, *, fold=None): Pandas replacement for python datetime."}
{"text_id": 1005839, "text": "UInt16Dtype(): An ExtensionDtype for uint16 integer data."}
{"text_id": 1005840, "text": "UInt16Dtype(): An ExtensionDtype for uint16 integer data."}
{"text_id": 1005841, "text": "UInt16Dtype(): An ExtensionDtype for uint16 integer data."}
{"text_id": 1005842, "text": "UInt16Dtype(): An ExtensionDtype for uint16 integer data."}
{"text_id": 1005843, "text": "UInt32Dtype(): An ExtensionDtype for uint32 integer data."}
{"text_id": 1005844, "text": "UInt32Dtype(): An ExtensionDtype for uint32 integer data."}
{"text_id": 1005845, "text": "UInt32Dtype(): An ExtensionDtype for uint32 integer data."}
{"text_id": 1005846, "text": "UInt32Dtype(): An ExtensionDtype for uint32 integer data."}
{"text_id": 1005847, "text": "UInt64Dtype(): An ExtensionDtype for uint64 integer data."}
{"text_id": 1005848, "text": "UInt64Dtype(): An ExtensionDtype for uint64 integer data."}
{"text_id": 1005849, "text": "UInt64Dtype(): An ExtensionDtype for uint64 integer data."}
{"text_id": 1005850, "text": "UInt64Dtype(): An ExtensionDtype for uint64 integer data."}
{"text_id": 1005851, "text": "UInt64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005852, "text": "UInt64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005853, "text": "UInt64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005854, "text": "UInt64Index(data=None, dtype: 'Dtype | None' = None, copy=False, name=None): Immutable sequence used for indexing and alignment."}
{"text_id": 1005855, "text": "UInt8Dtype(): An ExtensionDtype for uint8 integer data."}
{"text_id": 1005856, "text": "UInt8Dtype(): An ExtensionDtype for uint8 integer data."}
{"text_id": 1005857, "text": "UInt8Dtype(): An ExtensionDtype for uint8 integer data."}
{"text_id": 1005858, "text": "UInt8Dtype(): An ExtensionDtype for uint8 integer data."}
{"text_id": 1005859, "text": "ExtensionArray(): Abstract base class for custom 1-D array types."}
{"text_id": 1005860, "text": "ExtensionArray(): Abstract base class for custom 1-D array types."}
{"text_id": 1005861, "text": "ExtensionArray(): Abstract base class for custom 1-D array types."}
{"text_id": 1005862, "text": "ExtensionArray(): Abstract base class for custom 1-D array types."}
{"text_id": 1005863, "text": "ExtensionArray(): Abstract base class for custom 1-D array types."}
{"text_id": 1005864, "text": "ExtensionArray(): Abstract base class for custom 1-D array types."}
{"text_id": 1005865, "text": "ExtensionDtype(): A custom data type, to be paired with an ExtensionArray."}
{"text_id": 1005866, "text": "ExtensionDtype(): A custom data type, to be paired with an ExtensionArray."}
{"text_id": 1005867, "text": "ExtensionDtype(): A custom data type, to be paired with an ExtensionArray."}
{"text_id": 1005868, "text": "ExtensionScalarOpsMixin(): A mixin for defining ops on an ExtensionArray."}
{"text_id": 1005869, "text": "ExtensionScalarOpsMixin(): A mixin for defining ops on an ExtensionArray."}
{"text_id": 1005870, "text": "register_dataframe_accessor(name): Register a custom accessor on DataFrame objects."}
{"text_id": 1005871, "text": "register_dataframe_accessor(name): Register a custom accessor on DataFrame objects."}
{"text_id": 1005872, "text": "register_extension_dtype(cls: 'type[E]') -> 'type[E]': Register an ExtensionType with pandas as class decorator."}
{"text_id": 1005873, "text": "register_index_accessor(name): Register a custom accessor on Index objects."}
{"text_id": 1005874, "text": "register_index_accessor(name): Register a custom accessor on Index objects."}
{"text_id": 1005875, "text": "register_series_accessor(name): Register a custom accessor on Series objects."}
{"text_id": 1005876, "text": "register_series_accessor(name): Register a custom accessor on Series objects."}
{"text_id": 1005877, "text": "BaseIndexer(index_array: 'np.ndarray | None' = None, window_size: 'int' = 0, **kwargs): Base class for window bounds calculations."}
{"text_id": 1005878, "text": "FixedForwardWindowIndexer(index_array: 'np.ndarray | None' = None, window_size: 'int' = 0, **kwargs): Creates window boundaries for fixed-length windows that include the current row."}
{"text_id": 1005879, "text": "VariableOffsetWindowIndexer(index_array: 'np.ndarray | None' = None, window_size: 'int' = 0, index=None, offset=None, **kwargs): Calculate window boundaries based on a non-fixed offset such as a BusinessDay."}
{"text_id": 1005880, "text": "check_array_indexer(array: 'AnyArrayLike', indexer: 'Any') -> 'Any': Check if `indexer` is a valid array indexer for `array`."}
{"text_id": 1005881, "text": "check_array_indexer(array: 'AnyArrayLike', indexer: 'Any') -> 'Any': Check if `indexer` is a valid array indexer for `array`."}
{"text_id": 1005882, "text": "check_array_indexer(array: 'AnyArrayLike', indexer: 'Any') -> 'Any': Check if `indexer` is a valid array indexer for `array`."}
{"text_id": 1005883, "text": "is_array_like(obj) -> bool: Check if the object is array-like."}
{"text_id": 1005884, "text": "is_array_like(obj) -> bool: Check if the object is array-like."}
{"text_id": 1005885, "text": "is_array_like(obj) -> bool: Check if the object is array-like."}
{"text_id": 1005886, "text": "is_array_like(obj) -> bool: Check if the object is array-like."}
{"text_id": 1005887, "text": "is_array_like(obj) -> bool: Check if the object is array-like."}
{"text_id": 1005888, "text": "is_array_like(obj) -> bool: Check if the object is array-like."}
{"text_id": 1005889, "text": "is_array_like(obj) -> bool: Check if the object is array-like."}
{"text_id": 1005890, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005891, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005892, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005893, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005894, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005895, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005896, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005897, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005898, "text": "is_bool_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a boolean dtype."}
{"text_id": 1005899, "text": "is_categorical_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Categorical dtype."}
{"text_id": 1005900, "text": "is_categorical_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Categorical dtype."}
{"text_id": 1005901, "text": "is_categorical_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Categorical dtype."}
{"text_id": 1005902, "text": "is_categorical_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Categorical dtype."}
{"text_id": 1005903, "text": "is_categorical_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Categorical dtype."}
{"text_id": 1005904, "text": "is_complex_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a complex dtype."}
{"text_id": 1005905, "text": "is_complex_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a complex dtype."}
{"text_id": 1005906, "text": "is_complex_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a complex dtype."}
{"text_id": 1005907, "text": "is_datetime64_any_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the datetime64 dtype."}
{"text_id": 1005908, "text": "is_datetime64_any_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the datetime64 dtype."}
{"text_id": 1005909, "text": "is_datetime64_any_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the datetime64 dtype."}
{"text_id": 1005910, "text": "is_datetime64_any_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the datetime64 dtype."}
{"text_id": 1005911, "text": "is_datetime64_any_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the datetime64 dtype."}
{"text_id": 1005912, "text": "is_datetime64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the datetime64 dtype."}
{"text_id": 1005913, "text": "is_datetime64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the datetime64 dtype."}
{"text_id": 1005914, "text": "is_datetime64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the datetime64 dtype."}
{"text_id": 1005915, "text": "is_datetime64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the datetime64 dtype."}
{"text_id": 1005916, "text": "is_datetime64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the datetime64 dtype."}
{"text_id": 1005917, "text": "is_datetime64_ns_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the datetime64[ns] dtype."}
{"text_id": 1005918, "text": "is_datetime64_ns_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the datetime64[ns] dtype."}
{"text_id": 1005919, "text": "is_datetime64tz_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of a DatetimeTZDtype dtype."}
{"text_id": 1005920, "text": "is_datetime64tz_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of a DatetimeTZDtype dtype."}
{"text_id": 1005921, "text": "is_datetime64tz_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of a DatetimeTZDtype dtype."}
{"text_id": 1005922, "text": "is_datetime64tz_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of a DatetimeTZDtype dtype."}
{"text_id": 1005923, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005924, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005925, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005926, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005927, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005928, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005929, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005930, "text": "is_dict_like(obj) -> bool: Check if the object is dict-like."}
{"text_id": 1005931, "text": "is_dtype_equal(source, target) -> 'bool': Check if two dtypes are equal."}
{"text_id": 1005932, "text": "is_dtype_equal(source, target) -> 'bool': Check if two dtypes are equal."}
{"text_id": 1005933, "text": "is_dtype_equal(source, target) -> 'bool': Check if two dtypes are equal."}
{"text_id": 1005934, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005935, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005936, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005937, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005938, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005939, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005940, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005941, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005942, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005943, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005944, "text": "is_extension_array_dtype(arr_or_dtype) -> 'bool': Check if an object is a pandas extension array type."}
{"text_id": 1005945, "text": "is_extension_type(arr) -> 'bool': Check whether an array-like is of a pandas extension class instance."}
{"text_id": 1005946, "text": "is_file_like(obj) -> bool: Check if the object is a file-like object."}
{"text_id": 1005947, "text": "is_file_like(obj) -> bool: Check if the object is a file-like object."}
{"text_id": 1005948, "text": "is_float_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a float dtype."}
{"text_id": 1005949, "text": "is_float_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a float dtype."}
{"text_id": 1005950, "text": "is_float_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a float dtype."}
{"text_id": 1005951, "text": "is_float_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a float dtype."}
{"text_id": 1005952, "text": "is_float_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a float dtype."}
{"text_id": 1005953, "text": "is_hashable(obj) -> bool: Return True if hash(obj) will succeed, False otherwise."}
{"text_id": 1005954, "text": "is_hashable(obj) -> bool: Return True if hash(obj) will succeed, False otherwise."}
{"text_id": 1005955, "text": "is_hashable(obj) -> bool: Return True if hash(obj) will succeed, False otherwise."}
{"text_id": 1005956, "text": "is_hashable(obj) -> bool: Return True if hash(obj) will succeed, False otherwise."}
{"text_id": 1005957, "text": "is_hashable(obj) -> bool: Return True if hash(obj) will succeed, False otherwise."}
{"text_id": 1005958, "text": "is_int64_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the int64 dtype."}
{"text_id": 1005959, "text": "is_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an integer dtype."}
{"text_id": 1005960, "text": "is_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an integer dtype."}
{"text_id": 1005961, "text": "is_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an integer dtype."}
{"text_id": 1005962, "text": "is_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an integer dtype."}
{"text_id": 1005963, "text": "is_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an integer dtype."}
{"text_id": 1005964, "text": "is_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an integer dtype."}
{"text_id": 1005965, "text": "is_interval_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Interval dtype."}
{"text_id": 1005966, "text": "is_named_tuple(obj) -> bool: Check if the object is a named tuple."}
{"text_id": 1005967, "text": "is_number(obj) -> bool: Check if the object is a number."}
{"text_id": 1005968, "text": "is_number(obj) -> bool: Check if the object is a number."}
{"text_id": 1005969, "text": "is_numeric_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a numeric dtype."}
{"text_id": 1005970, "text": "is_numeric_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a numeric dtype."}
{"text_id": 1005971, "text": "is_numeric_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a numeric dtype."}
{"text_id": 1005972, "text": "is_numeric_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a numeric dtype."}
{"text_id": 1005973, "text": "is_numeric_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a numeric dtype."}
{"text_id": 1005974, "text": "is_numeric_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a numeric dtype."}
{"text_id": 1005975, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005976, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005977, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005978, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005979, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005980, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005981, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005982, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005983, "text": "is_object_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the object dtype."}
{"text_id": 1005984, "text": "is_period_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Period dtype."}
{"text_id": 1005985, "text": "is_period_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the Period dtype."}
{"text_id": 1005986, "text": "is_re(obj) -> bool: Check if the object is a regex pattern instance."}
{"text_id": 1005987, "text": "is_re_compilable(obj) -> bool: Check if the object can be compiled into a regex pattern instance."}
{"text_id": 1005988, "text": "is_re_compilable(obj) -> bool: Check if the object can be compiled into a regex pattern instance."}
{"text_id": 1005989, "text": "is_signed_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of a signed integer dtype."}
{"text_id": 1005990, "text": "is_sparse(arr) -> 'bool': Check whether an array-like is a 1-D pandas sparse array."}
{"text_id": 1005991, "text": "is_string_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the string dtype."}
{"text_id": 1005992, "text": "is_string_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the string dtype."}
{"text_id": 1005993, "text": "is_timedelta64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the timedelta64 dtype."}
{"text_id": 1005994, "text": "is_timedelta64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the timedelta64 dtype."}
{"text_id": 1005995, "text": "is_timedelta64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the timedelta64 dtype."}
{"text_id": 1005996, "text": "is_timedelta64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the timedelta64 dtype."}
{"text_id": 1005997, "text": "is_timedelta64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the timedelta64 dtype."}
{"text_id": 1005998, "text": "is_timedelta64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the timedelta64 dtype."}
{"text_id": 1005999, "text": "is_timedelta64_dtype(arr_or_dtype) -> 'bool': Check whether an array-like or dtype is of the timedelta64 dtype."}
{"text_id": 1006000, "text": "is_timedelta64_ns_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the timedelta64[ns] dtype."}
{"text_id": 1006001, "text": "is_timedelta64_ns_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of the timedelta64[ns] dtype."}
{"text_id": 1006002, "text": "is_unsigned_integer_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an unsigned integer dtype."}
{"text_id": 1006003, "text": "pandas_dtype(dtype) -> 'DtypeObj': Convert input into a pandas only dtype object or a numpy dtype object."}
{"text_id": 1006004, "text": "pandas_dtype(dtype) -> 'DtypeObj': Convert input into a pandas only dtype object or a numpy dtype object."}
{"text_id": 1006005, "text": "pandas_dtype(dtype) -> 'DtypeObj': Convert input into a pandas only dtype object or a numpy dtype object."}
{"text_id": 1006006, "text": "pandas_dtype(dtype) -> 'DtypeObj': Convert input into a pandas only dtype object or a numpy dtype object."}
{"text_id": 1006007, "text": "pandas_dtype(dtype) -> 'DtypeObj': Convert input into a pandas only dtype object or a numpy dtype object."}
{"text_id": 1006008, "text": "pandas_dtype(dtype) -> 'DtypeObj': Convert input into a pandas only dtype object or a numpy dtype object."}
{"text_id": 1006009, "text": "union_categoricals(to_union, sort_categories: bool = False, ignore_order: bool = False): Combine list-like of Categorical-like, unioning categories."}
{"text_id": 1006010, "text": "ArrowStringArray(values): Extension array for string data in a ``pyarrow."}
{"text_id": 1006011, "text": "ArrowStringArray(values): Extension array for string data in a ``pyarrow."}
{"text_id": 1006012, "text": "ArrowStringArray(values): Extension array for string data in a ``pyarrow."}
{"text_id": 1006013, "text": "BooleanArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of boolean (True/False) data with missing values."}
{"text_id": 1006014, "text": "BooleanArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of boolean (True/False) data with missing values."}
{"text_id": 1006015, "text": "BooleanArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of boolean (True/False) data with missing values."}
{"text_id": 1006016, "text": "DatetimeArray(values, dtype=dtype('<M8[ns]'), freq=None, copy: 'bool' = False): Pandas ExtensionArray for tz-naive or tz-aware datetime data."}
{"text_id": 1006017, "text": "DatetimeArray(values, dtype=dtype('<M8[ns]'), freq=None, copy: 'bool' = False): Pandas ExtensionArray for tz-naive or tz-aware datetime data."}
{"text_id": 1006018, "text": "DatetimeArray(values, dtype=dtype('<M8[ns]'), freq=None, copy: 'bool' = False): Pandas ExtensionArray for tz-naive or tz-aware datetime data."}
{"text_id": 1006019, "text": "DatetimeArray(values, dtype=dtype('<M8[ns]'), freq=None, copy: 'bool' = False): Pandas ExtensionArray for tz-naive or tz-aware datetime data."}
{"text_id": 1006020, "text": "DatetimeArray(values, dtype=dtype('<M8[ns]'), freq=None, copy: 'bool' = False): Pandas ExtensionArray for tz-naive or tz-aware datetime data."}
{"text_id": 1006021, "text": "DatetimeArray(values, dtype=dtype('<M8[ns]'), freq=None, copy: 'bool' = False): Pandas ExtensionArray for tz-naive or tz-aware datetime data."}
{"text_id": 1006022, "text": "FloatingArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of floating (optional missing) values."}
{"text_id": 1006023, "text": "FloatingArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of floating (optional missing) values."}
{"text_id": 1006024, "text": "FloatingArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of floating (optional missing) values."}
{"text_id": 1006025, "text": "IntegerArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of integer (optional missing) values."}
{"text_id": 1006026, "text": "IntegerArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of integer (optional missing) values."}
{"text_id": 1006027, "text": "IntegerArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Array of integer (optional missing) values."}
{"text_id": 1006028, "text": "IntervalArray(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, verify_integrity: 'bool' = True): Pandas array for interval data that are closed on the same side."}
{"text_id": 1006029, "text": "IntervalArray(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, verify_integrity: 'bool' = True): Pandas array for interval data that are closed on the same side."}
{"text_id": 1006030, "text": "IntervalArray(data, closed=None, dtype: 'Dtype | None' = None, copy: 'bool' = False, verify_integrity: 'bool' = True): Pandas array for interval data that are closed on the same side."}
{"text_id": 1006031, "text": "PandasArray(values: 'np.ndarray | PandasArray', copy: 'bool' = False): A pandas ExtensionArray for NumPy data."}
{"text_id": 1006032, "text": "PandasArray(values: 'np.ndarray | PandasArray', copy: 'bool' = False): A pandas ExtensionArray for NumPy data."}
{"text_id": 1006033, "text": "PandasArray(values: 'np.ndarray | PandasArray', copy: 'bool' = False): A pandas ExtensionArray for NumPy data."}
{"text_id": 1006034, "text": "PeriodArray(values, dtype: 'Dtype | None' = None, freq=None, copy: 'bool' = False): Pandas ExtensionArray for storing Period data."}
{"text_id": 1006035, "text": "PeriodArray(values, dtype: 'Dtype | None' = None, freq=None, copy: 'bool' = False): Pandas ExtensionArray for storing Period data."}
{"text_id": 1006036, "text": "PeriodArray(values, dtype: 'Dtype | None' = None, freq=None, copy: 'bool' = False): Pandas ExtensionArray for storing Period data."}
{"text_id": 1006037, "text": "PeriodArray(values, dtype: 'Dtype | None' = None, freq=None, copy: 'bool' = False): Pandas ExtensionArray for storing Period data."}
{"text_id": 1006038, "text": "PeriodArray(values, dtype: 'Dtype | None' = None, freq=None, copy: 'bool' = False): Pandas ExtensionArray for storing Period data."}
{"text_id": 1006039, "text": "SparseArray(data, sparse_index=None, index=None, fill_value=None, kind='integer', dtype: 'Dtype | None' = None, copy=False): An ExtensionArray for storing sparse data."}
{"text_id": 1006040, "text": "SparseArray(data, sparse_index=None, index=None, fill_value=None, kind='integer', dtype: 'Dtype | None' = None, copy=False): An ExtensionArray for storing sparse data."}
{"text_id": 1006041, "text": "SparseArray(data, sparse_index=None, index=None, fill_value=None, kind='integer', dtype: 'Dtype | None' = None, copy=False): An ExtensionArray for storing sparse data."}
{"text_id": 1006042, "text": "StringArray(values, copy=False): Extension array for string data."}
{"text_id": 1006043, "text": "StringArray(values, copy=False): Extension array for string data."}
{"text_id": 1006044, "text": "StringArray(values, copy=False): Extension array for string data."}
{"text_id": 1006045, "text": "TimedeltaArray(values, dtype=dtype('<m8[ns]'), freq=<no_default>, copy: 'bool' = False): Pandas ExtensionArray for timedelta data."}
{"text_id": 1006046, "text": "TimedeltaArray(values, dtype=dtype('<m8[ns]'), freq=<no_default>, copy: 'bool' = False): Pandas ExtensionArray for timedelta data."}
{"text_id": 1006047, "text": "TimedeltaArray(values, dtype=dtype('<m8[ns]'), freq=<no_default>, copy: 'bool' = False): Pandas ExtensionArray for timedelta data."}
{"text_id": 1006048, "text": "TimedeltaArray(values, dtype=dtype('<m8[ns]'), freq=<no_default>, copy: 'bool' = False): Pandas ExtensionArray for timedelta data."}
{"text_id": 1006049, "text": "TimedeltaArray(values, dtype=dtype('<m8[ns]'), freq=<no_default>, copy: 'bool' = False): Pandas ExtensionArray for timedelta data."}
{"text_id": 1006050, "text": "bdate_range(start=None, end=None, periods: 'int | None' = None, freq='B', tz=None, normalize: 'bool' = True, name: 'Hashable' = None, weekmask=None, holidays=None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex, with business day as the default frequency."}
{"text_id": 1006051, "text": "bdate_range(start=None, end=None, periods: 'int | None' = None, freq='B', tz=None, normalize: 'bool' = True, name: 'Hashable' = None, weekmask=None, holidays=None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex, with business day as the default frequency."}
{"text_id": 1006052, "text": "bdate_range(start=None, end=None, periods: 'int | None' = None, freq='B', tz=None, normalize: 'bool' = True, name: 'Hashable' = None, weekmask=None, holidays=None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex, with business day as the default frequency."}
{"text_id": 1006053, "text": "bdate_range(start=None, end=None, periods: 'int | None' = None, freq='B', tz=None, normalize: 'bool' = True, name: 'Hashable' = None, weekmask=None, holidays=None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex, with business day as the default frequency."}
{"text_id": 1006054, "text": "ChainMap(*args, **kwargs): The central part of internal API."}
{"text_id": 1006055, "text": "DeepChainMap(*args, **kwds): Variant of ChainMap that allows direct updates to inner scopes."}
{"text_id": 1006056, "text": "MutableMapping(*args, **kwargs): The central part of internal API."}
{"text_id": 1006057, "text": "TypeVar(name, *constraints, bound=None, covariant=False, contravariant=False): Type variable."}
{"text_id": 1006058, "text": "TypeVar(name, *constraints, bound=None, covariant=False, contravariant=False): Type variable."}
{"text_id": 1006059, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006060, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006061, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006062, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006063, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006064, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006065, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006066, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006067, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006068, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006069, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006070, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006071, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006072, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006073, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006074, "text": "cast(typ, val): Cast a value to a type."}
{"text_id": 1006075, "text": "get_lzma_file(lzma): Importing the `LZMAFile` class from the `lzma` module."}
{"text_id": 1006076, "text": "get_lzma_file(lzma): Importing the `LZMAFile` class from the `lzma` module."}
{"text_id": 1006077, "text": "get_lzma_file(lzma): Importing the `LZMAFile` class from the `lzma` module."}
{"text_id": 1006078, "text": "import_lzma(): Importing the `lzma` module."}
{"text_id": 1006079, "text": "import_lzma(): Importing the `lzma` module."}
{"text_id": 1006080, "text": "import_lzma(): Importing the `lzma` module."}
{"text_id": 1006081, "text": "is_platform_arm() -> bool: Checking if he running platform use ARM architecture."}
{"text_id": 1006082, "text": "is_platform_arm() -> bool: Checking if he running platform use ARM architecture."}
{"text_id": 1006083, "text": "is_platform_linux() -> bool: Checking if the running platform is linux."}
{"text_id": 1006084, "text": "is_platform_linux() -> bool: Checking if the running platform is linux."}
{"text_id": 1006085, "text": "is_platform_little_endian() -> bool: Checking if the running platform is little endian."}
{"text_id": 1006086, "text": "is_platform_little_endian() -> bool: Checking if the running platform is little endian."}
{"text_id": 1006087, "text": "is_platform_mac() -> bool: Checking if the running platform is mac."}
{"text_id": 1006088, "text": "is_platform_mac() -> bool: Checking if the running platform is mac."}
{"text_id": 1006089, "text": "is_platform_windows() -> bool: Checking if the running platform is windows."}
{"text_id": 1006090, "text": "is_platform_windows() -> bool: Checking if the running platform is windows."}
{"text_id": 1006091, "text": "np_array_datetime64_compat(arr, dtype='M8[ns]'): provide compat for construction of an array of strings to a np."}
{"text_id": 1006092, "text": "np_array_datetime64_compat(arr, dtype='M8[ns]'): provide compat for construction of an array of strings to a np."}
{"text_id": 1006093, "text": "np_array_datetime64_compat(arr, dtype='M8[ns]'): provide compat for construction of an array of strings to a np."}
{"text_id": 1006094, "text": "np_datetime64_compat(tstring: str, unit: str = 'ns'): provide compat for construction of strings to numpy datetime64's with tz-changes in 1."}
{"text_id": 1006095, "text": "np_datetime64_compat(tstring: str, unit: str = 'ns'): provide compat for construction of strings to numpy datetime64's with tz-changes in 1."}
{"text_id": 1006096, "text": "np_datetime64_compat(tstring: str, unit: str = 'ns'): provide compat for construction of strings to numpy datetime64's with tz-changes in 1."}
{"text_id": 1006097, "text": "BlockManager(blocks: 'Sequence[Block]', axes: 'Sequence[Index]', verify_integrity: 'bool' = True): BaseBlockManager that holds 2D blocks."}
{"text_id": 1006098, "text": "BlockManager(blocks: 'Sequence[Block]', axes: 'Sequence[Index]', verify_integrity: 'bool' = True): BaseBlockManager that holds 2D blocks."}
{"text_id": 1006099, "text": "BlockManager(blocks: 'Sequence[Block]', axes: 'Sequence[Index]', verify_integrity: 'bool' = True): BaseBlockManager that holds 2D blocks."}
{"text_id": 1006100, "text": "BlockManager(blocks: 'Sequence[Block]', axes: 'Sequence[Index]', verify_integrity: 'bool' = True): BaseBlockManager that holds 2D blocks."}
{"text_id": 1006101, "text": "BlockManager(blocks: 'Sequence[Block]', axes: 'Sequence[Index]', verify_integrity: 'bool' = True): BaseBlockManager that holds 2D blocks."}
{"text_id": 1006102, "text": "load(fh, encoding: 'str | None' = None, is_verbose: 'bool' = False): Load a pickle, with a provided encoding,."}
{"text_id": 1006103, "text": "loads(bytes_object: 'bytes', *, fix_imports: 'bool' = True, encoding: 'str' = 'ASCII', errors: 'str' = 'strict'): Analogous to pickle."}
{"text_id": 1006104, "text": "patch_pickle(): Temporarily patch pickle to use our unpickler."}
{"text_id": 1006105, "text": "patch_pickle(): Temporarily patch pickle to use our unpickler."}
{"text_id": 1006106, "text": "platform(aliased=0, terse=0): Returns a single string identifying the underlying platform with as much useful information as possible (but no more :)."}
{"text_id": 1006107, "text": "architecture(executable='/home/v-dazan/miniconda3/envs/codex/bin/python', bits='', linkage=''): Queries the given executable (defaults to the Python interpreter binary) for various architecture information."}
{"text_id": 1006108, "text": "java_ver(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', '')): Version interface for Jython."}
{"text_id": 1006109, "text": "libc_ver(executable=None, lib='', version='', chunksize=16384): Tries to determine the libc version that the file executable (which defaults to the Python interpreter) is linked against."}
{"text_id": 1006110, "text": "mac_ver(release='', versioninfo=('', '', ''), machine=''): Get macOS version information and return it as tuple (release, versioninfo, machine) with versioninfo being a tuple (version, dev_stage, non_release_version)."}
{"text_id": 1006111, "text": "machine(): Returns the machine type, e."}
{"text_id": 1006112, "text": "node(): Returns the computer's network name (which may not be fully qualified) An empty string is returned if the value cannot be determined."}
{"text_id": 1006113, "text": "processor(): Returns the (true) processor name, e."}
{"text_id": 1006114, "text": "python_branch(): Returns a string identifying the Python implementation branch."}
{"text_id": 1006115, "text": "python_build(): Returns a tuple (buildno, builddate) stating the Python build number and date as strings."}
{"text_id": 1006116, "text": "python_compiler(): Returns a string identifying the compiler used for compiling Python."}
{"text_id": 1006117, "text": "python_implementation(): Returns a string identifying the Python implementation."}
{"text_id": 1006118, "text": "python_revision(): Returns a string identifying the Python implementation revision."}
{"text_id": 1006119, "text": "python_version(): Returns the Python version as string 'major."}
{"text_id": 1006120, "text": "python_version_tuple(): Returns the Python version as tuple (major, minor, patchlevel) of strings."}
{"text_id": 1006121, "text": "system(): Returns the system/OS name, e."}
{"text_id": 1006122, "text": "system_alias(system, release, version): Returns (system, release, version) aliased to common marketing names used for some systems."}
{"text_id": 1006123, "text": "uname(): Fairly portable uname interface."}
{"text_id": 1006124, "text": "uname_result(system, node, release, version, machine, processor): uname_result(system, node, release, version, machine, processor)."}
{"text_id": 1006125, "text": "version(): Returns the system's release version, e."}
{"text_id": 1006126, "text": "set_function_name(f: ~F, name: str, cls) -> ~F: Bind the name/qualname attributes of the function."}
{"text_id": 1006127, "text": "set_function_name(f: ~F, name: str, cls) -> ~F: Bind the name/qualname attributes of the function."}
{"text_id": 1006128, "text": "addaudithook(hook): Adds a new audit hook callback."}
{"text_id": 1006129, "text": "call_tracing(func, args, /): Call func(*args), while tracing is enabled."}
{"text_id": 1006130, "text": "callstats(): Return a tuple of function call statistics."}
{"text_id": 1006131, "text": "displayhook(object, /): Print an object to sys."}
{"text_id": 1006132, "text": "exc_info(): Return current exception information: (type, value, traceback)."}
{"text_id": 1006133, "text": "excepthook(exctype, value, traceback, /): Handle an exception by displaying it with a traceback on sys."}
{"text_id": 1006134, "text": "exit(status=None, /): Exit the interpreter by raising SystemExit(status)."}
{"text_id": 1006135, "text": "get_asyncgen_hooks(): Return the installed asynchronous generators hooks."}
{"text_id": 1006136, "text": "get_coroutine_origin_tracking_depth(): Check status of origin tracking for coroutine objects in this thread."}
{"text_id": 1006137, "text": "getallocatedblocks(): Return the number of memory blocks currently allocated."}
{"text_id": 1006138, "text": "getcheckinterval(): Return the current check interval; see sys."}
{"text_id": 1006139, "text": "getdefaultencoding(): Return the current default encoding used by the Unicode implementation."}
{"text_id": 1006140, "text": "getdlopenflags(): Return the current value of the flags that are used for dlopen calls."}
{"text_id": 1006141, "text": "getfilesystemencodeerrors(): Return the error mode used Unicode to OS filename conversion."}
{"text_id": 1006142, "text": "getfilesystemencoding(): Return the encoding used to convert Unicode filenames to OS filenames."}
{"text_id": 1006143, "text": "getprofile(): Return the profiling function set with sys."}
{"text_id": 1006144, "text": "getrecursionlimit(): Return the current value of the recursion limit."}
{"text_id": 1006145, "text": "getrefcount(object, /): Return the reference count of object."}
{"text_id": 1006146, "text": "getswitchinterval(): Return the current thread switch interval; see sys."}
{"text_id": 1006147, "text": "gettrace(): Return the global debug tracing function set with sys."}
{"text_id": 1006148, "text": "intern(string, /): ``Intern'' the given string."}
{"text_id": 1006149, "text": "is_finalizing(): Return True if Python is exiting."}
{"text_id": 1006150, "text": "set_coroutine_origin_tracking_depth(depth): Enable or disable origin tracking for coroutine objects in this thread."}
{"text_id": 1006151, "text": "setcheckinterval(n, /): Set the async event check interval to n instructions."}
{"text_id": 1006152, "text": "setdlopenflags(flags, /): Set the flags used by the interpreter for dlopen calls."}
{"text_id": 1006153, "text": "setrecursionlimit(limit, /): Set the maximum depth of the Python interpreter stack to n."}
{"text_id": 1006154, "text": "setswitchinterval(interval, /): Set the ideal thread switching delay inside the Python interpreter."}
{"text_id": 1006155, "text": "unraisablehook(unraisable, /): Handle an unraisable exception."}
{"text_id": 1006156, "text": "catch_warnings(*, record=False, module=None): A context manager that copies and restores the warnings filter upon exiting the context."}
{"text_id": 1006157, "text": "catch_warnings(*, record=False, module=None): A context manager that copies and restores the warnings filter upon exiting the context."}
{"text_id": 1006158, "text": "filterwarnings(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False): Insert an entry into the list of warnings filters (at the front)."}
{"text_id": 1006159, "text": "formatwarning(message, category, filename, lineno, line=None): Function to format a warning the standard way."}
{"text_id": 1006160, "text": "resetwarnings(): Clear the list of warning filters, so that no filters are active."}
{"text_id": 1006161, "text": "showwarning(message, category, filename, lineno, file=None, line=None): Hook to write a warning to a file; replace if you like."}
{"text_id": 1006162, "text": "simplefilter(action, category=<class 'Warning'>, lineno=0, append=False): Insert a simple entry into the list of warnings filters (at the front)."}
{"text_id": 1006163, "text": "warn(message, category=None, stacklevel=1, source=None): Issue a warning, or maybe ignore it or raise an exception."}
{"text_id": 1006164, "text": "warn(message, category=None, stacklevel=1, source=None): Issue a warning, or maybe ignore it or raise an exception."}
{"text_id": 1006165, "text": "concat(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool' = True) -> 'FrameOrSeriesUnion': Concatenate pandas objects along a particular axis with optional set logic along the other axes."}
{"text_id": 1006166, "text": "concat(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool' = True) -> 'FrameOrSeriesUnion': Concatenate pandas objects along a particular axis with optional set logic along the other axes."}
{"text_id": 1006167, "text": "concat(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool' = True) -> 'FrameOrSeriesUnion': Concatenate pandas objects along a particular axis with optional set logic along the other axes."}
{"text_id": 1006168, "text": "concat(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool' = True) -> 'FrameOrSeriesUnion': Concatenate pandas objects along a particular axis with optional set logic along the other axes."}
{"text_id": 1006169, "text": "concat(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool' = True) -> 'FrameOrSeriesUnion': Concatenate pandas objects along a particular axis with optional set logic along the other axes."}
{"text_id": 1006170, "text": "concat(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool' = True) -> 'FrameOrSeriesUnion': Concatenate pandas objects along a particular axis with optional set logic along the other axes."}
{"text_id": 1006171, "text": "concat(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool' = True) -> 'FrameOrSeriesUnion': Concatenate pandas objects along a particular axis with optional set logic along the other axes."}
{"text_id": 1006172, "text": "CachedAccessor(name: 'str', accessor) -> 'None': Custom property-like object."}
{"text_id": 1006173, "text": "CachedAccessor(name: 'str', accessor) -> 'None': Custom property-like object."}
{"text_id": 1006174, "text": "CachedAccessor(name: 'str', accessor) -> 'None': Custom property-like object."}
{"text_id": 1006175, "text": "PandasDelegate(): Abstract base class for delegating methods/properties."}
{"text_id": 1006176, "text": "delegate_names(delegate, accessors, typ: 'str', overwrite: 'bool' = False): Add delegated names to a class using a class decorator."}
{"text_id": 1006177, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006178, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006179, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006180, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006181, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006182, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006183, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006184, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006185, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006186, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006187, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006188, "text": "doc(*docstrings: 'str | Callable', **params) -> 'Callable[[F], F]': A decorator take docstring templates, concatenate them and perform string substitution on it."}
{"text_id": 1006189, "text": "AggFuncType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006190, "text": "AggFuncType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006191, "text": "AggFuncType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006192, "text": "AggFuncType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006193, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006194, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006195, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006196, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006197, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006198, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006199, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006200, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006201, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006202, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006203, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006204, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006205, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006206, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006207, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006208, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006209, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006210, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006211, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006212, "text": "Any(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006213, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006214, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006215, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006216, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006217, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006218, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006219, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006220, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006221, "text": "Callable(*args, **kwargs): Callable type; Callable[[int], str] is a function of (int) -> str."}
{"text_id": 1006222, "text": "DefaultDict(*args, **kwargs): The central part of internal API."}
{"text_id": 1006223, "text": "DefaultDict(*args, **kwargs): The central part of internal API."}
{"text_id": 1006224, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006225, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006226, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006227, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006228, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006229, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006230, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006231, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006232, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006233, "text": "Hashable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006234, "text": "Iterable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006235, "text": "Iterable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006236, "text": "Iterable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006237, "text": "Iterable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006238, "text": "Iterable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006239, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006240, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006241, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006242, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006243, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006244, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006245, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006246, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006247, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006248, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006249, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006250, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006251, "text": "Sequence(*args, **kwargs): The central part of internal API."}
{"text_id": 1006252, "text": "is_multi_agg_with_relabel(**kwargs) -> 'bool': Check whether kwargs passed to."}
{"text_id": 1006253, "text": "maybe_mangle_lambdas(agg_spec: 'Any') -> 'Any': Make new lambdas with unique names."}
{"text_id": 1006254, "text": "normalize_keyword_aggregation(kwargs: 'dict') -> 'tuple[dict, list[str], list[int]]': Normalize user-provided \"named aggregation\" kwargs."}
{"text_id": 1006255, "text": "reconstruct_func(func: 'AggFuncType | None', **kwargs) -> 'tuple[bool, AggFuncType | None, list[str] | None, list[int] | None]': This is the internal function to reconstruct func given if there is relabeling or not and also normalize the keyword to get new order of columns."}
{"text_id": 1006256, "text": "reconstruct_func(func: 'AggFuncType | None', **kwargs) -> 'tuple[bool, AggFuncType | None, list[str] | None, list[int] | None]': This is the internal function to reconstruct func given if there is relabeling or not and also normalize the keyword to get new order of columns."}
{"text_id": 1006257, "text": "relabel_result(result: 'FrameOrSeries', func: 'dict[str, list[Callable | str]]', columns: 'Iterable[Hashable]', order: 'Iterable[int]') -> 'dict[Hashable, Series]': Internal function to reorder result if relabelling is True for dataframe."}
{"text_id": 1006258, "text": "relabel_result(result: 'FrameOrSeries', func: 'dict[str, list[Callable | str]]', columns: 'Iterable[Hashable]', order: 'Iterable[int]') -> 'dict[Hashable, Series]': Internal function to reorder result if relabelling is True for dataframe."}
{"text_id": 1006259, "text": "validate_func_kwargs(kwargs: 'dict') -> 'tuple[list[str], list[str | Callable[..., Any]]]': Validates types of user-provided \"named aggregation\" kwargs."}
{"text_id": 1006260, "text": "AnyArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006261, "text": "AnyArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006262, "text": "AnyArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006263, "text": "AnyArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006264, "text": "AnyArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006265, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006266, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006267, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006268, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006269, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006270, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006271, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006272, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006273, "text": "ArrayLike(*args, **kwargs): The central part of internal API."}
{"text_id": 1006274, "text": "DtypeObj(*args, **kwargs): The central part of internal API."}
{"text_id": 1006275, "text": "DtypeObj(*args, **kwargs): The central part of internal API."}
{"text_id": 1006276, "text": "DtypeObj(*args, **kwargs): The central part of internal API."}
{"text_id": 1006277, "text": "DtypeObj(*args, **kwargs): The central part of internal API."}
{"text_id": 1006278, "text": "DtypeObj(*args, **kwargs): The central part of internal API."}
{"text_id": 1006279, "text": "DtypeObj(*args, **kwargs): The central part of internal API."}
{"text_id": 1006280, "text": "FrameOrSeriesUnion(*args, **kwargs): The central part of internal API."}
{"text_id": 1006281, "text": "FrameOrSeriesUnion(*args, **kwargs): The central part of internal API."}
{"text_id": 1006282, "text": "FrameOrSeriesUnion(*args, **kwargs): The central part of internal API."}
{"text_id": 1006283, "text": "FrameOrSeriesUnion(*args, **kwargs): The central part of internal API."}
{"text_id": 1006284, "text": "FrameOrSeriesUnion(*args, **kwargs): The central part of internal API."}
{"text_id": 1006285, "text": "FrameOrSeriesUnion(*args, **kwargs): The central part of internal API."}
{"text_id": 1006286, "text": "PandasDtype(dtype: 'NpDtype | PandasDtype | None'): A Pandas ExtensionDtype for NumPy dtypes."}
{"text_id": 1006287, "text": "Scalar(*args, **kwargs): The central part of internal API."}
{"text_id": 1006288, "text": "Scalar(*args, **kwargs): The central part of internal API."}
{"text_id": 1006289, "text": "Scalar(*args, **kwargs): The central part of internal API."}
{"text_id": 1006290, "text": "Scalar(*args, **kwargs): The central part of internal API."}
{"text_id": 1006291, "text": "SelectNFrame(obj, n: 'int', keep: 'str', columns): Implement n largest/smallest for DataFrame."}
{"text_id": 1006292, "text": "SelectNSeries(obj, n: 'int', keep: 'str'): Implement n largest/smallest for Series."}
{"text_id": 1006293, "text": "Union(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006294, "text": "Union(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006295, "text": "Union(*args, **kwds): Internal indicator of special typing constructs."}
{"text_id": 1006296, "text": "checked_add_with_arr(arr: 'np.ndarray', b, arr_mask: 'np.ndarray | None' = None, b_mask: 'np.ndarray | None' = None) -> 'np.ndarray': Perform array addition that checks for underflow and overflow."}
{"text_id": 1006297, "text": "construct_1d_object_array_from_listlike(values: 'Sized') -> 'np.ndarray': Transform any list-like object in a 1-dimensional numpy array of object dtype."}
{"text_id": 1006298, "text": "construct_1d_object_array_from_listlike(values: 'Sized') -> 'np.ndarray': Transform any list-like object in a 1-dimensional numpy array of object dtype."}
{"text_id": 1006299, "text": "construct_1d_object_array_from_listlike(values: 'Sized') -> 'np.ndarray': Transform any list-like object in a 1-dimensional numpy array of object dtype."}
{"text_id": 1006300, "text": "dedent(text): Remove any common leading whitespace from every line in `text`."}
{"text_id": 1006301, "text": "dedent(text): Remove any common leading whitespace from every line in `text`."}
{"text_id": 1006302, "text": "dedent(text): Remove any common leading whitespace from every line in `text`."}
{"text_id": 1006303, "text": "dedent(text): Remove any common leading whitespace from every line in `text`."}
{"text_id": 1006304, "text": "ensure_wrapped_if_datetimelike(arr): Wrap datetime64 and timedelta64 ndarrays in DatetimeArray/TimedeltaArray."}
{"text_id": 1006305, "text": "ensure_wrapped_if_datetimelike(arr): Wrap datetime64 and timedelta64 ndarrays in DatetimeArray/TimedeltaArray."}
{"text_id": 1006306, "text": "ensure_wrapped_if_datetimelike(arr): Wrap datetime64 and timedelta64 ndarrays in DatetimeArray/TimedeltaArray."}
{"text_id": 1006307, "text": "ensure_wrapped_if_datetimelike(arr): Wrap datetime64 and timedelta64 ndarrays in DatetimeArray/TimedeltaArray."}
{"text_id": 1006308, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006309, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006310, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006311, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006312, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006313, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006314, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006315, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006316, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006317, "text": "extract_array(obj: 'object', extract_numpy: 'bool' = False, extract_range: 'bool' = False) -> 'Any | ArrayLike': Extract the ndarray or ExtensionArray from a Series or Index."}
{"text_id": 1006318, "text": "factorize_array(values: 'np.ndarray', na_sentinel: 'int' = -1, size_hint: 'int | None' = None, na_value=None, mask: 'np.ndarray | None' = None) -> 'tuple[np.ndarray, np.ndarray]': Factorize an array-like to codes and uniques."}
{"text_id": 1006319, "text": "infer_dtype_from_array(arr, pandas_dtype: 'bool' = False) -> 'tuple[DtypeObj, ArrayLike]': Infer the dtype from an array."}
{"text_id": 1006320, "text": "na_value_for_dtype(dtype: Union[numpy.dtype, ForwardRef('ExtensionDtype')], compat: bool = True): Return a dtype compat na value."}
{"text_id": 1006321, "text": "na_value_for_dtype(dtype: Union[numpy.dtype, ForwardRef('ExtensionDtype')], compat: bool = True): Return a dtype compat na value."}
{"text_id": 1006322, "text": "na_value_for_dtype(dtype: Union[numpy.dtype, ForwardRef('ExtensionDtype')], compat: bool = True): Return a dtype compat na value."}
{"text_id": 1006323, "text": "na_value_for_dtype(dtype: Union[numpy.dtype, ForwardRef('ExtensionDtype')], compat: bool = True): Return a dtype compat na value."}
{"text_id": 1006324, "text": "needs_i8_conversion(arr_or_dtype) -> 'bool': Check whether the array or dtype should be converted to int64."}
{"text_id": 1006325, "text": "needs_i8_conversion(arr_or_dtype) -> 'bool': Check whether the array or dtype should be converted to int64."}
{"text_id": 1006326, "text": "needs_i8_conversion(arr_or_dtype) -> 'bool': Check whether the array or dtype should be converted to int64."}
{"text_id": 1006327, "text": "needs_i8_conversion(arr_or_dtype) -> 'bool': Check whether the array or dtype should be converted to int64."}
{"text_id": 1006328, "text": "needs_i8_conversion(arr_or_dtype) -> 'bool': Check whether the array or dtype should be converted to int64."}
{"text_id": 1006329, "text": "pd_array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1006330, "text": "pd_array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1006331, "text": "pd_array(data: 'Sequence[object] | AnyArrayLike', dtype: 'Dtype | None' = None, copy: 'bool' = True) -> 'ExtensionArray': Create an array."}
{"text_id": 1006332, "text": "safe_sort(values, codes=None, na_sentinel: 'int' = -1, assume_unique: 'bool' = False, verify: 'bool' = True) -> 'np.ndarray | tuple[np.ndarray, np.ndarray]': Sort ``values`` and reorder corresponding ``codes``."}
{"text_id": 1006333, "text": "safe_sort(values, codes=None, na_sentinel: 'int' = -1, assume_unique: 'bool' = False, verify: 'bool' = True) -> 'np.ndarray | tuple[np.ndarray, np.ndarray]': Sort ``values`` and reorder corresponding ``codes``."}
{"text_id": 1006334, "text": "sanitize_to_nanoseconds(values: 'np.ndarray', copy: 'bool' = False) -> 'np.ndarray': Safely convert non-nanosecond datetime64 or timedelta64 values to nanosecond."}
{"text_id": 1006335, "text": "sanitize_to_nanoseconds(values: 'np.ndarray', copy: 'bool' = False) -> 'np.ndarray': Safely convert non-nanosecond datetime64 or timedelta64 values to nanosecond."}
{"text_id": 1006336, "text": "union_with_duplicates(lvals: 'ArrayLike', rvals: 'ArrayLike') -> 'ArrayLike': Extracts the union from lvals and rvals with respect to duplicates and nans in both arrays."}
{"text_id": 1006337, "text": "unique1d(values): Hash table-based unique."}
{"text_id": 1006338, "text": "unique1d(values): Hash table-based unique."}
{"text_id": 1006339, "text": "validate_indices(indices: 'np.ndarray', n: 'int') -> 'None': Perform bounds-checking for an indexer."}
{"text_id": 1006340, "text": "validate_indices(indices: 'np.ndarray', n: 'int') -> 'None': Perform bounds-checking for an indexer."}
{"text_id": 1006341, "text": "value_counts_arraylike(values, dropna: 'bool'): ."}
{"text_id": 1006342, "text": "date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize: 'bool' = False, name: 'Hashable' = None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex."}
{"text_id": 1006343, "text": "date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize: 'bool' = False, name: 'Hashable' = None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex."}
{"text_id": 1006344, "text": "date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize: 'bool' = False, name: 'Hashable' = None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex."}
{"text_id": 1006345, "text": "date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize: 'bool' = False, name: 'Hashable' = None, closed=None, **kwargs) -> 'DatetimeIndex': Return a fixed frequency DatetimeIndex."}
{"text_id": 1006346, "text": "interval_range(start=None, end=None, periods=None, freq=None, name: 'Hashable' = None, closed='right') -> 'IntervalIndex': Return a fixed frequency IntervalIndex."}
{"text_id": 1006347, "text": "interval_range(start=None, end=None, periods=None, freq=None, name: 'Hashable' = None, closed='right') -> 'IntervalIndex': Return a fixed frequency IntervalIndex."}
{"text_id": 1006348, "text": "interval_range(start=None, end=None, periods=None, freq=None, name: 'Hashable' = None, closed='right') -> 'IntervalIndex': Return a fixed frequency IntervalIndex."}
{"text_id": 1006349, "text": "interval_range(start=None, end=None, periods=None, freq=None, name: 'Hashable' = None, closed='right') -> 'IntervalIndex': Return a fixed frequency IntervalIndex."}
{"text_id": 1006350, "text": "period_range(start=None, end=None, periods: 'int | None' = None, freq=None, name=None) -> 'PeriodIndex': Return a fixed frequency PeriodIndex."}
{"text_id": 1006351, "text": "period_range(start=None, end=None, periods: 'int | None' = None, freq=None, name=None) -> 'PeriodIndex': Return a fixed frequency PeriodIndex."}
{"text_id": 1006352, "text": "period_range(start=None, end=None, periods: 'int | None' = None, freq=None, name=None) -> 'PeriodIndex': Return a fixed frequency PeriodIndex."}
{"text_id": 1006353, "text": "period_range(start=None, end=None, periods: 'int | None' = None, freq=None, name=None) -> 'PeriodIndex': Return a fixed frequency PeriodIndex."}
{"text_id": 1006354, "text": "set_eng_float_format(accuracy: 'int' = 3, use_eng_prefix: 'bool' = False) -> 'None': Alter default behavior on how float is formatted in DataFrame."}
{"text_id": 1006355, "text": "set_eng_float_format(accuracy: 'int' = 3, use_eng_prefix: 'bool' = False) -> 'None': Alter default behavior on how float is formatted in DataFrame."}
{"text_id": 1006356, "text": "set_eng_float_format(accuracy: 'int' = 3, use_eng_prefix: 'bool' = False) -> 'None': Alter default behavior on how float is formatted in DataFrame."}
{"text_id": 1006357, "text": "set_eng_float_format(accuracy: 'int' = 3, use_eng_prefix: 'bool' = False) -> 'None': Alter default behavior on how float is formatted in DataFrame."}
{"text_id": 1006358, "text": "timedelta_range(start=None, end=None, periods: 'Optional[int]' = None, freq=None, name=None, closed=None) -> 'TimedeltaIndex': Return a fixed frequency TimedeltaIndex, with day as the default frequency."}
{"text_id": 1006359, "text": "timedelta_range(start=None, end=None, periods: 'Optional[int]' = None, freq=None, name=None, closed=None) -> 'TimedeltaIndex': Return a fixed frequency TimedeltaIndex, with day as the default frequency."}
{"text_id": 1006360, "text": "timedelta_range(start=None, end=None, periods: 'Optional[int]' = None, freq=None, name=None, closed=None) -> 'TimedeltaIndex': Return a fixed frequency TimedeltaIndex, with day as the default frequency."}
{"text_id": 1006361, "text": "timedelta_range(start=None, end=None, periods: 'Optional[int]' = None, freq=None, name=None, closed=None) -> 'TimedeltaIndex': Return a fixed frequency TimedeltaIndex, with day as the default frequency."}
{"text_id": 1006362, "text": "to_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None': Convert argument to datetime."}
{"text_id": 1006363, "text": "to_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None': Convert argument to datetime."}
{"text_id": 1006364, "text": "to_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None': Convert argument to datetime."}
{"text_id": 1006365, "text": "to_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None': Convert argument to datetime."}
{"text_id": 1006366, "text": "to_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None': Convert argument to datetime."}
{"text_id": 1006367, "text": "to_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None': Convert argument to datetime."}
{"text_id": 1006368, "text": "to_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, format: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_format: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Series | DatetimeScalar | NaTType | None': Convert argument to datetime."}
{"text_id": 1006369, "text": "to_numeric(arg, errors='raise', downcast=None): Convert argument to a numeric type."}
{"text_id": 1006370, "text": "to_numeric(arg, errors='raise', downcast=None): Convert argument to a numeric type."}
{"text_id": 1006371, "text": "to_numeric(arg, errors='raise', downcast=None): Convert argument to a numeric type."}
{"text_id": 1006372, "text": "to_numeric(arg, errors='raise', downcast=None): Convert argument to a numeric type."}
{"text_id": 1006373, "text": "to_timedelta(arg, unit=None, errors='raise'): Convert argument to timedelta."}
{"text_id": 1006374, "text": "to_timedelta(arg, unit=None, errors='raise'): Convert argument to timedelta."}
{"text_id": 1006375, "text": "to_timedelta(arg, unit=None, errors='raise'): Convert argument to timedelta."}
{"text_id": 1006376, "text": "to_timedelta(arg, unit=None, errors='raise'): Convert argument to timedelta."}
{"text_id": 1006377, "text": "to_timedelta(arg, unit=None, errors='raise'): Convert argument to timedelta."}
{"text_id": 1006378, "text": "AggFuncTypeBase(*args, **kwargs): The central part of internal API."}
{"text_id": 1006379, "text": "AggFuncTypeDict(*args, **kwargs): The central part of internal API."}
{"text_id": 1006380, "text": "AggObjType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006381, "text": "Axis(*args, **kwargs): The central part of internal API."}
{"text_id": 1006382, "text": "Axis(*args, **kwargs): The central part of internal API."}
{"text_id": 1006383, "text": "Axis(*args, **kwargs): The central part of internal API."}
{"text_id": 1006384, "text": "Axis(*args, **kwargs): The central part of internal API."}
{"text_id": 1006385, "text": "Axis(*args, **kwargs): The central part of internal API."}
{"text_id": 1006386, "text": "Dict(*args, **kwargs): The central part of internal API."}
{"text_id": 1006387, "text": "Iterator(*args, **kwargs): The central part of internal API."}
{"text_id": 1006388, "text": "Iterator(*args, **kwargs): The central part of internal API."}
{"text_id": 1006389, "text": "Iterator(*args, **kwargs): The central part of internal API."}
{"text_id": 1006390, "text": "Iterator(*args, **kwargs): The central part of internal API."}
{"text_id": 1006391, "text": "Iterator(*args, **kwargs): The central part of internal API."}
{"text_id": 1006392, "text": "List(*args, **kwargs): The central part of internal API."}
{"text_id": 1006393, "text": "NDFrameApply(obj: 'AggObjType', func, raw: 'bool', result_type: 'str | None', args, kwargs): Methods shared by FrameApply and SeriesApply but not GroupByApply or ResamplerWindowApply."}
{"text_id": 1006394, "text": "ResType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006395, "text": "SelectionMixin(*args, **kwds): mixin implementing the selection & aggregation interface on a group-like object sub-classes need to define: obj, exclusions."}
{"text_id": 1006396, "text": "SelectionMixin(*args, **kwds): mixin implementing the selection & aggregation interface on a group-like object sub-classes need to define: obj, exclusions."}
{"text_id": 1006397, "text": "create_series_with_explicit_dtype(data: 'Any' = None, index: 'ArrayLike | Index | None' = None, dtype: 'Dtype | None' = None, name: 'str | None' = None, copy: 'bool' = False, fastpath: 'bool' = False, dtype_if_empty: 'Dtype' = <class 'object'>) -> 'Series': Helper to pass an explicit dtype when instantiating an empty Series."}
{"text_id": 1006398, "text": "create_series_with_explicit_dtype(data: 'Any' = None, index: 'ArrayLike | Index | None' = None, dtype: 'Dtype | None' = None, name: 'str | None' = None, copy: 'bool' = False, fastpath: 'bool' = False, dtype_if_empty: 'Dtype' = <class 'object'>) -> 'Series': Helper to pass an explicit dtype when instantiating an empty Series."}
{"text_id": 1006399, "text": "create_series_with_explicit_dtype(data: 'Any' = None, index: 'ArrayLike | Index | None' = None, dtype: 'Dtype | None' = None, name: 'str | None' = None, copy: 'bool' = False, fastpath: 'bool' = False, dtype_if_empty: 'Dtype' = <class 'object'>) -> 'Series': Helper to pass an explicit dtype when instantiating an empty Series."}
{"text_id": 1006400, "text": "create_series_with_explicit_dtype(data: 'Any' = None, index: 'ArrayLike | Index | None' = None, dtype: 'Dtype | None' = None, name: 'str | None' = None, copy: 'bool' = False, fastpath: 'bool' = False, dtype_if_empty: 'Dtype' = <class 'object'>) -> 'Series': Helper to pass an explicit dtype when instantiating an empty Series."}
{"text_id": 1006401, "text": "create_series_with_explicit_dtype(data: 'Any' = None, index: 'ArrayLike | Index | None' = None, dtype: 'Dtype | None' = None, name: 'str | None' = None, copy: 'bool' = False, fastpath: 'bool' = False, dtype_if_empty: 'Dtype' = <class 'object'>) -> 'Series': Helper to pass an explicit dtype when instantiating an empty Series."}
{"text_id": 1006402, "text": "create_series_with_explicit_dtype(data: 'Any' = None, index: 'ArrayLike | Index | None' = None, dtype: 'Dtype | None' = None, name: 'str | None' = None, copy: 'bool' = False, fastpath: 'bool' = False, dtype_if_empty: 'Dtype' = <class 'object'>) -> 'Series': Helper to pass an explicit dtype when instantiating an empty Series."}
{"text_id": 1006403, "text": "frame_apply(obj: 'DataFrame', func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type: 'str | None' = None, args=None, kwargs=None) -> 'FrameApply': construct and return a row or column based frame apply object."}
{"text_id": 1006404, "text": "is_nested_object(obj) -> 'bool': return a boolean if we have a nested object, e."}
{"text_id": 1006405, "text": "is_sequence(obj) -> bool: Check if the object is a sequence of objects."}
{"text_id": 1006406, "text": "is_sequence(obj) -> bool: Check if the object is a sequence of objects."}
{"text_id": 1006407, "text": "is_sequence(obj) -> bool: Check if the object is a sequence of objects."}
{"text_id": 1006408, "text": "option_context(*args): Context manager to temporarily set options in the `with` statement context."}
{"text_id": 1006409, "text": "option_context(*args): Context manager to temporarily set options in the `with` statement context."}
{"text_id": 1006410, "text": "option_context(*args): Context manager to temporarily set options in the `with` statement context."}
{"text_id": 1006411, "text": "option_context(*args): Context manager to temporarily set options in the `with` statement context."}
{"text_id": 1006412, "text": "option_context(*args): Context manager to temporarily set options in the `with` statement context."}
{"text_id": 1006413, "text": "array_ufunc(self, ufunc: numpy.ufunc, method: str, *inputs: Any, **kwargs: Any): Compatibility with numpy ufuncs."}
{"text_id": 1006414, "text": "unpack_zerodim_and_defer(name: str) -> Callable[[~F], ~F]: Boilerplate for pandas conventions in arithmetic and comparison methods."}
{"text_id": 1006415, "text": "unpack_zerodim_and_defer(name: str) -> Callable[[~F], ~F]: Boilerplate for pandas conventions in arithmetic and comparison methods."}
{"text_id": 1006416, "text": "BaseMaskedArray(values: 'np.ndarray', mask: 'np.ndarray', copy: 'bool' = False): Base class for masked arrays (which use _data and _mask to store the data)."}
{"text_id": 1006417, "text": "ExtensionOpsMixin(): A base class for linking the operators to their dunder names."}
{"text_id": 1006418, "text": "period_array(data: 'Sequence[Period | str | None] | AnyArrayLike', freq: 'str | Tick | None' = None, copy: 'bool' = False) -> 'PeriodArray': Construct a new PeriodArray from a sequence of Period scalars."}
{"text_id": 1006419, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006420, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006421, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006422, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006423, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006424, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006425, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006426, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006427, "text": "AbstractMethodError(class_instance, methodtype='method'): Raise this error instead of NotImplementedError for abstract methods while keeping compatibility with Python 2 and Python 3."}
{"text_id": 1006428, "text": "Dtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006429, "text": "Dtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006430, "text": "Dtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006431, "text": "Dtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006432, "text": "Dtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006433, "text": "Dtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006434, "text": "Generic(*args, **kwds): Abstract base class for generic types."}
{"text_id": 1006435, "text": "IndexLabel(*args, **kwargs): The central part of internal API."}
{"text_id": 1006436, "text": "IndexLabel(*args, **kwargs): The central part of internal API."}
{"text_id": 1006437, "text": "IndexLabel(*args, **kwargs): The central part of internal API."}
{"text_id": 1006438, "text": "IndexOpsMixin(): Common ops mixin to support a unified interface / docs for Series / Index."}
{"text_id": 1006439, "text": "NoNewAttributesMixin(): Mixin which prevents adding new attributes."}
{"text_id": 1006440, "text": "PandasObject(): Baseclass for various pandas objects."}
{"text_id": 1006441, "text": "PandasObject(): Baseclass for various pandas objects."}
{"text_id": 1006442, "text": "PandasObject(): Baseclass for various pandas objects."}
{"text_id": 1006443, "text": "Shape(*args, **kwargs): The central part of internal API."}
{"text_id": 1006444, "text": "Shape(*args, **kwargs): The central part of internal API."}
{"text_id": 1006445, "text": "Shape(*args, **kwargs): The central part of internal API."}
{"text_id": 1006446, "text": "Shape(*args, **kwargs): The central part of internal API."}
{"text_id": 1006447, "text": "remove_na_arraylike(arr): Return array-like containing only true/non-NaN values, possibly empty."}
{"text_id": 1006448, "text": "remove_na_arraylike(arr): Return array-like containing only true/non-NaN values, possibly empty."}
{"text_id": 1006449, "text": "Collection(*args, **kwargs): The central part of internal API."}
{"text_id": 1006450, "text": "NpDtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006451, "text": "NpDtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006452, "text": "NpDtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006453, "text": "NpDtype(*args, **kwargs): The central part of internal API."}
{"text_id": 1006454, "text": "all_none(*args) -> 'bool': Returns a boolean indicating if all arguments are None."}
{"text_id": 1006455, "text": "all_not_none(*args) -> 'bool': Returns a boolean indicating if all arguments are not None."}
{"text_id": 1006456, "text": "any_none(*args) -> 'bool': Returns a boolean indicating if any argument is None."}
{"text_id": 1006457, "text": "any_not_none(*args) -> 'bool': Returns a boolean indicating if any argument is not None."}
{"text_id": 1006458, "text": "apply_if_callable(maybe_callable, obj, **kwargs): Evaluate possibly callable input using obj and kwargs if it is callable, otherwise return as it is."}
{"text_id": 1006459, "text": "cast_scalar_indexer(val, warn_float: 'bool' = False): To avoid numpy DeprecationWarnings, cast float to integer where valid."}
{"text_id": 1006460, "text": "convert_to_list_like(values: 'Scalar | Iterable | AnyArrayLike') -> 'list | AnyArrayLike': Convert list-like or scalar input to list-like."}
{"text_id": 1006461, "text": "count_not_none(*args) -> 'int': Returns the count of arguments that are not None."}
{"text_id": 1006462, "text": "get_cython_func(arg: 'Callable') -> 'str | None': if we define an internal function for this argument, return it."}
{"text_id": 1006463, "text": "get_rename_function(mapper): Returns a function that will map names/labels, dependent if mapper is a dict, Series or just a function."}
{"text_id": 1006464, "text": "index_labels_to_array(labels, dtype: 'NpDtype | None' = None) -> 'np.ndarray': Transform label or iterable of labels to array, for use in Index."}
{"text_id": 1006465, "text": "is_bool_indexer(key: 'Any') -> 'bool': Check whether `key` is a valid boolean indexer."}
{"text_id": 1006466, "text": "is_builtin_func(arg): if we define an builtin function for this argument, return it, otherwise return the arg."}
{"text_id": 1006467, "text": "is_full_slice(obj, line: 'int') -> 'bool': We have a full length slice."}
{"text_id": 1006468, "text": "is_null_slice(obj) -> 'bool': We have a null slice."}
{"text_id": 1006469, "text": "is_true_slices(line) -> 'list[bool]': Find non-trivial slices in \"line\": return a list of booleans with same length."}
{"text_id": 1006470, "text": "iterable_not_string(obj) -> bool: Check if the object is an iterable but not a string."}
{"text_id": 1006471, "text": "maybe_iterable_to_list(obj: 'Iterable[T] | T') -> 'Collection[T] | T': If obj is Iterable but not list-like, consume into list."}
{"text_id": 1006472, "text": "not_none(*args): Returns a generator consisting of the arguments that are not None."}
{"text_id": 1006473, "text": "random_state(state=None): Helper function for processing random_state arguments."}
{"text_id": 1006474, "text": "require_length_match(data, index: 'Index'): Check the length of data matches the length of the index."}
{"text_id": 1006475, "text": "standardize_mapping(into): Helper function to standardize a supplied mapping."}
{"text_id": 1006476, "text": "temp_setattr(obj, attr: 'str', value) -> 'Iterator[None]': Temporarily set attribute on an object."}
{"text_id": 1006477, "text": "is_callable(obj) -> 'bool': ."}
{"text_id": 1006478, "text": "is_instance_factory(_type) -> 'Callable[[Any], None]': ."}
{"text_id": 1006479, "text": "is_nonnegative_int(value: 'int | None') -> 'None': Verify that value is None or a positive int."}
{"text_id": 1006480, "text": "is_terminal() -> bool: Detect if Python is running in a terminal."}
{"text_id": 1006481, "text": "construct_1d_arraylike_from_scalar(value: 'Scalar', length: 'int', dtype: 'DtypeObj | None') -> 'ArrayLike': create a np."}
{"text_id": 1006482, "text": "construct_1d_arraylike_from_scalar(value: 'Scalar', length: 'int', dtype: 'DtypeObj | None') -> 'ArrayLike': create a np."}
{"text_id": 1006483, "text": "is_empty_data(data: 'Any') -> 'bool': Utility to check if a Series is instantiated with empty data, which does not contain dtype information."}
{"text_id": 1006484, "text": "is_empty_data(data: 'Any') -> 'bool': Utility to check if a Series is instantiated with empty data, which does not contain dtype information."}
{"text_id": 1006485, "text": "maybe_cast_to_datetime(value: 'ExtensionArray | np.ndarray | list', dtype: 'DtypeObj | None') -> 'ExtensionArray | np.ndarray': try to cast the array/value to a datetimelike dtype, converting float nan to iNaT We allow a list *only* when dtype is not None."}
{"text_id": 1006486, "text": "maybe_cast_to_integer_array(arr: 'list | np.ndarray', dtype: 'np.dtype', copy: 'bool' = False) -> 'np.ndarray': Takes any dtype and returns the casted version, raising for when data is incompatible with integer/unsigned integer dtypes."}
{"text_id": 1006487, "text": "maybe_convert_platform(values: 'list | tuple | range | np.ndarray | ExtensionArray') -> 'ArrayLike': try to do platform conversion, allow ndarray or list here."}
{"text_id": 1006488, "text": "maybe_infer_to_datetimelike(value: 'np.ndarray') -> 'np.ndarray | DatetimeArray | TimedeltaArray | PeriodArray | IntervalArray': we might have a array (or single object) that is datetime like, and no dtype is passed don't change the value unless we find a datetime/timedelta set this is pretty strict in that a datetime/timedelta is REQUIRED in addition to possible nulls/string likes."}
{"text_id": 1006489, "text": "maybe_upcast(values: 'NumpyArrayT', fill_value: 'Scalar' = nan, copy: 'bool' = False) -> 'tuple[NumpyArrayT, Scalar]': Provide explicit type promotion and coercion."}
{"text_id": 1006490, "text": "range_to_ndarray(rng: 'range') -> 'np.ndarray': Cast a range object to ndarray."}
{"text_id": 1006491, "text": "sanitize_array(data, index: 'Index | None', dtype: 'DtypeObj | None' = None, copy: 'bool' = False, raise_cast_failure: 'bool' = True, *, allow_2d: 'bool' = False) -> 'ArrayLike': Sanitize input data to an ndarray or ExtensionArray, copy if specified, coerce to the dtype if specified."}
{"text_id": 1006492, "text": "sanitize_array(data, index: 'Index | None', dtype: 'DtypeObj | None' = None, copy: 'bool' = False, raise_cast_failure: 'bool' = True, *, allow_2d: 'bool' = False) -> 'ArrayLike': Sanitize input data to an ndarray or ExtensionArray, copy if specified, coerce to the dtype if specified."}
{"text_id": 1006493, "text": "sanitize_array(data, index: 'Index | None', dtype: 'DtypeObj | None' = None, copy: 'bool' = False, raise_cast_failure: 'bool' = True, *, allow_2d: 'bool' = False) -> 'ArrayLike': Sanitize input data to an ndarray or ExtensionArray, copy if specified, coerce to the dtype if specified."}
{"text_id": 1006494, "text": "sanitize_masked_array(data: 'ma.MaskedArray') -> 'np.ndarray': Convert numpy MaskedArray to ensure mask is softened."}
{"text_id": 1006495, "text": "sanitize_masked_array(data: 'ma.MaskedArray') -> 'np.ndarray': Convert numpy MaskedArray to ensure mask is softened."}
{"text_id": 1006496, "text": "ABC(): Helper class that provides a standard way to create an ABC using inheritance."}
{"text_id": 1006497, "text": "DataFrameDescriber(obj: 'DataFrame', *, include: 'str | Sequence[str] | None', exclude: 'str | Sequence[str] | None', datetime_is_numeric: 'bool'): Class responsible for creating dataobj description."}
{"text_id": 1006498, "text": "NDFrameDescriberAbstract(obj: 'FrameOrSeriesUnion', datetime_is_numeric: 'bool'): Abstract class for describing dataframe or series."}
{"text_id": 1006499, "text": "SeriesDescriber(obj: 'FrameOrSeriesUnion', datetime_is_numeric: 'bool'): Class responsible for creating series description."}
{"text_id": 1006500, "text": "abstractmethod(funcobj): A decorator indicating abstract methods."}
{"text_id": 1006501, "text": "describe_categorical_1d(data: 'Series', percentiles_ignored: 'Sequence[float]') -> 'Series': Describe series containing categorical data."}
{"text_id": 1006502, "text": "describe_ndframe(*, obj: 'FrameOrSeries', include: 'str | Sequence[str] | None', exclude: 'str | Sequence[str] | None', datetime_is_numeric: 'bool', percentiles: 'Sequence[float] | None') -> 'FrameOrSeries': Describe series or dataframe."}
{"text_id": 1006503, "text": "describe_ndframe(*, obj: 'FrameOrSeries', include: 'str | Sequence[str] | None', exclude: 'str | Sequence[str] | None', datetime_is_numeric: 'bool', percentiles: 'Sequence[float] | None') -> 'FrameOrSeries': Describe series or dataframe."}
{"text_id": 1006504, "text": "describe_numeric_1d(series: 'Series', percentiles: 'Sequence[float]') -> 'Series': Describe series containing numerical data."}
{"text_id": 1006505, "text": "describe_timestamp_1d(data: 'Series', percentiles: 'Sequence[float]') -> 'Series': Describe series containing datetime64 dtype."}
{"text_id": 1006506, "text": "describe_timestamp_as_categorical_1d(data: 'Series', percentiles_ignored: 'Sequence[float]') -> 'Series': Describe series containing timestamp data treated as categorical."}
{"text_id": 1006507, "text": "format_percentiles(percentiles: 'np.ndarray | list[int | float] | list[float] | list[str | float]') -> 'list[str]': Outputs rounded and formatted percentiles."}
{"text_id": 1006508, "text": "refine_percentiles(percentiles: 'Sequence[float] | None') -> 'Sequence[float]': Ensure that percentiles are unique and sorted."}
{"text_id": 1006509, "text": "reorder_columns(ldesc: 'Sequence[Series]') -> 'list[Hashable]': Set a convenient order for rows for display."}
{"text_id": 1006510, "text": "select_describe_func(data: 'Series', datetime_is_numeric: 'bool') -> 'Callable': Select proper function for describing series based on data type."}
{"text_id": 1006511, "text": "validate_percentile(q: 'float | Iterable[float]') -> 'np.ndarray': Validate percentiles (used by describe and quantile)."}
{"text_id": 1006512, "text": "validate_percentile(q: 'float | Iterable[float]') -> 'np.ndarray': Validate percentiles (used by describe and quantile)."}
{"text_id": 1006513, "text": "validate_percentile(q: 'float | Iterable[float]') -> 'np.ndarray': Validate percentiles (used by describe and quantile)."}
{"text_id": 1006514, "text": "Appender(addendum: 'str | None', join: 'str' = '', indents: 'int' = 0): A function decorator that will append an addendum to the docstring of the target function."}
{"text_id": 1006515, "text": "Appender(addendum: 'str | None', join: 'str' = '', indents: 'int' = 0): A function decorator that will append an addendum to the docstring of the target function."}
{"text_id": 1006516, "text": "Appender(addendum: 'str | None', join: 'str' = '', indents: 'int' = 0): A function decorator that will append an addendum to the docstring of the target function."}
{"text_id": 1006517, "text": "Appender(addendum: 'str | None', join: 'str' = '', indents: 'int' = 0): A function decorator that will append an addendum to the docstring of the target function."}
{"text_id": 1006518, "text": "Appender(addendum: 'str | None', join: 'str' = '', indents: 'int' = 0): A function decorator that will append an addendum to the docstring of the target function."}
{"text_id": 1006519, "text": "Appender(addendum: 'str | None', join: 'str' = '', indents: 'int' = 0): A function decorator that will append an addendum to the docstring of the target function."}
{"text_id": 1006520, "text": "Axes(*args, **kwargs): The central part of internal API."}
{"text_id": 1006521, "text": "BaseInfo(): Base class for DataFrameInfo and SeriesInfo."}
{"text_id": 1006522, "text": "ColspaceArgType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006523, "text": "CompressionOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006524, "text": "CompressionOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006525, "text": "CompressionOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006526, "text": "CompressionOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006527, "text": "CompressionOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006528, "text": "CompressionOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006529, "text": "DataFrameInfo(data: 'DataFrame', memory_usage: 'bool | str | None' = None): Class storing dataframe-specific info."}
{"text_id": 1006530, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006531, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006532, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006533, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006534, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006535, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006536, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006537, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006538, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006539, "text": "FilePathOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006540, "text": "FloatFormatType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006541, "text": "FormattersType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006542, "text": "Frequency(*args, **kwargs): The central part of internal API."}
{"text_id": 1006543, "text": "IO(*args, **kwds): Generic base class for TextIO and BinaryIO."}
{"text_id": 1006544, "text": "IO(*args, **kwds): Generic base class for TextIO and BinaryIO."}
{"text_id": 1006545, "text": "IO(*args, **kwds): Generic base class for TextIO and BinaryIO."}
{"text_id": 1006546, "text": "IndexKeyFunc(*args, **kwargs): The central part of internal API."}
{"text_id": 1006547, "text": "IndexKeyFunc(*args, **kwargs): The central part of internal API."}
{"text_id": 1006548, "text": "IndexKeyFunc(*args, **kwargs): The central part of internal API."}
{"text_id": 1006549, "text": "IndexKeyFunc(*args, **kwargs): The central part of internal API."}
{"text_id": 1006550, "text": "Level(*args, **kwargs): The central part of internal API."}
{"text_id": 1006551, "text": "Level(*args, **kwargs): The central part of internal API."}
{"text_id": 1006552, "text": "Level(*args, **kwargs): The central part of internal API."}
{"text_id": 1006553, "text": "NDFrame(data: 'Manager', copy: 'bool_t' = False, attrs: 'Mapping[Hashable, Any] | None' = None): N-dimensional analogue of DataFrame."}
{"text_id": 1006554, "text": "NDFrame(data: 'Manager', copy: 'bool_t' = False, attrs: 'Mapping[Hashable, Any] | None' = None): N-dimensional analogue of DataFrame."}
{"text_id": 1006555, "text": "NDFrame(data: 'Manager', copy: 'bool_t' = False, attrs: 'Mapping[Hashable, Any] | None' = None): N-dimensional analogue of DataFrame."}
{"text_id": 1006556, "text": "PythonFuncType(*args, **kwargs): The central part of internal API."}
{"text_id": 1006557, "text": "Renamer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006558, "text": "Renamer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006559, "text": "SparseFrameAccessor(data=None): DataFrame accessor for sparse data."}
{"text_id": 1006560, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006561, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006562, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006563, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006564, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006565, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006566, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006567, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006568, "text": "StorageOptions(*args, **kwargs): The central part of internal API."}
{"text_id": 1006569, "text": "StringIO(initial_value='', newline='\\n'): Text I/O implementation using an in-memory buffer."}
{"text_id": 1006570, "text": "StringIO(initial_value='', newline='\\n'): Text I/O implementation using an in-memory buffer."}
{"text_id": 1006571, "text": "StringIO(initial_value='', newline='\\n'): Text I/O implementation using an in-memory buffer."}
{"text_id": 1006572, "text": "StringIO(initial_value='', newline='\\n'): Text I/O implementation using an in-memory buffer."}
{"text_id": 1006573, "text": "Substitution(*args, **kwargs): A decorator to take a function's docstring and perform string substitution on it."}
{"text_id": 1006574, "text": "Substitution(*args, **kwargs): A decorator to take a function's docstring and perform string substitution on it."}
{"text_id": 1006575, "text": "Substitution(*args, **kwargs): A decorator to take a function's docstring and perform string substitution on it."}
{"text_id": 1006576, "text": "Substitution(*args, **kwargs): A decorator to take a function's docstring and perform string substitution on it."}
{"text_id": 1006577, "text": "Suffixes(*args, **kwargs): The central part of internal API."}
{"text_id": 1006578, "text": "ValueKeyFunc(*args, **kwargs): The central part of internal API."}
{"text_id": 1006579, "text": "ValueKeyFunc(*args, **kwargs): The central part of internal API."}
{"text_id": 1006580, "text": "ValueKeyFunc(*args, **kwargs): The central part of internal API."}
{"text_id": 1006581, "text": "arrays_to_mgr(arrays, arr_names: 'Index', index, columns, *, dtype: 'DtypeObj | None' = None, verify_integrity: 'bool' = True, typ: 'str | None' = None, consolidate: 'bool' = True) -> 'Manager': Segregate Series based on type and coerce into matrices."}
{"text_id": 1006582, "text": "check_bool_indexer(index: 'Index', key) -> 'np.ndarray': Check if key is a valid boolean indexer for an object with such index and perform reindexing or conversion if needed."}
{"text_id": 1006583, "text": "check_bool_indexer(index: 'Index', key) -> 'np.ndarray': Check if key is a valid boolean indexer for an object with such index and perform reindexing or conversion if needed."}
{"text_id": 1006584, "text": "check_bool_indexer(index: 'Index', key) -> 'np.ndarray': Check if key is a valid boolean indexer for an object with such index and perform reindexing or conversion if needed."}
{"text_id": 1006585, "text": "check_key_length(columns: 'Index', key, value: 'DataFrame'): Checks if a key used as indexer has the same length as the columns it is associated with."}
{"text_id": 1006586, "text": "check_key_length(columns: 'Index', key, value: 'DataFrame'): Checks if a key used as indexer has the same length as the columns it is associated with."}
{"text_id": 1006587, "text": "convert_to_index_sliceable(obj: 'DataFrame', key): If we are index sliceable, then return my slicer, otherwise return None."}
{"text_id": 1006588, "text": "convert_to_index_sliceable(obj: 'DataFrame', key): If we are index sliceable, then return my slicer, otherwise return None."}
{"text_id": 1006589, "text": "dataclasses_to_dicts(data): Converts a list of dataclass instances to a list of dictionaries."}
{"text_id": 1006590, "text": "deprecate_kwarg(old_arg_name: 'str', new_arg_name: 'str | None', mapping: 'Mapping[Any, Any] | Callable[[Any], Any] | None' = None, stacklevel: 'int' = 2) -> 'Callable[[F], F]': Decorator to deprecate a keyword argument of a function."}
{"text_id": 1006591, "text": "deprecate_nonkeyword_arguments(version: 'str | None', allowed_args: 'list[str] | None' = None, stacklevel: 'int' = 2) -> 'Callable[[F], F]': Decorator to deprecate a use of non-keyword arguments of a function."}
{"text_id": 1006592, "text": "deprecate_nonkeyword_arguments(version: 'str | None', allowed_args: 'list[str] | None' = None, stacklevel: 'int' = 2) -> 'Callable[[F], F]': Decorator to deprecate a use of non-keyword arguments of a function."}
{"text_id": 1006593, "text": "deprecate_nonkeyword_arguments(version: 'str | None', allowed_args: 'list[str] | None' = None, stacklevel: 'int' = 2) -> 'Callable[[F], F]': Decorator to deprecate a use of non-keyword arguments of a function."}
{"text_id": 1006594, "text": "dict_to_mgr(data: 'dict', index, columns, *, dtype: 'DtypeObj | None' = None, typ: 'str' = 'block', copy: 'bool' = True) -> 'Manager': Segregate Series based on type and coerce into matrices."}
{"text_id": 1006595, "text": "ensure_index(index_like: 'AnyArrayLike | Sequence', copy: 'bool' = False) -> 'Index': Ensure that we have an index from some index-like object."}
{"text_id": 1006596, "text": "ensure_index(index_like: 'AnyArrayLike | Sequence', copy: 'bool' = False) -> 'Index': Ensure that we have an index from some index-like object."}
{"text_id": 1006597, "text": "ensure_index(index_like: 'AnyArrayLike | Sequence', copy: 'bool' = False) -> 'Index': Ensure that we have an index from some index-like object."}
{"text_id": 1006598, "text": "ensure_index(index_like: 'AnyArrayLike | Sequence', copy: 'bool' = False) -> 'Index': Ensure that we have an index from some index-like object."}
{"text_id": 1006599, "text": "ensure_index(index_like: 'AnyArrayLike | Sequence', copy: 'bool' = False) -> 'Index': Ensure that we have an index from some index-like object."}
{"text_id": 1006600, "text": "ensure_index_from_sequences(sequences, names=None): Construct an index from sequences of data."}
{"text_id": 1006601, "text": "find_common_type(types: 'list[DtypeObj]') -> 'DtypeObj': Find a common data type among the given dtypes."}
{"text_id": 1006602, "text": "get_group_index(labels, shape: 'Shape', sort: 'bool', xnull: 'bool'): For the particular label_list, gets the offsets into the hypothetical list representing the totally ordered cartesian product of all possible label combinations, *as long as* this space fits within int64 bounds; otherwise, though group indices identify unique combinations of labels, they cannot be deconstructed."}
{"text_id": 1006603, "text": "get_group_index(labels, shape: 'Shape', sort: 'bool', xnull: 'bool'): For the particular label_list, gets the offsets into the hypothetical list representing the totally ordered cartesian product of all possible label combinations, *as long as* this space fits within int64 bounds; otherwise, though group indices identify unique combinations of labels, they cannot be deconstructed."}
{"text_id": 1006604, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006605, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006606, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006607, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006608, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006609, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006610, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006611, "text": "get_handle(path_or_buf: 'FilePathOrBuffer', mode: 'str', encoding: 'str | None' = None, compression: 'CompressionOptions' = None, memory_map: 'bool' = False, is_text: 'bool' = True, errors: 'str | None' = None, storage_options: 'StorageOptions' = None) -> 'IOHandles': Get file handle for given path/buffer and mode."}
{"text_id": 1006612, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006613, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006614, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006615, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006616, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006617, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006618, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006619, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006620, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006621, "text": "get_option(*args, **kwds): get_option(pat) Retrieves the value of the specified option."}
{"text_id": 1006622, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006623, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006624, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006625, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006626, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006627, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006628, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006629, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006630, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006631, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006632, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006633, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006634, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006635, "text": "import_optional_dependency(name: 'str', extra: 'str' = '', errors: 'str' = 'raise', min_version: 'str | None' = None): Import an optional dependency."}
{"text_id": 1006636, "text": "infer_dtype_from_object(dtype) -> 'DtypeObj': Get a numpy dtype."}
{"text_id": 1006637, "text": "infer_dtype_from_scalar(val, pandas_dtype: 'bool' = False) -> 'tuple[DtypeObj, Any]': Interpret the dtype from a scalar."}
{"text_id": 1006638, "text": "invalidate_string_dtypes(dtype_set: 'set[DtypeObj]'): Change string like dtypes to object for ``DataFrame."}
{"text_id": 1006639, "text": "is_1d_only_ea_dtype(dtype: 'Optional[DtypeObj]') -> 'bool': Analogue to is_extension_array_dtype but excluding DatetimeTZDtype."}
{"text_id": 1006640, "text": "is_1d_only_ea_obj(obj: 'Any') -> 'bool': ExtensionArray that does not support 2D, or more specifically that does not use HybridBlock."}
{"text_id": 1006641, "text": "is_dataclass(item): Checks if the object is a data-class instance."}
{"text_id": 1006642, "text": "lexsort_indexer(keys, orders=None, na_position: 'str' = 'last', key: 'Callable | None' = None) -> 'np.ndarray': Performs lexical sorting on a set of keys."}
{"text_id": 1006643, "text": "lexsort_indexer(keys, orders=None, na_position: 'str' = 'last', key: 'Callable | None' = None) -> 'np.ndarray': Performs lexical sorting on a set of keys."}
{"text_id": 1006644, "text": "maybe_box_native(value: 'Scalar') -> 'Scalar': If passed a scalar cast the scalar to a python native type."}
{"text_id": 1006645, "text": "maybe_box_native(value: 'Scalar') -> 'Scalar': If passed a scalar cast the scalar to a python native type."}
{"text_id": 1006646, "text": "maybe_downcast_to_dtype(result: 'ArrayLike', dtype: 'str | np.dtype') -> 'ArrayLike': try to cast to the specified dtype (e."}
{"text_id": 1006647, "text": "maybe_droplevels(index: 'Index', key) -> 'Index': Attempt to drop level or levels from the given index."}
{"text_id": 1006648, "text": "mgr_to_mgr(mgr, typ: 'str', copy: 'bool' = True): Convert to specific type of Manager."}
{"text_id": 1006649, "text": "mgr_to_mgr(mgr, typ: 'str', copy: 'bool' = True): Convert to specific type of Manager."}
{"text_id": 1006650, "text": "nargsort(items, kind: 'str' = 'quicksort', ascending: 'bool' = True, na_position: 'str' = 'last', key: 'Callable | None' = None, mask: 'np.ndarray | None' = None): Intended to be a drop-in replacement for np."}
{"text_id": 1006651, "text": "nargsort(items, kind: 'str' = 'quicksort', ascending: 'bool' = True, na_position: 'str' = 'last', key: 'Callable | None' = None, mask: 'np.ndarray | None' = None): Intended to be a drop-in replacement for np."}
{"text_id": 1006652, "text": "nargsort(items, kind: 'str' = 'quicksort', ascending: 'bool' = True, na_position: 'str' = 'last', key: 'Callable | None' = None, mask: 'np.ndarray | None' = None): Intended to be a drop-in replacement for np."}
{"text_id": 1006653, "text": "nested_data_to_arrays(data: 'Sequence', columns: 'Index | None', index: 'Index | None', dtype: 'DtypeObj | None') -> 'tuple[list[ArrayLike], Index, Index]': Convert a single sequence of arrays to multiple arrays."}
{"text_id": 1006654, "text": "overload(func): Decorator for overloaded functions/methods."}
{"text_id": 1006655, "text": "overload(func): Decorator for overloaded functions/methods."}
{"text_id": 1006656, "text": "overload(func): Decorator for overloaded functions/methods."}
{"text_id": 1006657, "text": "overload(func): Decorator for overloaded functions/methods."}
{"text_id": 1006658, "text": "rec_array_to_mgr(data: 'MaskedRecords | np.recarray | np.ndarray', index, columns, dtype: 'DtypeObj | None', copy: 'bool', typ: 'str'): Extract from a masked rec array and create the manager."}
{"text_id": 1006659, "text": "take_2d_multi(arr: 'np.ndarray', indexer: 'tuple[np.ndarray, np.ndarray]', fill_value=nan) -> 'np.ndarray': Specialized Cython take which sets NaN values in one pass."}
{"text_id": 1006660, "text": "to_arrays(data, columns: 'Index | None', dtype: 'DtypeObj | None' = None) -> 'tuple[list[ArrayLike], Index]': Return list of arrays, columns."}
{"text_id": 1006661, "text": "treat_as_nested(data) -> 'bool': Check if we should use nested_data_to_arrays."}
{"text_id": 1006662, "text": "validate_axis_style_args(data, args, kwargs, arg_name, method_name): Argument handler for mixed index, columns / axis functions In an attempt to handle both `."}
{"text_id": 1006663, "text": "validate_bool_kwarg(value, arg_name, none_allowed=True, int_allowed=False): Ensure that argument passed in arg_name can be interpreted as boolean."}
{"text_id": 1006664, "text": "validate_bool_kwarg(value, arg_name, none_allowed=True, int_allowed=False): Ensure that argument passed in arg_name can be interpreted as boolean."}
{"text_id": 1006665, "text": "validate_bool_kwarg(value, arg_name, none_allowed=True, int_allowed=False): Ensure that argument passed in arg_name can be interpreted as boolean."}
{"text_id": 1006666, "text": "validate_numeric_casting(dtype: 'np.dtype', value: 'Scalar') -> 'None': Check that we can losslessly insert the given value into an array with the given dtype."}
{"text_id": 1006667, "text": "validate_numeric_casting(dtype: 'np.dtype', value: 'Scalar') -> 'None': Check that we can losslessly insert the given value into an array with the given dtype."}
{"text_id": 1006668, "text": "DataFrameFormatter(frame: 'DataFrame', columns: 'Sequence[str] | None' = None, col_space: 'ColspaceArgType | None' = None, header: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatters: 'FormattersType | None' = None, justify: 'str | None' = None, float_format: 'FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, max_rows: 'int | None' = None, min_rows: 'int | None' = None, max_cols: 'int | None' = None, show_dimensions: 'bool | str' = False, decimal: 'str' = '.', bold_rows: 'bool' = False, escape: 'bool' = True): Class for processing dataframe formatting options and data."}
{"text_id": 1006669, "text": "DataFrameRenderer(fmt: 'DataFrameFormatter'): Class for creating dataframe output in multiple formats."}
{"text_id": 1006670, "text": "DtypeArg(*args, **kwargs): The central part of internal API."}
{"text_id": 1006671, "text": "DtypeArg(*args, **kwargs): The central part of internal API."}
{"text_id": 1006672, "text": "DtypeArg(*args, **kwargs): The central part of internal API."}
{"text_id": 1006673, "text": "Expanding(*args, **kwds): Provide expanding transformations."}
{"text_id": 1006674, "text": "Expanding(*args, **kwds): Provide expanding transformations."}
{"text_id": 1006675, "text": "ExponentialMovingWindow(*args, **kwds): Provide exponential weighted (EW) functions."}
{"text_id": 1006676, "text": "ExponentialMovingWindow(*args, **kwds): Provide exponential weighted (EW) functions."}
{"text_id": 1006677, "text": "JSONSerializable(*args, **kwargs): The central part of internal API."}
{"text_id": 1006678, "text": "Manager(*args, **kwargs): The central part of internal API."}
{"text_id": 1006679, "text": "Mapping(*args, **kwargs): The central part of internal API."}
{"text_id": 1006680, "text": "Mapping(*args, **kwargs): The central part of internal API."}
{"text_id": 1006681, "text": "Rolling(*args, **kwds): Provide rolling window calculations."}
{"text_id": 1006682, "text": "Rolling(*args, **kwds): Provide rolling window calculations."}
{"text_id": 1006683, "text": "TimedeltaConvertibleTypes(*args, **kwargs): The central part of internal API."}
{"text_id": 1006684, "text": "TimestampConvertibleTypes(*args, **kwargs): The central part of internal API."}
{"text_id": 1006685, "text": "Window(*args, **kwds): Provide rolling window calculations."}
{"text_id": 1006686, "text": "Window(*args, **kwds): Provide rolling window calculations."}
{"text_id": 1006687, "text": "align_method_FRAME(left, right, axis, flex: 'bool | None' = False, level: 'Level' = None): Convert rhs to meet lhs dims if input is list, tuple or np."}
{"text_id": 1006688, "text": "align_method_FRAME(left, right, axis, flex: 'bool | None' = False, level: 'Level' = None): Convert rhs to meet lhs dims if input is list, tuple or np."}
{"text_id": 1006689, "text": "ensure_str(value: 'bytes | Any') -> 'str': Ensure that bytes and non-strings get converted into ``str`` objects."}
{"text_id": 1006690, "text": "find_valid_index(values, *, how: 'str') -> 'int | None': Retrieves the index of the first valid value."}
{"text_id": 1006691, "text": "find_valid_index(values, *, how: 'str') -> 'int | None': Retrieves the index of the first valid value."}
{"text_id": 1006692, "text": "get_indexer_indexer(target: 'Index', level: 'str | int | list[str] | list[int]', ascending: 'Sequence[bool | int] | bool | int', kind: 'str', na_position: 'str', sort_remaining: 'bool', key: 'IndexKeyFunc') -> 'np.ndarray | None': Helper method that return the indexer according to input parameters for the sort_index method of DataFrame and Series."}
{"text_id": 1006693, "text": "get_indexer_indexer(target: 'Index', level: 'str | int | list[str] | list[int]', ascending: 'Sequence[bool | int] | bool | int', kind: 'str', na_position: 'str', sort_remaining: 'bool', key: 'IndexKeyFunc') -> 'np.ndarray | None': Helper method that return the indexer according to input parameters for the sort_index method of DataFrame and Series."}
{"text_id": 1006694, "text": "is_nested_list_like(obj) -> bool: Check if the object is list-like, and that all of its elements are also list-like."}
{"text_id": 1006695, "text": "pprint_thing(thing: 'Any', _nest_lvl: 'int' = 0, escape_chars: 'EscapeChars | None' = None, default_escapes: 'bool' = False, quote_strings: 'bool' = False, max_seq_items: 'int | None' = None) -> 'str': This function is the sanctioned way of converting objects to a string representation and properly handles nested sequences."}
{"text_id": 1006696, "text": "pprint_thing(thing: 'Any', _nest_lvl: 'int' = 0, escape_chars: 'EscapeChars | None' = None, default_escapes: 'bool' = False, quote_strings: 'bool' = False, max_seq_items: 'int | None' = None) -> 'str': This function is the sanctioned way of converting objects to a string representation and properly handles nested sequences."}
{"text_id": 1006697, "text": "pprint_thing(thing: 'Any', _nest_lvl: 'int' = 0, escape_chars: 'EscapeChars | None' = None, default_escapes: 'bool' = False, quote_strings: 'bool' = False, max_seq_items: 'int | None' = None) -> 'str': This function is the sanctioned way of converting objects to a string representation and properly handles nested sequences."}
{"text_id": 1006698, "text": "validate_ascending(ascending: 'bool | int | Sequence[bool | int]' = True): Validate ``ascending`` kwargs for ``sort_index`` method."}
{"text_id": 1006699, "text": "validate_fillna_kwargs(value, method, validate_scalar_dict_value=True): Validate the keyword arguments to 'fillna'."}
{"text_id": 1006700, "text": "GroupBy(*args, **kwds): Class for grouping and aggregating relational data."}
{"text_id": 1006701, "text": "check_setitem_lengths(indexer, value, values) -> 'bool': Validate that value and indexer are the same length."}
{"text_id": 1006702, "text": "deprecate_ndim_indexing(result, stacklevel: 'int' = 3): Helper function to raise the deprecation warning for multi-dimensional indexing on 1D Series/Index."}
{"text_id": 1006703, "text": "deprecate_ndim_indexing(result, stacklevel: 'int' = 3): Helper function to raise the deprecation warning for multi-dimensional indexing on 1D Series/Index."}
{"text_id": 1006704, "text": "is_empty_indexer(indexer, arr_value: 'np.ndarray') -> 'bool': Check if we have an empty indexer."}
{"text_id": 1006705, "text": "is_empty_indexer(indexer, arr_value: 'np.ndarray') -> 'bool': Check if we have an empty indexer."}
{"text_id": 1006706, "text": "is_exact_shape_match(target: 'ArrayLike', value: 'ArrayLike') -> 'bool': Is setting this value into this target overwriting the entire column?."}
{"text_id": 1006707, "text": "is_exact_shape_match(target: 'ArrayLike', value: 'ArrayLike') -> 'bool': Is setting this value into this target overwriting the entire column?."}
{"text_id": 1006708, "text": "is_list_like_indexer(key) -> 'bool': Check if we have a list-like indexer that is *not* a NamedTuple."}
{"text_id": 1006709, "text": "is_list_like_indexer(key) -> 'bool': Check if we have a list-like indexer that is *not* a NamedTuple."}
{"text_id": 1006710, "text": "is_scalar_indexer(indexer, ndim: 'int') -> 'bool': Return True if we are all scalar indexers."}
{"text_id": 1006711, "text": "is_valid_positional_slice(slc: 'slice') -> 'bool': Check if a slice object can be interpreted as a positional indexer."}
{"text_id": 1006712, "text": "length_of_indexer(indexer, target=None) -> 'int': Return the expected length of target[indexer]."}
{"text_id": 1006713, "text": "length_of_indexer(indexer, target=None) -> 'int': Return the expected length of target[indexer]."}
{"text_id": 1006714, "text": "maybe_convert_indices(indices, n: 'int', verify: 'bool' = True): Attempt to convert indices into valid, positive indices."}
{"text_id": 1006715, "text": "unpack_1tuple(tup): If we have a length-1 tuple/list that contains a slice, unpack to just the slice."}
{"text_id": 1006716, "text": "unpack_1tuple(tup): If we have a length-1 tuple/list that contains a slice, unpack to just the slice."}
{"text_id": 1006717, "text": "IndexingMixin(): Mixin for adding."}
{"text_id": 1006718, "text": "concat_compat(to_concat, axis: int = 0, ea_compat_axis: bool = False): provide concatenation of an array of arrays each of which is a single 'normalized' dtypes (in that for example, if it's object, then it is a non-datetimelike and provide a combined dtype for the resulting array that preserves the overall dtype if possible)."}
{"text_id": 1006719, "text": "convert_from_missing_indexer_tuple(indexer, axes): Create a filtered indexer that doesn't have any missing indexers."}
{"text_id": 1006720, "text": "convert_missing_indexer(indexer): Reverse convert a missing indexer, which is a dict return the scalar indexer and a boolean indicating if we converted."}
{"text_id": 1006721, "text": "infer_fill_value(val): infer the fill value for the nan/NaT from the provided scalar/ndarray/list-like if we are a NaT, return the correct dtyped element to provide proper block construction."}
{"text_id": 1006722, "text": "is_label_like(key) -> 'bool': ."}
{"text_id": 1006723, "text": "is_nested_tuple(tup, labels) -> 'bool': ."}
{"text_id": 1006724, "text": "maybe_convert_ix(*args): We likely want to take the cross-product."}
{"text_id": 1006725, "text": "need_slice(obj: 'slice') -> 'bool': ."}
{"text_id": 1006726, "text": "suppress(*exceptions): Context manager to suppress specified exceptions After the exception is suppressed, execution proceeds with the next statement following the with statement."}
{"text_id": 1006727, "text": "suppress(*exceptions): Context manager to suppress specified exceptions After the exception is suppressed, execution proceeds with the next statement following the with statement."}
{"text_id": 1006728, "text": "Block(): Canonical n-dimensional unit of homogeneous dtype contained in a pandas data structure Index-ignorant; let the container take care of that."}
{"text_id": 1006729, "text": "SingleBlockManager(block: 'Block', axis: 'Index', verify_integrity: 'bool' = False, fastpath=<no_default>): manage a single block with."}
{"text_id": 1006730, "text": "SingleBlockManager(block: 'Block', axis: 'Index', verify_integrity: 'bool' = False, fastpath=<no_default>): manage a single block with."}
{"text_id": 1006731, "text": "concatenate_managers(mgrs_indexers, axes: 'list[Index]', concat_axis: 'int', copy: 'bool') -> 'Manager': Concatenate block managers into one."}
{"text_id": 1006732, "text": "make_block(values, placement, klass=None, ndim=None, dtype: 'Dtype | None' = None) -> 'Block': This is a pseudo-public analogue to blocks."}
{"text_id": 1006733, "text": "check_value_size(value, mask: 'np.ndarray', length: 'int'): Validate the size of the values passed to ExtensionArray."}
{"text_id": 1006734, "text": "infer_dtype_from(val, pandas_dtype: 'bool' = False) -> 'tuple[DtypeObj, Any]': Interpret the dtype from a scalar or array."}
{"text_id": 1006735, "text": "interpolate_1d(xvalues: 'Index', yvalues: 'np.ndarray', method: 'str | None' = 'linear', limit: 'int | None' = None, limit_direction: 'str' = 'forward', limit_area: 'str | None' = None, fill_value: 'Any | None' = None, bounds_error: 'bool' = False, order: 'int | None' = None, **kwargs): Logic for the 1-d interpolation."}
{"text_id": 1006736, "text": "interpolate_2d(values, method: 'str' = 'pad', axis: 'Axis' = 0, limit: 'int | None' = None, limit_area: 'str | None' = None): Perform an actual interpolation of values, values will be make 2-d if needed fills inplace, returns the result."}
{"text_id": 1006737, "text": "interpolate_2d_with_fill(data: 'np.ndarray', index: 'Index', axis: 'int', method: 'str' = 'linear', limit: 'int | None' = None, limit_direction: 'str' = 'forward', limit_area: 'str | None' = None, fill_value: 'Any | None' = None, **kwargs) -> 'np.ndarray': Column-wise application of interpolate_1d."}
{"text_id": 1006738, "text": "interpolate_array_2d(data: 'np.ndarray', method: 'str' = 'pad', axis: 'int' = 0, index: 'Index | None' = None, limit: 'int | None' = None, limit_direction: 'str' = 'forward', limit_area: 'str | None' = None, fill_value: 'Any | None' = None, coerce: 'bool' = False, downcast: 'str | None' = None, **kwargs): Wrapper to dispatch to either interpolate_2d or interpolate_2d_with_fill."}
{"text_id": 1006739, "text": "is_numeric_v_string_like(a: 'ArrayLike', b): Check if we are comparing a string-like object to a numeric ndarray."}
{"text_id": 1006740, "text": "is_valid_na_for_dtype(obj, dtype: Union[numpy.dtype, ForwardRef('ExtensionDtype')]) -> bool: isna check that excludes incompatible dtypes."}
{"text_id": 1006741, "text": "mask_missing(arr: 'ArrayLike', values_to_mask) -> 'np.ndarray': Return a masking array of same size/shape as arr with entries equaling any member of values_to_mask set to True."}
{"text_id": 1006742, "text": "NaTType(): (N)ot-(A)-(T)ime, the time equivalent of NaN."}
{"text_id": 1006743, "text": "check_below_min_count(shape: 'tuple[int, ...]', mask: 'np.ndarray | None', min_count: 'int') -> 'bool': Check for the `min_count` keyword."}
{"text_id": 1006744, "text": "get_dtype(arr_or_dtype) -> 'DtypeObj': Get the dtype instance associated with an array or dtype object."}
{"text_id": 1006745, "text": "get_empty_reduction_result(shape: 'tuple[int, ...]', axis: 'int', dtype: 'np.dtype | type[np.floating]', fill_value: 'Any') -> 'np.ndarray': The result from a reduction on an empty ndarray."}
{"text_id": 1006746, "text": "is_any_int_dtype(arr_or_dtype) -> 'bool': Check whether the provided array or dtype is of an integer dtype."}
{"text_id": 1006747, "text": "na_accum_func(values: 'ArrayLike', accum_func, *, skipna: 'bool') -> 'ArrayLike': Cumulative function with skipna support."}
{"text_id": 1006748, "text": "nanall(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, mask: 'np.ndarray | None' = None) -> 'bool': Check if all elements along an axis evaluate to True."}
{"text_id": 1006749, "text": "nanany(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, mask: 'np.ndarray | None' = None) -> 'bool': Check if any elements along an axis evaluate to True."}
{"text_id": 1006750, "text": "nanargmax(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, mask: 'np.ndarray | None' = None) -> 'int | np.ndarray': ."}
{"text_id": 1006751, "text": "nanargmin(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, mask: 'np.ndarray | None' = None) -> 'int | np.ndarray': ."}
{"text_id": 1006752, "text": "nancorr(a: 'np.ndarray', b: 'np.ndarray', *, method='pearson', min_periods: 'int | None' = None): a, b: ndarrays."}
{"text_id": 1006753, "text": "nankurt(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, mask: 'np.ndarray | None' = None) -> 'float': Compute the sample excess kurtosis The statistic computed here is the adjusted Fisher-Pearson standardized moment coefficient G2, computed directly from the second and fourth central moment."}
{"text_id": 1006754, "text": "nanmean(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, mask: 'np.ndarray | None' = None) -> 'float': Compute the mean of the element along an axis ignoring NaNs."}
{"text_id": 1006755, "text": "nanmedian(values, *, axis=None, skipna=True, mask=None): ."}
{"text_id": 1006756, "text": "nanpercentile(values: 'np.ndarray', q: 'np.ndarray', *, na_value, mask: 'np.ndarray', interpolation): Wrapper for np."}
{"text_id": 1006757, "text": "nanprod(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, min_count: 'int' = 0, mask: 'np.ndarray | None' = None) -> 'float': ."}
{"text_id": 1006758, "text": "nansem(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, ddof: 'int' = 1, mask: 'np.ndarray | None' = None) -> 'float': Compute the standard error in the mean along given axis while ignoring NaNs."}
{"text_id": 1006759, "text": "nanskew(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, mask: 'np.ndarray | None' = None) -> 'float': Compute the sample skewness."}
{"text_id": 1006760, "text": "nanstd(values, *, axis=None, skipna=True, ddof=1, mask=None): Compute the standard deviation along given axis while ignoring NaNs."}
{"text_id": 1006761, "text": "nansum(values: 'np.ndarray', *, axis: 'int | None' = None, skipna: 'bool' = True, min_count: 'int' = 0, mask: 'np.ndarray | None' = None) -> 'float': Sum the elements along an axis ignoring NaNs."}
{"text_id": 1006762, "text": "nanvar(values, *, axis=None, skipna=True, ddof=1, mask=None): Compute the variance along given axis while ignoring NaNs."}
{"text_id": 1006763, "text": "add_flex_arithmetic_methods(cls): Adds the full suite of flex arithmetic methods (``pow``, ``mul``, ``add``) to the class."}
{"text_id": 1006764, "text": "align_method_SERIES(left: 'Series', right, align_asobject: 'bool' = False): align lhs and rhs Series."}
{"text_id": 1006765, "text": "arithmetic_op(left: Union[ForwardRef('ExtensionArray'), numpy.ndarray], right: Any, op): Evaluate an arithmetic operation `+`, `-`, `*`, `/`, `//`, `%`, `**`,."}
{"text_id": 1006766, "text": "comparison_op(left: Union[ForwardRef('ExtensionArray'), numpy.ndarray], right: Any, op) -> Union[ForwardRef('ExtensionArray'), numpy.ndarray]: Evaluate a comparison operation `=`, `!=`, `>=`, `>`, `<=`, or `<`."}
{"text_id": 1006767, "text": "fill_binop(left, right, fill_value): If a non-None fill_value is given, replace null entries in left and right with this value, but only in positions where _one_ of left/right is null, not both."}
{"text_id": 1006768, "text": "frame_arith_method_with_reindex(left: 'DataFrame', right: 'DataFrame', op) -> 'DataFrame': For DataFrame-with-DataFrame operations that require reindexing, operate only on shared columns, then reindex."}
{"text_id": 1006769, "text": "get_array_op(op): Return a binary array operation corresponding to the given operator op."}
{"text_id": 1006770, "text": "get_op_result_name(left, right): Find the appropriate name to pin to an operation result."}
{"text_id": 1006771, "text": "invalid_comparison(left, right, op): If a comparison has mismatched types and is not necessarily meaningful, follow python3 conventions by: - returning all-False for equality - returning all-True for inequality - raising TypeError otherwise."}
{"text_id": 1006772, "text": "kleene_and(left: 'bool | libmissing.NAType | np.ndarray', right: 'bool | libmissing.NAType | np.ndarray', left_mask: 'np.ndarray | None', right_mask: 'np.ndarray | None'): Boolean ``and`` using Kleene logic."}
{"text_id": 1006773, "text": "kleene_or(left: 'bool | np.ndarray', right: 'bool | np.ndarray', left_mask: 'np.ndarray | None', right_mask: 'np.ndarray | None'): Boolean ``or`` using Kleene logic."}
{"text_id": 1006774, "text": "kleene_xor(left: 'bool | np.ndarray', right: 'bool | np.ndarray', left_mask: 'np.ndarray | None', right_mask: 'np.ndarray | None'): Boolean ``xor`` using Kleene logic."}
{"text_id": 1006775, "text": "logical_op(left: Union[ForwardRef('ExtensionArray'), numpy.ndarray], right: Any, op) -> Union[ForwardRef('ExtensionArray'), numpy.ndarray]: Evaluate a logical operation `|`, `&`, or `^`."}
{"text_id": 1006776, "text": "make_flex_doc(op_name: 'str', typ: 'str') -> 'str': Make the appropriate substitutions for the given operation and class-typ into either _flex_doc_SERIES or _flex_doc_FRAME to return the docstring to attach to a generated method."}
{"text_id": 1006777, "text": "maybe_prepare_scalar_for_op(obj, shape: Tuple[int, ...]): Cast non-pandas objects to pandas types to unify behavior of arithmetic and comparison operations."}
{"text_id": 1006778, "text": "should_reindex_frame_op(left: 'DataFrame', right, op, axis, default_axis, fill_value, level) -> 'bool': Check if this is an operation between DataFrames that will need to reindex."}
{"text_id": 1006779, "text": "CategoricalAccessor(data): Accessor object for categorical properties of the Series values."}
{"text_id": 1006780, "text": "SingleManager(*args, **kwargs): The central part of internal API."}
{"text_id": 1006781, "text": "SparseAccessor(data=None): Accessor for SparseSparse from other sparse matrix data types."}
{"text_id": 1006782, "text": "StringMethods(data): Vectorized string functions for Series and Index."}
{"text_id": 1006783, "text": "StringMethods(data): Vectorized string functions for Series and Index."}
{"text_id": 1006784, "text": "ensure_key_mapped(values, key: 'Callable | None', levels=None): Applies a callable key function to the values function and checks that the resulting value has the same shape."}
{"text_id": 1006785, "text": "ensure_key_mapped(values, key: 'Callable | None', levels=None): Applies a callable key function to the values function and checks that the resulting value has the same shape."}
{"text_id": 1006786, "text": "get_terminal_size(fallback=(80, 24)): Get the size of the terminal window."}
{"text_id": 1006787, "text": "maybe_cast_pointwise_result(result: 'ArrayLike', dtype: 'DtypeObj', numeric_only: 'bool' = False, same_dtype: 'bool' = True) -> 'ArrayLike': Try casting result of a pointwise operation back to the original dtype if appropriate."}
{"text_id": 1006788, "text": "validate_all_hashable(*args, error_name: 'Optional[str]' = None) -> 'None': Return None if all args are hashable, else raise a TypeError."}
{"text_id": 1006789, "text": "compress_group_index(group_index: 'np.ndarray', sort: 'bool' = True) -> 'tuple[np.ndarray, np.ndarray]': Group_index is offsets into cartesian product of all possible labels."}
{"text_id": 1006790, "text": "decons_obs_group_ids(comp_ids: 'np.ndarray', obs_ids, shape, labels, xnull: 'bool'): Reconstruct labels from observed group ids."}
{"text_id": 1006791, "text": "get_compressed_ids(labels, sizes: 'Shape') -> 'tuple[np.ndarray, np.ndarray]': Group_index is offsets into cartesian product of all possible labels."}
{"text_id": 1006792, "text": "get_flattened_list(comp_ids: 'np.ndarray', ngroups: 'int', levels: 'Iterable[Index]', labels: 'Iterable[np.ndarray]') -> 'list[tuple]': Map compressed group id -> key tuple."}
{"text_id": 1006793, "text": "get_group_index_sorter(group_index: 'np.ndarray', ngroups: 'int | None' = None) -> 'np.ndarray': algos."}
{"text_id": 1006794, "text": "get_indexer_dict(label_list: 'list[np.ndarray]', keys: 'list[Index]') -> 'dict[str | tuple, np.ndarray]': ."}
{"text_id": 1006795, "text": "nargminmax(values, method: 'str', axis: 'int' = 0): Implementation of np."}
{"text_id": 1006796, "text": "BaseStringArrayMethods(): Base class for extension arrays implementing string methods."}
{"text_id": 1006797, "text": "ExpandingGroupby(*args, **kwds): Provide a expanding groupby implementation."}
{"text_id": 1006798, "text": "ExponentialMovingWindowGroupby(*args, **kwds): Provide an exponential moving window groupby implementation."}
{"text_id": 1006799, "text": "RollingGroupby(*args, **kwds): Provide a rolling groupby implementation."}
{"text_id": 1006800, "text": "crosstab(index, columns, values=None, rownames=None, colnames=None, aggfunc=None, margins=False, margins_name: 'str' = 'All', dropna: 'bool' = True, normalize=False) -> 'DataFrame': Compute a simple cross tabulation of two (or more) factors."}
{"text_id": 1006801, "text": "crosstab(index, columns, values=None, rownames=None, colnames=None, aggfunc=None, margins=False, margins_name: 'str' = 'All', dropna: 'bool' = True, normalize=False) -> 'DataFrame': Compute a simple cross tabulation of two (or more) factors."}
{"text_id": 1006802, "text": "crosstab(index, columns, values=None, rownames=None, colnames=None, aggfunc=None, margins=False, margins_name: 'str' = 'All', dropna: 'bool' = True, normalize=False) -> 'DataFrame': Compute a simple cross tabulation of two (or more) factors."}
{"text_id": 1006803, "text": "cut(x, bins, right: bool = True, labels=None, retbins: bool = False, precision: int = 3, include_lowest: bool = False, duplicates: str = 'raise', ordered: bool = True): Bin values into discrete intervals."}
{"text_id": 1006804, "text": "cut(x, bins, right: bool = True, labels=None, retbins: bool = False, precision: int = 3, include_lowest: bool = False, duplicates: str = 'raise', ordered: bool = True): Bin values into discrete intervals."}
{"text_id": 1006805, "text": "cut(x, bins, right: bool = True, labels=None, retbins: bool = False, precision: int = 3, include_lowest: bool = False, duplicates: str = 'raise', ordered: bool = True): Bin values into discrete intervals."}
{"text_id": 1006806, "text": "describe_option(*args, **kwds): describe_option(pat, _print_desc=False) Prints the description for one or more registered options."}
{"text_id": 1006807, "text": "describe_option(*args, **kwds): describe_option(pat, _print_desc=False) Prints the description for one or more registered options."}
{"text_id": 1006808, "text": "describe_option(*args, **kwds): describe_option(pat, _print_desc=False) Prints the description for one or more registered options."}
{"text_id": 1006809, "text": "infer_freq(index, warn: 'bool' = True) -> 'str | None': Infer the most likely frequency given the input index."}
{"text_id": 1006810, "text": "infer_freq(index, warn: 'bool' = True) -> 'str | None': Infer the most likely frequency given the input index."}
{"text_id": 1006811, "text": "infer_freq(index, warn: 'bool' = True) -> 'str | None': Infer the most likely frequency given the input index."}
{"text_id": 1006812, "text": "infer_freq(index, warn: 'bool' = True) -> 'str | None': Infer the most likely frequency given the input index."}
{"text_id": 1006813, "text": "infer_freq(index, warn: 'bool' = True) -> 'str | None': Infer the most likely frequency given the input index."}
{"text_id": 1006814, "text": "read_clipboard(sep='\\\\s+', **kwargs): Read text from clipboard and pass to read_csv."}
{"text_id": 1006815, "text": "read_clipboard(sep='\\\\s+', **kwargs): Read text from clipboard and pass to read_csv."}
{"text_id": 1006816, "text": "read_clipboard(sep='\\\\s+', **kwargs): Read text from clipboard and pass to read_csv."}
{"text_id": 1006817, "text": "read_clipboard(sep='\\\\s+', **kwargs): Read text from clipboard and pass to read_csv."}
{"text_id": 1006818, "text": "read_clipboard(sep='\\\\s+', **kwargs): Read text from clipboard and pass to read_csv."}
{"text_id": 1006819, "text": "read_csv(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None): Read a comma-separated values (csv) file into DataFrame."}
{"text_id": 1006820, "text": "read_csv(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None): Read a comma-separated values (csv) file into DataFrame."}
{"text_id": 1006821, "text": "read_csv(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None): Read a comma-separated values (csv) file into DataFrame."}
{"text_id": 1006822, "text": "read_csv(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None): Read a comma-separated values (csv) file into DataFrame."}
{"text_id": 1006823, "text": "read_csv(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors: 'str | None' = 'strict', dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options: 'StorageOptions' = None): Read a comma-separated values (csv) file into DataFrame."}
{"text_id": 1006824, "text": "read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options: 'StorageOptions' = None): Read an Excel file into a pandas DataFrame."}
{"text_id": 1006825, "text": "read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options: 'StorageOptions' = None): Read an Excel file into a pandas DataFrame."}
{"text_id": 1006826, "text": "read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options: 'StorageOptions' = None): Read an Excel file into a pandas DataFrame."}
{"text_id": 1006827, "text": "read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options: 'StorageOptions' = None): Read an Excel file into a pandas DataFrame."}
{"text_id": 1006828, "text": "read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options: 'StorageOptions' = None): Read an Excel file into a pandas DataFrame."}
{"text_id": 1006829, "text": "read_feather(path, columns=None, use_threads: bool = True, storage_options: Union[Dict[str, Any], NoneType] = None): Load a feather-format object from the file path."}
{"text_id": 1006830, "text": "read_feather(path, columns=None, use_threads: bool = True, storage_options: Union[Dict[str, Any], NoneType] = None): Load a feather-format object from the file path."}
{"text_id": 1006831, "text": "read_feather(path, columns=None, use_threads: bool = True, storage_options: Union[Dict[str, Any], NoneType] = None): Load a feather-format object from the file path."}
{"text_id": 1006832, "text": "read_feather(path, columns=None, use_threads: bool = True, storage_options: Union[Dict[str, Any], NoneType] = None): Load a feather-format object from the file path."}
{"text_id": 1006833, "text": "read_feather(path, columns=None, use_threads: bool = True, storage_options: Union[Dict[str, Any], NoneType] = None): Load a feather-format object from the file path."}
{"text_id": 1006834, "text": "read_fwf(filepath_or_buffer: 'FilePathOrBuffer', colspecs='infer', widths=None, infer_nrows=100, **kwds): Read a table of fixed-width formatted lines into DataFrame."}
{"text_id": 1006835, "text": "read_fwf(filepath_or_buffer: 'FilePathOrBuffer', colspecs='infer', widths=None, infer_nrows=100, **kwds): Read a table of fixed-width formatted lines into DataFrame."}
{"text_id": 1006836, "text": "read_fwf(filepath_or_buffer: 'FilePathOrBuffer', colspecs='infer', widths=None, infer_nrows=100, **kwds): Read a table of fixed-width formatted lines into DataFrame."}
{"text_id": 1006837, "text": "read_fwf(filepath_or_buffer: 'FilePathOrBuffer', colspecs='infer', widths=None, infer_nrows=100, **kwds): Read a table of fixed-width formatted lines into DataFrame."}
{"text_id": 1006838, "text": "read_fwf(filepath_or_buffer: 'FilePathOrBuffer', colspecs='infer', widths=None, infer_nrows=100, **kwds): Read a table of fixed-width formatted lines into DataFrame."}
{"text_id": 1006839, "text": "read_gbq(query: 'str', project_id: 'str | None' = None, index_col: 'str | None' = None, col_order: 'list[str] | None' = None, reauth: 'bool' = False, auth_local_webserver: 'bool' = False, dialect: 'str | None' = None, location: 'str | None' = None, configuration: 'dict[str, Any] | None' = None, credentials=None, use_bqstorage_api: 'bool | None' = None, max_results: 'int | None' = None, progress_bar_type: 'str | None' = None) -> 'DataFrame': Load data from Google BigQuery."}
{"text_id": 1006840, "text": "read_gbq(query: 'str', project_id: 'str | None' = None, index_col: 'str | None' = None, col_order: 'list[str] | None' = None, reauth: 'bool' = False, auth_local_webserver: 'bool' = False, dialect: 'str | None' = None, location: 'str | None' = None, configuration: 'dict[str, Any] | None' = None, credentials=None, use_bqstorage_api: 'bool | None' = None, max_results: 'int | None' = None, progress_bar_type: 'str | None' = None) -> 'DataFrame': Load data from Google BigQuery."}
{"text_id": 1006841, "text": "read_gbq(query: 'str', project_id: 'str | None' = None, index_col: 'str | None' = None, col_order: 'list[str] | None' = None, reauth: 'bool' = False, auth_local_webserver: 'bool' = False, dialect: 'str | None' = None, location: 'str | None' = None, configuration: 'dict[str, Any] | None' = None, credentials=None, use_bqstorage_api: 'bool | None' = None, max_results: 'int | None' = None, progress_bar_type: 'str | None' = None) -> 'DataFrame': Load data from Google BigQuery."}
{"text_id": 1006842, "text": "read_gbq(query: 'str', project_id: 'str | None' = None, index_col: 'str | None' = None, col_order: 'list[str] | None' = None, reauth: 'bool' = False, auth_local_webserver: 'bool' = False, dialect: 'str | None' = None, location: 'str | None' = None, configuration: 'dict[str, Any] | None' = None, credentials=None, use_bqstorage_api: 'bool | None' = None, max_results: 'int | None' = None, progress_bar_type: 'str | None' = None) -> 'DataFrame': Load data from Google BigQuery."}
{"text_id": 1006843, "text": "read_gbq(query: 'str', project_id: 'str | None' = None, index_col: 'str | None' = None, col_order: 'list[str] | None' = None, reauth: 'bool' = False, auth_local_webserver: 'bool' = False, dialect: 'str | None' = None, location: 'str | None' = None, configuration: 'dict[str, Any] | None' = None, credentials=None, use_bqstorage_api: 'bool | None' = None, max_results: 'int | None' = None, progress_bar_type: 'str | None' = None) -> 'DataFrame': Load data from Google BigQuery."}
{"text_id": 1006844, "text": "read_hdf(path_or_buf, key=None, mode: 'str' = 'r', errors: 'str' = 'strict', where=None, start: 'int | None' = None, stop: 'int | None' = None, columns=None, iterator=False, chunksize: 'int | None' = None, **kwargs): Read from the store, close it if we opened it."}
{"text_id": 1006845, "text": "read_hdf(path_or_buf, key=None, mode: 'str' = 'r', errors: 'str' = 'strict', where=None, start: 'int | None' = None, stop: 'int | None' = None, columns=None, iterator=False, chunksize: 'int | None' = None, **kwargs): Read from the store, close it if we opened it."}
{"text_id": 1006846, "text": "read_hdf(path_or_buf, key=None, mode: 'str' = 'r', errors: 'str' = 'strict', where=None, start: 'int | None' = None, stop: 'int | None' = None, columns=None, iterator=False, chunksize: 'int | None' = None, **kwargs): Read from the store, close it if we opened it."}
{"text_id": 1006847, "text": "read_hdf(path_or_buf, key=None, mode: 'str' = 'r', errors: 'str' = 'strict', where=None, start: 'int | None' = None, stop: 'int | None' = None, columns=None, iterator=False, chunksize: 'int | None' = None, **kwargs): Read from the store, close it if we opened it."}
{"text_id": 1006848, "text": "read_hdf(path_or_buf, key=None, mode: 'str' = 'r', errors: 'str' = 'strict', where=None, start: 'int | None' = None, stop: 'int | None' = None, columns=None, iterator=False, chunksize: 'int | None' = None, **kwargs): Read from the store, close it if we opened it."}
{"text_id": 1006849, "text": "read_html(io: 'FilePathOrBuffer', match: 'str | Pattern' = '.+', flavor: 'str | None' = None, header: 'int | Sequence[int] | None' = None, index_col: 'int | Sequence[int] | None' = None, skiprows: 'int | Sequence[int] | slice | None' = None, attrs: 'dict[str, str] | None' = None, parse_dates: 'bool' = False, thousands: 'str | None' = ',', encoding: 'str | None' = None, decimal: 'str' = '.', converters: 'dict | None' = None, na_values=None, keep_default_na: 'bool' = True, displayed_only: 'bool' = True) -> 'list[DataFrame]': Read HTML tables into a ``list`` of ``DataFrame`` objects."}
{"text_id": 1006850, "text": "read_html(io: 'FilePathOrBuffer', match: 'str | Pattern' = '.+', flavor: 'str | None' = None, header: 'int | Sequence[int] | None' = None, index_col: 'int | Sequence[int] | None' = None, skiprows: 'int | Sequence[int] | slice | None' = None, attrs: 'dict[str, str] | None' = None, parse_dates: 'bool' = False, thousands: 'str | None' = ',', encoding: 'str | None' = None, decimal: 'str' = '.', converters: 'dict | None' = None, na_values=None, keep_default_na: 'bool' = True, displayed_only: 'bool' = True) -> 'list[DataFrame]': Read HTML tables into a ``list`` of ``DataFrame`` objects."}
{"text_id": 1006851, "text": "read_html(io: 'FilePathOrBuffer', match: 'str | Pattern' = '.+', flavor: 'str | None' = None, header: 'int | Sequence[int] | None' = None, index_col: 'int | Sequence[int] | None' = None, skiprows: 'int | Sequence[int] | slice | None' = None, attrs: 'dict[str, str] | None' = None, parse_dates: 'bool' = False, thousands: 'str | None' = ',', encoding: 'str | None' = None, decimal: 'str' = '.', converters: 'dict | None' = None, na_values=None, keep_default_na: 'bool' = True, displayed_only: 'bool' = True) -> 'list[DataFrame]': Read HTML tables into a ``list`` of ``DataFrame`` objects."}
{"text_id": 1006852, "text": "read_html(io: 'FilePathOrBuffer', match: 'str | Pattern' = '.+', flavor: 'str | None' = None, header: 'int | Sequence[int] | None' = None, index_col: 'int | Sequence[int] | None' = None, skiprows: 'int | Sequence[int] | slice | None' = None, attrs: 'dict[str, str] | None' = None, parse_dates: 'bool' = False, thousands: 'str | None' = ',', encoding: 'str | None' = None, decimal: 'str' = '.', converters: 'dict | None' = None, na_values=None, keep_default_na: 'bool' = True, displayed_only: 'bool' = True) -> 'list[DataFrame]': Read HTML tables into a ``list`` of ``DataFrame`` objects."}
{"text_id": 1006853, "text": "read_html(io: 'FilePathOrBuffer', match: 'str | Pattern' = '.+', flavor: 'str | None' = None, header: 'int | Sequence[int] | None' = None, index_col: 'int | Sequence[int] | None' = None, skiprows: 'int | Sequence[int] | slice | None' = None, attrs: 'dict[str, str] | None' = None, parse_dates: 'bool' = False, thousands: 'str | None' = ',', encoding: 'str | None' = None, decimal: 'str' = '.', converters: 'dict | None' = None, na_values=None, keep_default_na: 'bool' = True, displayed_only: 'bool' = True) -> 'list[DataFrame]': Read HTML tables into a ``list`` of ``DataFrame`` objects."}
{"text_id": 1006854, "text": "read_json(path_or_buf=None, orient=None, typ='frame', dtype: 'DtypeArg | None' = None, convert_axes=None, convert_dates=True, keep_default_dates: 'bool' = True, numpy: 'bool' = False, precise_float: 'bool' = False, date_unit=None, encoding=None, encoding_errors: 'str | None' = 'strict', lines: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', nrows: 'int | None' = None, storage_options: 'StorageOptions' = None): Convert a JSON string to pandas object."}
{"text_id": 1006855, "text": "read_json(path_or_buf=None, orient=None, typ='frame', dtype: 'DtypeArg | None' = None, convert_axes=None, convert_dates=True, keep_default_dates: 'bool' = True, numpy: 'bool' = False, precise_float: 'bool' = False, date_unit=None, encoding=None, encoding_errors: 'str | None' = 'strict', lines: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', nrows: 'int | None' = None, storage_options: 'StorageOptions' = None): Convert a JSON string to pandas object."}
{"text_id": 1006856, "text": "read_json(path_or_buf=None, orient=None, typ='frame', dtype: 'DtypeArg | None' = None, convert_axes=None, convert_dates=True, keep_default_dates: 'bool' = True, numpy: 'bool' = False, precise_float: 'bool' = False, date_unit=None, encoding=None, encoding_errors: 'str | None' = 'strict', lines: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', nrows: 'int | None' = None, storage_options: 'StorageOptions' = None): Convert a JSON string to pandas object."}
{"text_id": 1006857, "text": "read_json(path_or_buf=None, orient=None, typ='frame', dtype: 'DtypeArg | None' = None, convert_axes=None, convert_dates=True, keep_default_dates: 'bool' = True, numpy: 'bool' = False, precise_float: 'bool' = False, date_unit=None, encoding=None, encoding_errors: 'str | None' = 'strict', lines: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', nrows: 'int | None' = None, storage_options: 'StorageOptions' = None): Convert a JSON string to pandas object."}
{"text_id": 1006858, "text": "read_json(path_or_buf=None, orient=None, typ='frame', dtype: 'DtypeArg | None' = None, convert_axes=None, convert_dates=True, keep_default_dates: 'bool' = True, numpy: 'bool' = False, precise_float: 'bool' = False, date_unit=None, encoding=None, encoding_errors: 'str | None' = 'strict', lines: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', nrows: 'int | None' = None, storage_options: 'StorageOptions' = None): Convert a JSON string to pandas object."}
{"text_id": 1006859, "text": "read_orc(path: 'FilePathOrBuffer', columns: 'list[str] | None' = None, **kwargs) -> 'DataFrame': Load an ORC object from the file path, returning a DataFrame."}
{"text_id": 1006860, "text": "read_orc(path: 'FilePathOrBuffer', columns: 'list[str] | None' = None, **kwargs) -> 'DataFrame': Load an ORC object from the file path, returning a DataFrame."}
{"text_id": 1006861, "text": "read_orc(path: 'FilePathOrBuffer', columns: 'list[str] | None' = None, **kwargs) -> 'DataFrame': Load an ORC object from the file path, returning a DataFrame."}
{"text_id": 1006862, "text": "read_orc(path: 'FilePathOrBuffer', columns: 'list[str] | None' = None, **kwargs) -> 'DataFrame': Load an ORC object from the file path, returning a DataFrame."}
{"text_id": 1006863, "text": "read_orc(path: 'FilePathOrBuffer', columns: 'list[str] | None' = None, **kwargs) -> 'DataFrame': Load an ORC object from the file path, returning a DataFrame."}
{"text_id": 1006864, "text": "read_parquet(path, engine: 'str' = 'auto', columns=None, storage_options: 'StorageOptions' = None, use_nullable_dtypes: 'bool' = False, **kwargs): Load a parquet object from the file path, returning a DataFrame."}
{"text_id": 1006865, "text": "read_parquet(path, engine: 'str' = 'auto', columns=None, storage_options: 'StorageOptions' = None, use_nullable_dtypes: 'bool' = False, **kwargs): Load a parquet object from the file path, returning a DataFrame."}
{"text_id": 1006866, "text": "read_parquet(path, engine: 'str' = 'auto', columns=None, storage_options: 'StorageOptions' = None, use_nullable_dtypes: 'bool' = False, **kwargs): Load a parquet object from the file path, returning a DataFrame."}
{"text_id": 1006867, "text": "read_parquet(path, engine: 'str' = 'auto', columns=None, storage_options: 'StorageOptions' = None, use_nullable_dtypes: 'bool' = False, **kwargs): Load a parquet object from the file path, returning a DataFrame."}
{"text_id": 1006868, "text": "read_parquet(path, engine: 'str' = 'auto', columns=None, storage_options: 'StorageOptions' = None, use_nullable_dtypes: 'bool' = False, **kwargs): Load a parquet object from the file path, returning a DataFrame."}
{"text_id": 1006869, "text": "read_pickle(filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', storage_options: Union[Dict[str, Any], NoneType] = None): Load pickled pandas object (or any object) from file."}
{"text_id": 1006870, "text": "read_pickle(filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', storage_options: Union[Dict[str, Any], NoneType] = None): Load pickled pandas object (or any object) from file."}
{"text_id": 1006871, "text": "read_pickle(filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', storage_options: Union[Dict[str, Any], NoneType] = None): Load pickled pandas object (or any object) from file."}
{"text_id": 1006872, "text": "read_pickle(filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', storage_options: Union[Dict[str, Any], NoneType] = None): Load pickled pandas object (or any object) from file."}
{"text_id": 1006873, "text": "read_pickle(filepath_or_buffer: Union[ForwardRef('PathLike[str]'), str, IO[~AnyStr], io.RawIOBase, io.BufferedIOBase, io.TextIOBase, _io.TextIOWrapper, mmap.mmap], compression: Union[str, Dict[str, Any], NoneType] = 'infer', storage_options: Union[Dict[str, Any], NoneType] = None): Load pickled pandas object (or any object) from file."}
{"text_id": 1006874, "text": "read_sas(filepath_or_buffer: 'FilePathOrBuffer', format: 'str | None' = None, index: 'Hashable | None' = None, encoding: 'str | None' = None, chunksize: 'int | None' = None, iterator: 'bool' = False) -> 'DataFrame | ReaderBase': Read SAS files stored as either XPORT or SAS7BDAT format files."}
{"text_id": 1006875, "text": "read_sas(filepath_or_buffer: 'FilePathOrBuffer', format: 'str | None' = None, index: 'Hashable | None' = None, encoding: 'str | None' = None, chunksize: 'int | None' = None, iterator: 'bool' = False) -> 'DataFrame | ReaderBase': Read SAS files stored as either XPORT or SAS7BDAT format files."}
{"text_id": 1006876, "text": "read_sas(filepath_or_buffer: 'FilePathOrBuffer', format: 'str | None' = None, index: 'Hashable | None' = None, encoding: 'str | None' = None, chunksize: 'int | None' = None, iterator: 'bool' = False) -> 'DataFrame | ReaderBase': Read SAS files stored as either XPORT or SAS7BDAT format files."}
{"text_id": 1006877, "text": "read_sas(filepath_or_buffer: 'FilePathOrBuffer', format: 'str | None' = None, index: 'Hashable | None' = None, encoding: 'str | None' = None, chunksize: 'int | None' = None, iterator: 'bool' = False) -> 'DataFrame | ReaderBase': Read SAS files stored as either XPORT or SAS7BDAT format files."}
{"text_id": 1006878, "text": "read_sas(filepath_or_buffer: 'FilePathOrBuffer', format: 'str | None' = None, index: 'Hashable | None' = None, encoding: 'str | None' = None, chunksize: 'int | None' = None, iterator: 'bool' = False) -> 'DataFrame | ReaderBase': Read SAS files stored as either XPORT or SAS7BDAT format files."}
{"text_id": 1006879, "text": "read_spss(path: 'str | Path', usecols: 'Sequence[str] | None' = None, convert_categoricals: 'bool' = True) -> 'DataFrame': Load an SPSS file from the file path, returning a DataFrame."}
{"text_id": 1006880, "text": "read_spss(path: 'str | Path', usecols: 'Sequence[str] | None' = None, convert_categoricals: 'bool' = True) -> 'DataFrame': Load an SPSS file from the file path, returning a DataFrame."}
{"text_id": 1006881, "text": "read_spss(path: 'str | Path', usecols: 'Sequence[str] | None' = None, convert_categoricals: 'bool' = True) -> 'DataFrame': Load an SPSS file from the file path, returning a DataFrame."}
{"text_id": 1006882, "text": "read_spss(path: 'str | Path', usecols: 'Sequence[str] | None' = None, convert_categoricals: 'bool' = True) -> 'DataFrame': Load an SPSS file from the file path, returning a DataFrame."}
{"text_id": 1006883, "text": "read_spss(path: 'str | Path', usecols: 'Sequence[str] | None' = None, convert_categoricals: 'bool' = True) -> 'DataFrame': Load an SPSS file from the file path, returning a DataFrame."}
{"text_id": 1006884, "text": "read_sql(sql, con, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, params=None, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query or database table into a DataFrame."}
{"text_id": 1006885, "text": "read_sql(sql, con, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, params=None, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query or database table into a DataFrame."}
{"text_id": 1006886, "text": "read_sql(sql, con, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, params=None, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query or database table into a DataFrame."}
{"text_id": 1006887, "text": "read_sql(sql, con, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, params=None, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query or database table into a DataFrame."}
{"text_id": 1006888, "text": "read_sql(sql, con, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, params=None, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query or database table into a DataFrame."}
{"text_id": 1006889, "text": "read_sql_query(sql, con, index_col=None, coerce_float: 'bool' = True, params=None, parse_dates=None, chunksize: 'int | None' = None, dtype: 'DtypeArg | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query into a DataFrame."}
{"text_id": 1006890, "text": "read_sql_query(sql, con, index_col=None, coerce_float: 'bool' = True, params=None, parse_dates=None, chunksize: 'int | None' = None, dtype: 'DtypeArg | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query into a DataFrame."}
{"text_id": 1006891, "text": "read_sql_query(sql, con, index_col=None, coerce_float: 'bool' = True, params=None, parse_dates=None, chunksize: 'int | None' = None, dtype: 'DtypeArg | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query into a DataFrame."}
{"text_id": 1006892, "text": "read_sql_query(sql, con, index_col=None, coerce_float: 'bool' = True, params=None, parse_dates=None, chunksize: 'int | None' = None, dtype: 'DtypeArg | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query into a DataFrame."}
{"text_id": 1006893, "text": "read_sql_query(sql, con, index_col=None, coerce_float: 'bool' = True, params=None, parse_dates=None, chunksize: 'int | None' = None, dtype: 'DtypeArg | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL query into a DataFrame."}
{"text_id": 1006894, "text": "read_sql_table(table_name: 'str', con, schema: 'str | None' = None, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL database table into a DataFrame."}
{"text_id": 1006895, "text": "read_sql_table(table_name: 'str', con, schema: 'str | None' = None, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL database table into a DataFrame."}
{"text_id": 1006896, "text": "read_sql_table(table_name: 'str', con, schema: 'str | None' = None, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL database table into a DataFrame."}
{"text_id": 1006897, "text": "read_sql_table(table_name: 'str', con, schema: 'str | None' = None, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL database table into a DataFrame."}
{"text_id": 1006898, "text": "read_sql_table(table_name: 'str', con, schema: 'str | None' = None, index_col: 'str | Sequence[str] | None' = None, coerce_float: 'bool' = True, parse_dates=None, columns=None, chunksize: 'int | None' = None) -> 'DataFrame | Iterator[DataFrame]': Read SQL database table into a DataFrame."}
{"text_id": 1006899, "text": "read_stata(filepath_or_buffer: 'FilePathOrBuffer', convert_dates: 'bool' = True, convert_categoricals: 'bool' = True, index_col: 'str | None' = None, convert_missing: 'bool' = False, preserve_dtypes: 'bool' = True, columns: 'Sequence[str] | None' = None, order_categoricals: 'bool' = True, chunksize: 'int | None' = None, iterator: 'bool' = False, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame | StataReader': Read Stata file into DataFrame."}
{"text_id": 1006900, "text": "read_stata(filepath_or_buffer: 'FilePathOrBuffer', convert_dates: 'bool' = True, convert_categoricals: 'bool' = True, index_col: 'str | None' = None, convert_missing: 'bool' = False, preserve_dtypes: 'bool' = True, columns: 'Sequence[str] | None' = None, order_categoricals: 'bool' = True, chunksize: 'int | None' = None, iterator: 'bool' = False, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame | StataReader': Read Stata file into DataFrame."}
{"text_id": 1006901, "text": "read_stata(filepath_or_buffer: 'FilePathOrBuffer', convert_dates: 'bool' = True, convert_categoricals: 'bool' = True, index_col: 'str | None' = None, convert_missing: 'bool' = False, preserve_dtypes: 'bool' = True, columns: 'Sequence[str] | None' = None, order_categoricals: 'bool' = True, chunksize: 'int | None' = None, iterator: 'bool' = False, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame | StataReader': Read Stata file into DataFrame."}
{"text_id": 1006902, "text": "read_stata(filepath_or_buffer: 'FilePathOrBuffer', convert_dates: 'bool' = True, convert_categoricals: 'bool' = True, index_col: 'str | None' = None, convert_missing: 'bool' = False, preserve_dtypes: 'bool' = True, columns: 'Sequence[str] | None' = None, order_categoricals: 'bool' = True, chunksize: 'int | None' = None, iterator: 'bool' = False, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame | StataReader': Read Stata file into DataFrame."}
{"text_id": 1006903, "text": "read_stata(filepath_or_buffer: 'FilePathOrBuffer', convert_dates: 'bool' = True, convert_categoricals: 'bool' = True, index_col: 'str | None' = None, convert_missing: 'bool' = False, preserve_dtypes: 'bool' = True, columns: 'Sequence[str] | None' = None, order_categoricals: 'bool' = True, chunksize: 'int | None' = None, iterator: 'bool' = False, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame | StataReader': Read Stata file into DataFrame."}
{"text_id": 1006904, "text": "read_table(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, encoding_errors: 'str | None' = 'strict', delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None): Read general delimited file into DataFrame."}
{"text_id": 1006905, "text": "read_table(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, encoding_errors: 'str | None' = 'strict', delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None): Read general delimited file into DataFrame."}
{"text_id": 1006906, "text": "read_table(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, encoding_errors: 'str | None' = 'strict', delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None): Read general delimited file into DataFrame."}
{"text_id": 1006907, "text": "read_table(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, encoding_errors: 'str | None' = 'strict', delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None): Read general delimited file into DataFrame."}
{"text_id": 1006908, "text": "read_table(filepath_or_buffer: 'FilePathOrBuffer', sep=<no_default>, delimiter=None, header='infer', names=<no_default>, index_col=None, usecols=None, squeeze=False, prefix=<no_default>, mangle_dupe_cols=True, dtype: 'DtypeArg | None' = None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: 'str' = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, encoding_errors: 'str | None' = 'strict', delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None): Read general delimited file into DataFrame."}
{"text_id": 1006909, "text": "read_xml(path_or_buffer: 'FilePathOrBuffer', xpath: 'str | None' = './*', namespaces: 'dict | list[dict] | None' = None, elems_only: 'bool | None' = False, attrs_only: 'bool | None' = False, names: 'list[str] | None' = None, encoding: 'str | None' = 'utf-8', parser: 'str | None' = 'lxml', stylesheet: 'FilePathOrBuffer | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame': Read XML document into a ``DataFrame`` object."}
{"text_id": 1006910, "text": "read_xml(path_or_buffer: 'FilePathOrBuffer', xpath: 'str | None' = './*', namespaces: 'dict | list[dict] | None' = None, elems_only: 'bool | None' = False, attrs_only: 'bool | None' = False, names: 'list[str] | None' = None, encoding: 'str | None' = 'utf-8', parser: 'str | None' = 'lxml', stylesheet: 'FilePathOrBuffer | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame': Read XML document into a ``DataFrame`` object."}
{"text_id": 1006911, "text": "read_xml(path_or_buffer: 'FilePathOrBuffer', xpath: 'str | None' = './*', namespaces: 'dict | list[dict] | None' = None, elems_only: 'bool | None' = False, attrs_only: 'bool | None' = False, names: 'list[str] | None' = None, encoding: 'str | None' = 'utf-8', parser: 'str | None' = 'lxml', stylesheet: 'FilePathOrBuffer | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame': Read XML document into a ``DataFrame`` object."}
{"text_id": 1006912, "text": "read_xml(path_or_buffer: 'FilePathOrBuffer', xpath: 'str | None' = './*', namespaces: 'dict | list[dict] | None' = None, elems_only: 'bool | None' = False, attrs_only: 'bool | None' = False, names: 'list[str] | None' = None, encoding: 'str | None' = 'utf-8', parser: 'str | None' = 'lxml', stylesheet: 'FilePathOrBuffer | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame': Read XML document into a ``DataFrame`` object."}
{"text_id": 1006913, "text": "read_xml(path_or_buffer: 'FilePathOrBuffer', xpath: 'str | None' = './*', namespaces: 'dict | list[dict] | None' = None, elems_only: 'bool | None' = False, attrs_only: 'bool | None' = False, names: 'list[str] | None' = None, encoding: 'str | None' = 'utf-8', parser: 'str | None' = 'lxml', stylesheet: 'FilePathOrBuffer | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None) -> 'DataFrame': Read XML document into a ``DataFrame`` object."}
{"text_id": 1006914, "text": "Buffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006915, "text": "Buffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006916, "text": "Buffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006917, "text": "BytesIO(initial_bytes=b''): Buffered I/O implementation using an in-memory bytes buffer."}
{"text_id": 1006918, "text": "BytesIO(initial_bytes=b''): Buffered I/O implementation using an in-memory bytes buffer."}
{"text_id": 1006919, "text": "CompressionDict(*args, **kwargs): The central part of internal API."}
{"text_id": 1006920, "text": "FileOrBuffer(*args, **kwargs): The central part of internal API."}
{"text_id": 1006921, "text": "IOArgs(filepath_or_buffer: 'FileOrBuffer', encoding: 'str', mode: 'str', compression: 'CompressionDict', should_close: 'bool' = False) -> None: Return value of io/common."}
{"text_id": 1006922, "text": "IOHandles(handle: 'Buffer', compression: 'CompressionDict', created_handles: 'list[Buffer]' = <factory>, is_wrapped: 'bool' = False, is_mmap: 'bool' = False) -> None: Return value of io/common."}
{"text_id": 1006923, "text": "IOHandles(handle: 'Buffer', compression: 'CompressionDict', created_handles: 'list[Buffer]' = <factory>, is_wrapped: 'bool' = False, is_mmap: 'bool' = False) -> None: Return value of io/common."}
{"text_id": 1006924, "text": "TextIOWrapper(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False): Character and line based layer over a BufferedIOBase object, buffer."}
{"text_id": 1006925, "text": "file_exists(filepath_or_buffer: 'FilePathOrBuffer') -> 'bool': Test whether file exists."}
{"text_id": 1006926, "text": "file_exists(filepath_or_buffer: 'FilePathOrBuffer') -> 'bool': Test whether file exists."}
{"text_id": 1006927, "text": "file_path_to_url(path: 'str') -> 'str': converts an absolute native path to a FILE URL."}
{"text_id": 1006928, "text": "get_compression_method(compression: 'CompressionOptions') -> 'tuple[str | None, CompressionDict]': Simplifies a compression argument to a compression method string and a mapping containing additional arguments."}
{"text_id": 1006929, "text": "infer_compression(filepath_or_buffer: 'FilePathOrBuffer', compression: 'str | None') -> 'str | None': Get the compression method for filepath_or_buffer."}
{"text_id": 1006930, "text": "is_fsspec_url(url: 'FilePathOrBuffer') -> 'bool': Returns true if the given URL looks like something fsspec can handle."}
{"text_id": 1006931, "text": "is_fsspec_url(url: 'FilePathOrBuffer') -> 'bool': Returns true if the given URL looks like something fsspec can handle."}
{"text_id": 1006932, "text": "is_fsspec_url(url: 'FilePathOrBuffer') -> 'bool': Returns true if the given URL looks like something fsspec can handle."}
{"text_id": 1006933, "text": "is_url(url) -> 'bool': Check to see if a URL has a valid protocol."}
{"text_id": 1006934, "text": "is_url(url) -> 'bool': Check to see if a URL has a valid protocol."}
{"text_id": 1006935, "text": "is_url(url) -> 'bool': Check to see if a URL has a valid protocol."}
{"text_id": 1006936, "text": "is_url(url) -> 'bool': Check to see if a URL has a valid protocol."}
{"text_id": 1006937, "text": "parse_url(url, scheme='', allow_fragments=True): Parse a URL into 6 components: <scheme>://<netloc>/<path>;<params>?<query>#<fragment> Return a 6-tuple: (scheme, netloc, path, params, query, fragment)."}
{"text_id": 1006938, "text": "stringify_path(filepath_or_buffer: 'FilePathOrBuffer[AnyStr]', convert_file_like: 'bool' = False) -> 'FileOrBuffer[AnyStr]': Attempt to convert a path-like object to a string."}
{"text_id": 1006939, "text": "stringify_path(filepath_or_buffer: 'FilePathOrBuffer[AnyStr]', convert_file_like: 'bool' = False) -> 'FileOrBuffer[AnyStr]': Attempt to convert a path-like object to a string."}
{"text_id": 1006940, "text": "stringify_path(filepath_or_buffer: 'FilePathOrBuffer[AnyStr]', convert_file_like: 'bool' = False) -> 'FileOrBuffer[AnyStr]': Attempt to convert a path-like object to a string."}
{"text_id": 1006941, "text": "stringify_path(filepath_or_buffer: 'FilePathOrBuffer[AnyStr]', convert_file_like: 'bool' = False) -> 'FileOrBuffer[AnyStr]': Attempt to convert a path-like object to a string."}
{"text_id": 1006942, "text": "stringify_path(filepath_or_buffer: 'FilePathOrBuffer[AnyStr]', convert_file_like: 'bool' = False) -> 'FileOrBuffer[AnyStr]': Attempt to convert a path-like object to a string."}
{"text_id": 1006943, "text": "stringify_path(filepath_or_buffer: 'FilePathOrBuffer[AnyStr]', convert_file_like: 'bool' = False) -> 'FileOrBuffer[AnyStr]': Attempt to convert a path-like object to a string."}
{"text_id": 1006944, "text": "urljoin(base, url, allow_fragments=True): Join a base URL and a possibly relative URL to form an absolute interpretation of the latter."}
{"text_id": 1006945, "text": "urlopen(*args, **kwargs): Lazy-import wrapper for stdlib urlopen, as that imports a big chunk of the stdlib."}
{"text_id": 1006946, "text": "urlopen(*args, **kwargs): Lazy-import wrapper for stdlib urlopen, as that imports a big chunk of the stdlib."}
{"text_id": 1006947, "text": "generic_parser(parse_func, *cols): Use dateparser to parse columns with data information into a single datetime column."}
{"text_id": 1006948, "text": "parse_all_fields(year_col, month_col, day_col, hour_col, minute_col, second_col): Parse columns with datetime information into a single datetime column."}
{"text_id": 1006949, "text": "parse_date_fields(year_col, month_col, day_col): Parse columns with years, months and days into a single date column."}
{"text_id": 1006950, "text": "parse_date_time(date_col, time_col): Parse columns with dates and times into a single datetime column."}
{"text_id": 1006951, "text": "register_writer(klass): Add engine to the excel writer registry."}
{"text_id": 1006952, "text": "Pattern(*args, **kwargs): The central part of internal API."}
{"text_id": 1006953, "text": "TextParser(*args, **kwds): Converts lists of lists/tuples into DataFrames with proper type inference and optional (e."}
{"text_id": 1006954, "text": "TextParser(*args, **kwds): Converts lists of lists/tuples into DataFrames with proper type inference and optional (e."}
{"text_id": 1006955, "text": "TextParser(*args, **kwds): Converts lists of lists/tuples into DataFrames with proper type inference and optional (e."}
{"text_id": 1006956, "text": "build_table_schema(data: 'FrameOrSeries', index: 'bool' = True, primary_key: 'bool | None' = None, version: 'bool' = True) -> 'dict[str, JSONSerializable]': Create a Table schema from ``data``."}
{"text_id": 1006957, "text": "json_normalize(data: 'dict | list[dict]', record_path: 'str | list | None' = None, meta: 'str | list[str | list[str]] | None' = None, meta_prefix: 'str | None' = None, record_prefix: 'str | None' = None, errors: 'str' = 'raise', sep: 'str' = '.', max_level: 'int | None' = None) -> 'DataFrame': Normalize semi-structured JSON data into a flat table."}
{"text_id": 1006958, "text": "json_normalize(data: 'dict | list[dict]', record_path: 'str | list | None' = None, meta: 'str | list[str | list[str]] | None' = None, meta_prefix: 'str | None' = None, record_prefix: 'str | None' = None, errors: 'str' = 'raise', sep: 'str' = '.', max_level: 'int | None' = None) -> 'DataFrame': Normalize semi-structured JSON data into a flat table."}
{"text_id": 1006959, "text": "json_normalize(data: 'dict | list[dict]', record_path: 'str | list | None' = None, meta: 'str | list[str | list[str]] | None' = None, meta_prefix: 'str | None' = None, record_prefix: 'str | None' = None, errors: 'str' = 'raise', sep: 'str' = '.', max_level: 'int | None' = None) -> 'DataFrame': Normalize semi-structured JSON data into a flat table."}
{"text_id": 1006960, "text": "json_normalize(data: 'dict | list[dict]', record_path: 'str | list | None' = None, meta: 'str | list[str | list[str]] | None' = None, meta_prefix: 'str | None' = None, record_prefix: 'str | None' = None, errors: 'str' = 'raise', sep: 'str' = '.', max_level: 'int | None' = None) -> 'DataFrame': Normalize semi-structured JSON data into a flat table."}
{"text_id": 1006961, "text": "get_engine(engine: 'str') -> 'BaseImpl': return our implementation."}
{"text_id": 1006962, "text": "get_engine(engine: 'str') -> 'BaseEngine': return our implementation."}
{"text_id": 1006963, "text": "TextFileReader(f, engine=None, **kwds): Passed dialect overrides any of the related parser options."}
{"text_id": 1006964, "text": "AppendableFrameTable(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): support the new appendable table formats."}
{"text_id": 1006965, "text": "AppendableMultiFrameTable(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): a frame with a multi-index."}
{"text_id": 1006966, "text": "AppendableMultiSeriesTable(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): support the new appendable table formats."}
{"text_id": 1006967, "text": "AppendableSeriesTable(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): support the new appendable table formats."}
{"text_id": 1006968, "text": "AppendableTable(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): support the new appendable table formats."}
{"text_id": 1006969, "text": "DataCol(name: 'str', values=None, kind=None, typ=None, cname=None, pos=None, tz=None, ordered=None, table=None, meta=None, metadata=None, dtype: 'DtypeArg | None' = None, data=None): a data holding column, by definition this is not indexable."}
{"text_id": 1006970, "text": "DataIndexableCol(name: 'str', values=None, kind=None, typ=None, cname=None, pos=None, tz=None, ordered=None, table=None, meta=None, metadata=None, dtype: 'DtypeArg | None' = None, data=None): represent a data column that can be indexed."}
{"text_id": 1006971, "text": "Fixed(parent: 'HDFStore', group: 'Node', encoding: 'str' = 'UTF-8', errors: 'str' = 'strict'): represent an object in my store facilitate read/write of various types of objects this is an abstract base class."}
{"text_id": 1006972, "text": "GenericDataIndexableCol(name: 'str', values=None, kind=None, typ=None, cname=None, pos=None, tz=None, ordered=None, table=None, meta=None, metadata=None, dtype: 'DtypeArg | None' = None, data=None): represent a generic pytables data column."}
{"text_id": 1006973, "text": "GenericFixed(parent: 'HDFStore', group: 'Node', encoding: 'str' = 'UTF-8', errors: 'str' = 'strict'): a generified fixed version."}
{"text_id": 1006974, "text": "GenericIndexCol(name: 'str', values=None, kind=None, typ=None, cname: 'str | None' = None, axis=None, pos=None, freq=None, tz=None, index_name=None, ordered=None, table=None, meta=None, metadata=None): an index which is not represented in the data of the table."}
{"text_id": 1006975, "text": "GenericTable(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): a table that read/writes the generic pytables table format."}
{"text_id": 1006976, "text": "IndexCol(name: 'str', values=None, kind=None, typ=None, cname: 'str | None' = None, axis=None, pos=None, freq=None, tz=None, index_name=None, ordered=None, table=None, meta=None, metadata=None): an index column description class."}
{"text_id": 1006977, "text": "PyTablesExpr(where, queryables: 'dict[str, Any] | None' = None, encoding=None, scope_level: 'int' = 0): Hold a pytables-like expression, comprised of possibly multiple 'terms'."}
{"text_id": 1006978, "text": "Selection(table: 'Table', where=None, start: 'int | None' = None, stop: 'int | None' = None): Carries out a selection operation on a tables."}
{"text_id": 1006979, "text": "Table(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): represent a table: facilitate read/write of various types of tables Attrs in."}
{"text_id": 1006980, "text": "TableIterator(store: 'HDFStore', s: 'GenericFixed | Table', func, where, nrows, start=None, stop=None, iterator: 'bool' = False, chunksize: 'int | None' = None, auto_close: 'bool' = False): Define the iteration interface on a table."}
{"text_id": 1006981, "text": "Term(where, queryables: 'dict[str, Any] | None' = None, encoding=None, scope_level: 'int' = 0): Hold a pytables-like expression, comprised of possibly multiple 'terms'."}
{"text_id": 1006982, "text": "WORMTable(parent: 'HDFStore', group: 'Node', encoding=None, errors: 'str' = 'strict', index_axes=None, non_index_axes=None, values_axes=None, data_columns=None, info=None, nan_rep=None): a write-once read-many table: this format DOES NOT ALLOW appending to a table."}
{"text_id": 1006983, "text": "adjoin(space: 'int', *lists: 'list[str]', **kwargs) -> 'str': Glues together two sets of strings using the amount of space requested."}
{"text_id": 1006984, "text": "array_equivalent(left, right, strict_nan: bool = False, dtype_equal: bool = False) -> bool: True if two arrays, left and right, have equal non-NaN elements, and NaNs in corresponding locations."}
{"text_id": 1006985, "text": "maybe_expression(s) -> 'bool': loose checking if s is a pytables-acceptable expression."}
{"text_id": 1006986, "text": "Path(*args, **kwargs): PurePath subclass that can make system calls."}
{"text_id": 1006987, "text": "PandasSQL(): Subclasses Should define read_sql and to_sql."}
{"text_id": 1006988, "text": "SQLDatabase(engine, schema: 'str | None' = None, meta=None): This class enables conversion between DataFrame and SQL databases using SQLAlchemy to handle DataBase abstraction."}
{"text_id": 1006989, "text": "SQLTable(name: 'str', pandas_sql_engine, frame=None, index=True, if_exists='fail', prefix='pandas', index_label=None, schema=None, keys=None, dtype: 'DtypeArg | None' = None): For mapping Pandas tables to SQL tables."}
{"text_id": 1006990, "text": "SQLiteDatabase(con, is_cursor: 'bool' = False): Version of SQLDatabase to support SQLite connections (fallback without SQLAlchemy)."}
{"text_id": 1006991, "text": "SQLiteTable(*args, **kwargs): Patch the SQLTable for fallback support."}
{"text_id": 1006992, "text": "contextmanager(func): @contextmanager decorator."}
{"text_id": 1006993, "text": "execute(sql, con, cur=None, params=None): Execute the given SQL query using the provided connection object."}
{"text_id": 1006994, "text": "get_schema(frame, name: 'str', keys=None, con=None, dtype: 'DtypeArg | None' = None, schema: 'str | None' = None): Get the SQL db table schema for the given frame."}
{"text_id": 1006995, "text": "has_table(table_name: 'str', con, schema: 'str | None' = None): Check if DataBase has named table."}
{"text_id": 1006996, "text": "pandasSQL_builder(con, schema: 'str | None' = None, meta=None, is_cursor: 'bool' = False): Convenience function to return the correct PandasSQL subclass based on the provided parameters."}
{"text_id": 1006997, "text": "table_exists(table_name: 'str', con, schema: 'str | None' = None): Check if DataBase has named table."}
{"text_id": 1006998, "text": "StataMissingValue(value: 'int | float'): An observation's missing value."}
{"text_id": 1006999, "text": "StataReader(path_or_buf: 'FilePathOrBuffer', convert_dates: 'bool' = True, convert_categoricals: 'bool' = True, index_col: 'str | None' = None, convert_missing: 'bool' = False, preserve_dtypes: 'bool' = True, columns: 'Sequence[str] | None' = None, order_categoricals: 'bool' = True, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None): Class for reading Stata dta files."}
{"text_id": 1007000, "text": "StataStrLWriter(df: 'DataFrame', columns: 'Sequence[str]', version: 'int' = 117, byteorder: 'str | None' = None): Converter for Stata StrLs Stata StrLs map 8 byte values to strings which are stored using a dictionary-like format where strings are keyed to two values."}
{"text_id": 1007001, "text": "StataValueLabel(catarray: 'Series', encoding: 'str' = 'latin-1'): Parse a categorical column and prepare formatted output."}
{"text_id": 1007002, "text": "StataWriter(fname: 'FilePathOrBuffer', data: 'DataFrame', convert_dates: 'dict[Hashable, str] | None' = None, write_index: 'bool' = True, byteorder: 'str | None' = None, time_stamp: 'datetime.datetime | None' = None, data_label: 'str | None' = None, variable_labels: 'dict[Hashable, str] | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None): A class for writing Stata binary dta files."}
{"text_id": 1007003, "text": "StataWriter117(fname: 'FilePathOrBuffer', data: 'DataFrame', convert_dates: 'dict[Hashable, str] | None' = None, write_index: 'bool' = True, byteorder: 'str | None' = None, time_stamp: 'datetime.datetime | None' = None, data_label: 'str | None' = None, variable_labels: 'dict[Hashable, str] | None' = None, convert_strl: 'Sequence[Hashable] | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None): A class for writing Stata binary dta files in Stata 13 format (117)."}
{"text_id": 1007004, "text": "StataWriterUTF8(fname: 'FilePathOrBuffer', data: 'DataFrame', convert_dates: 'dict[Hashable, str] | None' = None, write_index: 'bool' = True, byteorder: 'str | None' = None, time_stamp: 'datetime.datetime | None' = None, data_label: 'str | None' = None, variable_labels: 'dict[Hashable, str] | None' = None, convert_strl: 'Sequence[Hashable] | None' = None, version: 'int | None' = None, compression: 'CompressionOptions' = 'infer', storage_options: 'StorageOptions' = None): Stata binary dta file writing in Stata 15 (118) and 16 (119) formats DTA 118 and 119 format files support unicode string data (both fixed and strL) format."}
{"text_id": 1007005, "text": "max_len_string_array(arr): Return the maximum size of elements in a 1-dim string array."}
{"text_id": 1007006, "text": "relativedelta(dt1=None, dt2=None, years=0, months=0, days=0, leapdays=0, weeks=0, hours=0, minutes=0, seconds=0, microseconds=0, year=None, month=None, day=None, weekday=None, yearday=None, nlyearday=None, hour=None, minute=None, second=None, microsecond=None): The relativedelta type is designed to be applied to an existing datetime and can replace specific components of that datetime, or represents an interval of time."}
{"text_id": 1007007, "text": "get_data_from_filepath(filepath_or_buffer, encoding, compression, storage_options) -> 'str | bytes | Buffer': Extract raw XML data."}
{"text_id": 1007008, "text": "preprocess_data(data) -> 'io.StringIO | io.BytesIO': Convert extracted raw data."}
{"text_id": 1007009, "text": "lreshape(data: 'DataFrame', groups, dropna: 'bool' = True, label=None) -> 'DataFrame': Reshape wide-format data to long."}
{"text_id": 1007010, "text": "lreshape(data: 'DataFrame', groups, dropna: 'bool' = True, label=None) -> 'DataFrame': Reshape wide-format data to long."}
{"text_id": 1007011, "text": "lreshape(data: 'DataFrame', groups, dropna: 'bool' = True, label=None) -> 'DataFrame': Reshape wide-format data to long."}
{"text_id": 1007012, "text": "merge_asof(left: 'DataFrame | Series', right: 'DataFrame | Series', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, by=None, left_by=None, right_by=None, suffixes: 'Suffixes' = ('_x', '_y'), tolerance=None, allow_exact_matches: 'bool' = True, direction: 'str' = 'backward') -> 'DataFrame': Perform an asof merge."}
{"text_id": 1007013, "text": "merge_asof(left: 'DataFrame | Series', right: 'DataFrame | Series', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, by=None, left_by=None, right_by=None, suffixes: 'Suffixes' = ('_x', '_y'), tolerance=None, allow_exact_matches: 'bool' = True, direction: 'str' = 'backward') -> 'DataFrame': Perform an asof merge."}
{"text_id": 1007014, "text": "merge_asof(left: 'DataFrame | Series', right: 'DataFrame | Series', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, by=None, left_by=None, right_by=None, suffixes: 'Suffixes' = ('_x', '_y'), tolerance=None, allow_exact_matches: 'bool' = True, direction: 'str' = 'backward') -> 'DataFrame': Perform an asof merge."}
{"text_id": 1007015, "text": "merge_ordered(left: 'DataFrame', right: 'DataFrame', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_by=None, right_by=None, fill_method: 'str | None' = None, suffixes: 'Suffixes' = ('_x', '_y'), how: 'str' = 'outer') -> 'DataFrame': Perform merge with optional filling/interpolation."}
{"text_id": 1007016, "text": "merge_ordered(left: 'DataFrame', right: 'DataFrame', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_by=None, right_by=None, fill_method: 'str | None' = None, suffixes: 'Suffixes' = ('_x', '_y'), how: 'str' = 'outer') -> 'DataFrame': Perform merge with optional filling/interpolation."}
{"text_id": 1007017, "text": "merge_ordered(left: 'DataFrame', right: 'DataFrame', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_by=None, right_by=None, fill_method: 'str | None' = None, suffixes: 'Suffixes' = ('_x', '_y'), how: 'str' = 'outer') -> 'DataFrame': Perform merge with optional filling/interpolation."}
{"text_id": 1007018, "text": "qcut(x, q, labels=None, retbins: bool = False, precision: int = 3, duplicates: str = 'raise'): Quantile-based discretization function."}
{"text_id": 1007019, "text": "qcut(x, q, labels=None, retbins: bool = False, precision: int = 3, duplicates: str = 'raise'): Quantile-based discretization function."}
{"text_id": 1007020, "text": "qcut(x, q, labels=None, retbins: bool = False, precision: int = 3, duplicates: str = 'raise'): Quantile-based discretization function."}
{"text_id": 1007021, "text": "reset_option(*args, **kwds): reset_option(pat) Reset one or more options to their default value."}
{"text_id": 1007022, "text": "reset_option(*args, **kwds): reset_option(pat) Reset one or more options to their default value."}
{"text_id": 1007023, "text": "reset_option(*args, **kwds): reset_option(pat) Reset one or more options to their default value."}
{"text_id": 1007024, "text": "set_option(*args, **kwds): set_option(pat, value) Sets the value of the specified option."}
{"text_id": 1007025, "text": "set_option(*args, **kwds): set_option(pat, value) Sets the value of the specified option."}
{"text_id": 1007026, "text": "set_option(*args, **kwds): set_option(pat, value) Sets the value of the specified option."}
{"text_id": 1007027, "text": "show_versions(as_json: 'str | bool' = False) -> 'None': Provide useful information, important for bug reports."}
{"text_id": 1007028, "text": "show_versions(as_json: 'str | bool' = False) -> 'None': Provide useful information, important for bug reports."}
{"text_id": 1007029, "text": "show_versions(as_json: 'str | bool' = False) -> 'None': Provide useful information, important for bug reports."}
{"text_id": 1007030, "text": "wide_to_long(df: 'DataFrame', stubnames, i, j, sep: 'str' = '', suffix: 'str' = '\\\\d+') -> 'DataFrame': Wide panel to long format."}
{"text_id": 1007031, "text": "wide_to_long(df: 'DataFrame', stubnames, i, j, sep: 'str' = '', suffix: 'str' = '\\\\d+') -> 'DataFrame': Wide panel to long format."}
{"text_id": 1007032, "text": "wide_to_long(df: 'DataFrame', stubnames, i, j, sep: 'str' = '', suffix: 'str' = '\\\\d+') -> 'DataFrame': Wide panel to long format."}
{"text_id": 1007033, "text": "PlotAccessor(data): Make plots of Series or DataFrame."}
{"text_id": 1007034, "text": "PlotAccessor(data): Make plots of Series or DataFrame."}
{"text_id": 1007035, "text": "andrews_curves(frame, class_column, ax=None, samples=200, color=None, colormap=None, **kwargs): Generate a matplotlib plot of Andrews curves, for visualising clusters of multivariate data."}
{"text_id": 1007036, "text": "andrews_curves(frame, class_column, ax=None, samples=200, color=None, colormap=None, **kwargs): Generate a matplotlib plot of Andrews curves, for visualising clusters of multivariate data."}
{"text_id": 1007037, "text": "autocorrelation_plot(series, ax=None, **kwargs): Autocorrelation plot for time series."}
{"text_id": 1007038, "text": "autocorrelation_plot(series, ax=None, **kwargs): Autocorrelation plot for time series."}
{"text_id": 1007039, "text": "bootstrap_plot(series, fig=None, size=50, samples=500, **kwds): Bootstrap plot on mean, median and mid-range statistics."}
{"text_id": 1007040, "text": "bootstrap_plot(series, fig=None, size=50, samples=500, **kwds): Bootstrap plot on mean, median and mid-range statistics."}
{"text_id": 1007041, "text": "boxplot_frame(self, column=None, by=None, ax=None, fontsize=None, rot=0, grid=True, figsize=None, layout=None, return_type=None, backend=None, **kwargs): Make a box plot from DataFrame columns."}
{"text_id": 1007042, "text": "boxplot_frame(self, column=None, by=None, ax=None, fontsize=None, rot=0, grid=True, figsize=None, layout=None, return_type=None, backend=None, **kwargs): Make a box plot from DataFrame columns."}
{"text_id": 1007043, "text": "boxplot_frame_groupby(grouped, subplots=True, column=None, fontsize=None, rot=0, grid=True, ax=None, figsize=None, layout=None, sharex=False, sharey=True, backend=None, **kwargs): Make box plots from DataFrameGroupBy data."}
{"text_id": 1007044, "text": "boxplot_frame_groupby(grouped, subplots=True, column=None, fontsize=None, rot=0, grid=True, ax=None, figsize=None, layout=None, sharex=False, sharey=True, backend=None, **kwargs): Make box plots from DataFrameGroupBy data."}
{"text_id": 1007045, "text": "deregister_matplotlib_converters(): Remove pandas formatters and converters."}
{"text_id": 1007046, "text": "deregister_matplotlib_converters(): Remove pandas formatters and converters."}
{"text_id": 1007047, "text": "hist_frame(data: 'DataFrame', column: 'IndexLabel' = None, by=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, ax=None, sharex: 'bool' = False, sharey: 'bool' = False, figsize: 'tuple[int, int] | None' = None, layout: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Make a histogram of the DataFrame's columns."}
{"text_id": 1007048, "text": "hist_frame(data: 'DataFrame', column: 'IndexLabel' = None, by=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, ax=None, sharex: 'bool' = False, sharey: 'bool' = False, figsize: 'tuple[int, int] | None' = None, layout: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Make a histogram of the DataFrame's columns."}
{"text_id": 1007049, "text": "hist_series(self, by=None, ax=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, figsize: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Draw histogram of the input series using matplotlib."}
{"text_id": 1007050, "text": "hist_series(self, by=None, ax=None, grid: 'bool' = True, xlabelsize: 'int | None' = None, xrot: 'float | None' = None, ylabelsize: 'int | None' = None, yrot: 'float | None' = None, figsize: 'tuple[int, int] | None' = None, bins: 'int | Sequence[int]' = 10, backend: 'str | None' = None, legend: 'bool' = False, **kwargs): Draw histogram of the input series using matplotlib."}
{"text_id": 1007051, "text": "lag_plot(series, lag=1, ax=None, **kwds): Lag plot for time series."}
{"text_id": 1007052, "text": "lag_plot(series, lag=1, ax=None, **kwds): Lag plot for time series."}
{"text_id": 1007053, "text": "parallel_coordinates(frame, class_column, cols=None, ax=None, color=None, use_columns=False, xticks=None, colormap=None, axvlines=True, axvlines_kwds=None, sort_labels=False, **kwargs): Parallel coordinates plotting."}
{"text_id": 1007054, "text": "parallel_coordinates(frame, class_column, cols=None, ax=None, color=None, use_columns=False, xticks=None, colormap=None, axvlines=True, axvlines_kwds=None, sort_labels=False, **kwargs): Parallel coordinates plotting."}
{"text_id": 1007055, "text": "radviz(frame, class_column, ax=None, color=None, colormap=None, **kwds): Plot a multidimensional dataset in 2D."}
{"text_id": 1007056, "text": "radviz(frame, class_column, ax=None, color=None, colormap=None, **kwds): Plot a multidimensional dataset in 2D."}
{"text_id": 1007057, "text": "register_matplotlib_converters(): Register pandas formatters and converters with matplotlib."}
{"text_id": 1007058, "text": "register_matplotlib_converters(): Register pandas formatters and converters with matplotlib."}
{"text_id": 1007059, "text": "scatter_matrix(frame, alpha=0.5, figsize=None, ax=None, grid=False, diagonal='hist', marker='.', density_kwds=None, hist_kwds=None, range_padding=0.05, **kwargs): Draw a matrix of scatter plots."}
{"text_id": 1007060, "text": "scatter_matrix(frame, alpha=0.5, figsize=None, ax=None, grid=False, diagonal='hist', marker='.', density_kwds=None, hist_kwds=None, range_padding=0.05, **kwargs): Draw a matrix of scatter plots."}
{"text_id": 1007061, "text": "table(ax, data, rowLabels=None, colLabels=None, **kwargs): Helper function to convert DataFrame and Series to matplotlib."}
{"text_id": 1007062, "text": "table(ax, data, rowLabels=None, colLabels=None, **kwargs): Helper function to convert DataFrame and Series to matplotlib."}
{"text_id": 1007063, "text": "assert_extension_array_equal(left, right, check_dtype=True, index_values=None, check_less_precise=<no_default>, check_exact=False, rtol: 'float' = 1e-05, atol: 'float' = 1e-08): Check that left and right ExtensionArrays are equal."}
{"text_id": 1007064, "text": "assert_extension_array_equal(left, right, check_dtype=True, index_values=None, check_less_precise=<no_default>, check_exact=False, rtol: 'float' = 1e-05, atol: 'float' = 1e-08): Check that left and right ExtensionArrays are equal."}
{"text_id": 1007065, "text": "assert_frame_equal(left, right, check_dtype=True, check_index_type='equiv', check_column_type='equiv', check_frame_type=True, check_less_precise=<no_default>, check_names=True, by_blocks=False, check_exact=False, check_datetimelike_compat=False, check_categorical=True, check_like=False, check_freq=True, check_flags=True, rtol=1e-05, atol=1e-08, obj='DataFrame'): Check that left and right DataFrame are equal."}
{"text_id": 1007066, "text": "assert_frame_equal(left, right, check_dtype=True, check_index_type='equiv', check_column_type='equiv', check_frame_type=True, check_less_precise=<no_default>, check_names=True, by_blocks=False, check_exact=False, check_datetimelike_compat=False, check_categorical=True, check_like=False, check_freq=True, check_flags=True, rtol=1e-05, atol=1e-08, obj='DataFrame'): Check that left and right DataFrame are equal."}
{"text_id": 1007067, "text": "assert_index_equal(left: 'Index', right: 'Index', exact: 'bool | str' = 'equiv', check_names: 'bool' = True, check_less_precise: 'bool | int | NoDefault' = <no_default>, check_exact: 'bool' = True, check_categorical: 'bool' = True, check_order: 'bool' = True, rtol: 'float' = 1e-05, atol: 'float' = 1e-08, obj: 'str' = 'Index') -> 'None': Check that left and right Index are equal."}
{"text_id": 1007068, "text": "assert_index_equal(left: 'Index', right: 'Index', exact: 'bool | str' = 'equiv', check_names: 'bool' = True, check_less_precise: 'bool | int | NoDefault' = <no_default>, check_exact: 'bool' = True, check_categorical: 'bool' = True, check_order: 'bool' = True, rtol: 'float' = 1e-05, atol: 'float' = 1e-08, obj: 'str' = 'Index') -> 'None': Check that left and right Index are equal."}
{"text_id": 1007069, "text": "assert_series_equal(left, right, check_dtype=True, check_index_type='equiv', check_series_type=True, check_less_precise=<no_default>, check_names=True, check_exact=False, check_datetimelike_compat=False, check_categorical=True, check_category_order=True, check_freq=True, check_flags=True, rtol=1e-05, atol=1e-08, obj='Series', *, check_index=True): Check that left and right Series are equal."}
{"text_id": 1007070, "text": "assert_series_equal(left, right, check_dtype=True, check_index_type='equiv', check_series_type=True, check_less_precise=<no_default>, check_names=True, check_exact=False, check_datetimelike_compat=False, check_categorical=True, check_category_order=True, check_freq=True, check_flags=True, rtol=1e-05, atol=1e-08, obj='Series', *, check_index=True): Check that left and right Series are equal."}
{"text_id": 1007071, "text": "hash_array(vals: 'ArrayLike', encoding: 'str' = 'utf8', hash_key: 'str' = '0123456789123456', categorize: 'bool' = True) -> 'np.ndarray': Given a 1d array, return an array of deterministic integers."}
{"text_id": 1007072, "text": "hash_array(vals: 'ArrayLike', encoding: 'str' = 'utf8', hash_key: 'str' = '0123456789123456', categorize: 'bool' = True) -> 'np.ndarray': Given a 1d array, return an array of deterministic integers."}
{"text_id": 1007073, "text": "hash_pandas_object(obj: 'Index | FrameOrSeriesUnion', index: 'bool' = True, encoding: 'str' = 'utf8', hash_key: 'str | None' = '0123456789123456', categorize: 'bool' = True) -> 'Series': Return a data hash of the Index/Series/DataFrame."}
{"text_id": 1007074, "text": "hash_pandas_object(obj: 'Index | FrameOrSeriesUnion', index: 'bool' = True, encoding: 'str' = 'utf8', hash_key: 'str | None' = '0123456789123456', categorize: 'bool' = True) -> 'Series': Return a data hash of the Index/Series/DataFrame."}
{"text_id": 1007075, "text": "fromkeys(iterable, value=None, /): Create a new dictionary with keys from iterable and values set to value."}
{"text_id": 1007076, "text": "popitem(): Remove and return a (key, value) pair as a 2-tuple."}
{"text_id": 1007077, "text": "reset(): Reset the option store to its initial state."}
{"text_id": 1007078, "text": "setdefault(key, default=None, /): Insert key with a value of default if key is not in the dictionary."}
{"text_id": 1007079, "text": "use(key, value): Temporarily set a parameter value using the with statement."}
{"text_id": 1007080, "text": "get_offset(name: 'str') -> 'DateOffset': Return DateOffset object associated with rule name."}
{"text_id": 1007081, "text": "get_period_alias(offset_str: 'str') -> 'str | None': Alias to closest period strings BQ->Q etc."}
{"text_id": 1007082, "text": "is_subperiod(source, target) -> 'bool': Returns True if downsampling is possible between source and target frequencies."}
{"text_id": 1007083, "text": "is_superperiod(source, target) -> 'bool': Returns True if upsampling is possible between source and target frequencies."}
{"text_id": 1007084, "text": "CmpKey(*args, **kwargs): The central part of internal API."}
{"text_id": 1007085, "text": "InfiniteTypes(*args, **kwargs): The central part of internal API."}
{"text_id": 1007086, "text": "LegacyCmpKey(*args, **kwargs): The central part of internal API."}
{"text_id": 1007087, "text": "LocalType(*args, **kwargs): The central part of internal API."}
{"text_id": 1007088, "text": "PrePostDevType(*args, **kwargs): The central part of internal API."}
{"text_id": 1007089, "text": "SubLocalType(*args, **kwargs): The central part of internal API."}
{"text_id": 1007090, "text": "SupportsInt(*args, **kwds): An ABC with one abstract method __int__."}
{"text_id": 1007091, "text": "Tuple(*args, **kwargs): Tuple type; Tuple[X, Y] is the cross-product type of X and Y."}
{"text_id": 1007092, "text": "VersionComparisonMethod(*args, **kwargs): The central part of internal API."}
{"text_id": 1007093, "text": "preprocess_pandas(func): Decorate a function to convert all data series arguments to `np."}
