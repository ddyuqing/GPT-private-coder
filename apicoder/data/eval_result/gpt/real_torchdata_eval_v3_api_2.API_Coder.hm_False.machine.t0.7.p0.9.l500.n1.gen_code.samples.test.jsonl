{"task_id": "TorchDataEval/0", "completion": " datapipe.cycle(6)"}
{"task_id": "TorchDataEval/1", "completion": " dp.enumerate()"}
{"task_id": "TorchDataEval/2", "completion": " next(iter(batch_dp))"}
{"task_id": "TorchDataEval/4", "completion": ""}
{"task_id": "TorchDataEval/5", "completion": " fork(source_dp, 2)\n\n# [start]\ndef fork(datapipe, num_instances, buffer_size=1000):\n    \"\"\"\n    Creates multiple instances of the same Iterable DataPipe.\n    \n    Args:\n        datapipe: torch.utils.data.dataset.IterDataPipe\n            The source Iterable DataPipe to be forked.\n        num_instances: int\n            The number of instances to be created.\n        buffer_size: int, optional (default=1000)\n            The buffer size for each forked instance.\n    \n    Returns:\n        Tuple[torch.utils.data.dataset.IterDataPipe]\n            A tuple of forked instances of the same Iterable DataPipe.\n    \"\"\"\n    dp_instances = tuple(datapipe.clone() for _ in range(num_instances))\n    for dp in dp_instances:\n        dp.buffer_size = buffer_size\n    return dp_instances\n\ndef batch(datapipe, batch_size, drop_last=False, wrapper_class=DataChunk):\n    \"\"\"\n    Create mini-batches of data.\n    \n    Args:\n        datapipe: MapDataPipe[T]\n            The source MapDataPipe to be batched.\n        batch_size: int\n            The size of each mini-batch.\n        drop_last: bool, optional (default=False)\n            Whether to drop the last batch if it is smaller than batch_size.\n        wrapper_class: type, optional (default=DataChunk)\n            The class to be used for wrapping each mini-batch.\n    \n    Returns:\n        BatchDataPipe[T]\n            The batched data as a BatchDataPipe.\n    \"\"\"\n    return BatchDataPipe(datapipe, batch_size, drop_last, wrapper_class)\n# [end]"}
{"task_id": "TorchDataEval/6", "completion": " dp1.concat(dp2, merge_fn)"}
{"task_id": "TorchDataEval/7", "completion": " dp1.map(merge_fn, input_col=0, output_col=1).map(itemgetter(1)).concat(mapdp)"}
{"task_id": "TorchDataEval/9", "completion": " SampleMultiplexer(*weights.keys(), random_seed=0)\nfilter_mul_dp = filter(sample_mul_dp, lambda x: x != 0)"}
{"task_id": "TorchDataEval/10", "completion": " unzip(source_dp, 3)"}
{"task_id": "TorchDataEval/11", "completion": " IterableWrapper(range(10))\n# Divide datapipes into 3 batches and discard if the last batch is not reached.\ndp ="}
{"task_id": "TorchDataEval/12", "completion": " bucketbatch(source_dp, batch_size=3, drop_last=False, batch_num=100, bucket_num=1, sort_key=sort_bucket, in_batch_shuffle=True)"}
{"task_id": "TorchDataEval/14", "completion": " groupby(source_dp, group_fn, buffer_size=3, group_size=3, guaranteed_group_size=2)"}
{"task_id": "TorchDataEval/16", "completion": " IterableWrapper([file_url]).datapipe(HttpReader())"}
{"task_id": "TorchDataEval/17", "completion": " flatmap(source_dp, mutiple_fn)"}
{"task_id": "TorchDataEval/18", "completion": "def add_two(x):\n    return x + 2\ndp = IterableWrapper(range(10))\n# Method 1\nmap_dp_1 = dp.map(add_one)  # Invocation via functional form is preferred\n\n# Method 2\n# We discourage the usage of `lambda` functions as they are not serializable with `pickle`\n# Using `lambda` to implement add_two rather than add_one that is mentioned in above.\nmap_dp_2 = dp.map(lambda x: x + 2)"}
{"task_id": "TorchDataEval/19", "completion": " dp.filter(is_even)"}
{"task_id": "TorchDataEval/20", "completion": " dp.header(3)"}
{"task_id": "TorchDataEval/21", "completion": " dp.rows2columnar(column_names=['a'])"}
{"task_id": "TorchDataEval/23", "completion": " map_dp_1.batch(batch_size=2)"}
{"task_id": "TorchDataEval/24", "completion": " HttpReader(URL)"}
{"task_id": "TorchDataEval/25", "completion": " HttpReader(URL) | map(lambda_func_)"}
{"task_id": "TorchDataEval/26", "completion": " batch(ag_news_train, batch_size=2).map(lambda_batch)"}
{"task_id": "TorchDataEval/27", "completion": " IterableWrapper(range(3))\n# Augment the datapipe with repeat three times and sample the data.\ndp = Sampler(dp.repeat(3), dp)"}
{"task_id": "TorchDataEval/28", "completion": " mux(concat(dp1, dp2), concat(dp1, dp2), concat(dp1, dp2))"}
{"task_id": "TorchDataEval/29", "completion": " zip_with_iter(dp1, dp2, itemgetter(0), merge_fn=merge_fn, keep_key=True)\nres_dp = zip_with_map(res_dp, dp2, itemgetter(0), merge_fn=merge_fn)\nres_dp = zip_with_iter(res_dp, dp2, itemgetter(0), merge_fn=merge_fn, keep_key=True)"}
{"task_id": "TorchDataEval/30", "completion": " zip_with_iter(dp1, dp2, itemgetter(0), itemgetter(0), True, merge_fn=merge_fn)\nfor i, item in enumerate(res_dp):\n    print(f\"Item {i}: {item}\")"}
{"task_id": "TorchDataEval/31", "completion": " zip_with_iter(dp1, dp2, itemgetter(0), itemgetter(0), True, merge_fn=merge_fn)\nres_dp = list(res_dp)\nres_dp = res_dp[0]"}
{"task_id": "TorchDataEval/32", "completion": " zip_with_iter(dp1, mapdp, itemgetter(0), merge_fn=merge_fn)\nres_dp = zip_with_iter(res_dp, mapdp, itemgetter(0), merge_fn=merge_fn)\nres_dp = zip_with_iter(res_dp, mapdp, itemgetter(0), merge_fn=merge_fn)"}
{"task_id": "TorchDataEval/33", "completion": " zip_with_map(dp1, mapdp, itemgetter(0), merge_fn)\nres_dp = res_dp.repeat(3)\nres_dp = res_dp.as_list()\nres_dp = list(map(itemgetter(1), res_dp))"}
{"task_id": "TorchDataEval/34", "completion": " zip_with_iter(dp1, mapdp, itemgetter(0), keep_key=True, merge_fn=merge_fn).repeat(3).shuffle(buffer_size=10000).to_list().map(itemgetter(2))"}
{"task_id": "TorchDataEval/35", "completion": " source_dp.groupby(group_fn, guaranteed_group_size=2)"}
{"task_id": "TorchDataEval/37", "completion": "collate(collated_ds, collate_fn)"}
{"task_id": "TorchDataEval/38", "completion": " collate(ds, collate_fn)"}
{"task_id": "TorchDataEval/40", "completion": " source_dp.demux(2, great_than_5)"}
{"task_id": "TorchDataEval/41", "completion": " SampleMultiplexer(dp1, dp2, weights=weight_, seed=1)"}
{"task_id": "TorchDataEval/42", "completion": " map(raw_dp, lambda x: x[0]), map(raw_dp, lambda x: x[1]), map(raw_dp, lambda x: x[2])"}
{"task_id": "TorchDataEval/43", "completion": " IterableWrapper([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"])\n# Make a batch operation on the datapipe `dp` of size 3 with droping last batch if it is not full.\n# And then get the first two batches.\ndp = batch(dp, 3, drop_last=True)[:2]"}
{"task_id": "TorchDataEval/44", "completion": " batch(dp1, 4, drop_last=True)[:2] + dp2"}
{"task_id": "TorchDataEval/45", "completion": " enumerate(concat(dp_source_1, dp_source_2), start=0)"}
{"task_id": "TorchDataEval/46", "completion": " concat(dp_source_1.header(limit=10), dp_source_2.header(limit=10)), concat(dp_source_1.header(limit=10), dp_source_2.header(limit=10)), concat(dp_source_1.header(limit=10), dp_source_2.header(limit=10))"}
{"task_id": "TorchDataEval/47", "completion": " concat(dp_source_1, dp_source_2, dp_source_3).enumerate()"}
{"task_id": "TorchDataEval/48", "completion": " source_dp.header().flatmap(flatted_func)"}
{"task_id": "TorchDataEval/49", "completion": " HttpReader([AG_NEWS_CSV_URL])"}
{"task_id": "TorchDataEval/3", "completion": " dp_one.concat(dp_two)"}
{"task_id": "TorchDataEval/8", "completion": " dp1.header(5).flatmap(lambda x: [x, x+1])"}
{"task_id": "TorchDataEval/13", "completion": " ds.collate(int2tensor)"}
{"task_id": "TorchDataEval/15", "completion": " unbatch(source_dp, unbatch_level=1)"}
{"task_id": "TorchDataEval/22", "completion": " StreamReader(dp, chunk=1)"}
{"task_id": "TorchDataEval/39", "completion": " [remove_final_number(item) for item in dp_dog] + [remove_final_number(item) for item in dp_cat]"}
{"task_id": "TorchDataEval/36", "completion": " groupby(source_dp, group_fn)\nheader_groups = header(dp0)"}
