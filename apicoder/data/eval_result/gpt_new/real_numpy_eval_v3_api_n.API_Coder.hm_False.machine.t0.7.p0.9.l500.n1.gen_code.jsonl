{"task_id": "NumpyEval/0", "success": true, "generated_code": "# [start]\n# array(obj, itemsize=None, copy=True, unicode=None, order=None): Create a `chararray`.\n# [end]\nimport numpy as np\n\n# create a numpy array composed of a list [[8, 7, 2], [5, 6, 1], [8, 2, 6]]\narray = np.array([[8, 7, 2], [5, 6, 1], [8, 2, 6]])", "error": "", "token_usage": [[175, 107]], "time_usage": [3.6521482467651367]}
{"task_id": "NumpyEval/4", "success": true, "generated_code": "# [start]\n# column_stack(x, *args, **params): column_stack(*args, **kwargs) Stack 1-D arrays as columns into a 2-D array.\n# [end]\nimport numpy as np\n\na = np.array([[1,3,4],[1,2,3],[1,2,1]])\nb = np.array([1,2,3])\n# How to add items into a numpy array?\n# add one element to each row using column stack operation.\nc = np.column_stack((a, b))", "error": "", "token_usage": [[206, 116]], "time_usage": [3.7744688987731934]}
{"task_id": "NumpyEval/5", "success": true, "generated_code": "c = np.concatenate((a, b))", "error": "", "token_usage": [[184, 13]], "time_usage": [0.8905577659606934]}
{"task_id": "NumpyEval/6", "success": true, "generated_code": "# [start]\n# slice(self, *args, **kwargs): Convenience fluent method for :py:func:`slice`.\n# [end]\nimport numpy as np\n\nm = np.arange(2*3*5).reshape((2,3,5))\naxis, start, end = 2, 1, 3\ntarget = m[:, :, 1:3]\nslc = [slice(None)] * len(m.shape)\n# I would like to dynamically slice a numpy array along a specific axis.\n# I think one way would be to use slice(start, end):\n\n# Dynamically slice a numpy array along a specific axis\ndef dynamic_slice(arr, axis, start, end):\n    slc[axis] = slice(start, end)\n    return arr[tuple(slc)]\n\n# Example usage\nresult = dynamic_slice(m, axis, start, end)\nprint(result)", "error": "", "token_usage": [[221, 185]], "time_usage": [5.789502859115601]}
{"task_id": "NumpyEval/7", "success": true, "generated_code": "# [start]\n# sum(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Sum of array elements over a given axis.\n# [end]\nimport numpy as np\n\na = np.arange(2*3*2).reshape((2,3,2))\n# How to count values in a certain range in a Numpy array?\n# the number of elements fulfilling 2 < x < 8 is:\ncount_value = np.count_nonzero((a > 2) & (a < 8))", "error": "", "token_usage": [[205, 124]], "time_usage": [4.023516416549683]}
{"task_id": "NumpyEval/8", "success": true, "generated_code": "import numpy as np\n\n# I have a NumPy array that looks like this:\narr = np.array([100.10, 200.42, 4.14, 89.00, 34.55, 1.12])\n# How can I get multiple values from this array by index?\n# How can I get the values at the index positions 1 and 4?\nresult_arr = arr[[1, 4]]", "error": "", "token_usage": [[186, 96]], "time_usage": [3.346703052520752]}
{"task_id": "NumpyEval/9", "success": true, "generated_code": "# [start]\n# imag(val): Return the imaginary part of the complex argument.\n# abs(self, *args, **kwargs): Convenience fluent method for :py:func:`abs`.\n# [end]\nimport numpy as np\n\na = np.array([0 +  0.5j, 0.25 + 1.2352444e-24j, 0.25+ 0j, 2.46519033e-32 + 0j])\ntol = 1e-16\n# what is the fastest and easiest way to set the super low value named tol to zero?\n# Handling of real and imaginary numbers separately\na.real[np.abs(a.real) < tol] = 0\n# [start]\n# Set the super low value named tol to zero\ntol = 0\n# [end]", "error": "", "token_usage": [[252, 178]], "time_usage": [4.807550668716431]}
{"task_id": "NumpyEval/10", "success": true, "generated_code": "# [start]\n# fill_diagonal(a, val, wrap=False): Fill the main diagonal of the given array of any dimensionality.\n# [end]\nimport numpy as np\nimport pandas as pd\n\ndf = pd.DataFrame({'A':[1,2,3], 'B':[1,2,3], 'C':[1,2,3]})\n# I have a pandas dataframe I would like to set the diagonal to 0\n\ndef fill_diagonal(a, val, wrap=False):\n    np.fill_diagonal(a.values, val, wrap)\n\nfill_diagonal(df, 0)", "error": "", "token_usage": [[192, 125]], "time_usage": [3.8578343391418457]}
{"task_id": "NumpyEval/11", "success": true, "generated_code": "result = np.all(a == a[0, :], axis=0)", "error": "", "token_usage": [[233, 19]], "time_usage": [1.116363525390625]}
{"task_id": "NumpyEval/12", "success": true, "generated_code": "new_arr = np.fromstring(ts, dtype=int)", "error": "", "token_usage": [[222, 15]], "time_usage": [1.0652525424957275]}
{"task_id": "NumpyEval/13", "success": true, "generated_code": "import numpy as np\n\na = np.zeros((2,5))\n# How can I get the shape of NumPy array?\na_shape = a.shape", "error": "", "token_usage": [[131, 36]], "time_usage": [1.7347419261932373]}
{"task_id": "NumpyEval/14", "success": true, "generated_code": "array = np.array(list(result.items()), dtype=dtype)", "error": "", "token_usage": [[269, 16]], "time_usage": [0.9544785022735596]}
{"task_id": "NumpyEval/15", "success": true, "generated_code": "sum_value = df.sum().sum()", "error": "", "token_usage": [[213, 12]], "time_usage": [0.9710268974304199]}
{"task_id": "NumpyEval/17", "success": true, "generated_code": "# [start]\n# in1d(ar1, ar2, assume_unique=False, invert=False): Test whether each element of a 1-D array is also present in a second array.\n# [end]\nimport numpy as np\n\na = np.array([1,2,3,4,5,6])\nb = np.array([1,4,5])\n\n# Is there a way to compare what elements in a exist in b?\n# Return a array of booleans, True if elements in a exist in b, False otherwise\nc = np.in1d(a, b)", "error": "", "token_usage": [[215, 125]], "time_usage": [4.234756708145142]}
{"task_id": "NumpyEval/18", "success": true, "generated_code": "# [start]\n# mean(a, axis=None, dtype=None, out=None, keepdims=False): Compute the arithmetic mean along the specified axis.\n# [end]\nimport numpy as np\n\na = np.array([10, 20, 30])\nb = np.array([30, 20, 20])\nc = np.array([50, 20, 40])\n\n# I'd like to calculate element-wise average between a, b and c.\nmean_array = np.mean([a, b, c], axis=0)", "error": "", "token_usage": [[199, 115]], "time_usage": [3.4827473163604736]}
{"task_id": "NumpyEval/19", "success": true, "generated_code": "result = np.where(np.diff(a) != 0)[0] + 1", "error": "", "token_usage": [[254, 22]], "time_usage": [1.2095234394073486]}
{"task_id": "NumpyEval/20", "success": true, "generated_code": "b = a[..., newaxis]", "error": "", "token_usage": [[194, 11]], "time_usage": [0.9258975982666016]}
{"task_id": "NumpyEval/21", "success": true, "generated_code": "# [start]\n# std(self, axis=None, dtype=None, out=None, ddof=0): Return the standard deviation of the array elements along the given axis.\n# [end]\nimport numpy as np\n\narr = np.array([[1, 2, 3], [3, 4, 5], [5, 6, 7]])\n# How to invoke the standard deviation function on a 2d array?\n# with axis=0, it will return a 1d array with the standard deviation of each column\narr_sd = np.std(arr, axis=0)", "error": "", "token_usage": [[217, 127]], "time_usage": [3.782329797744751]}
{"task_id": "NumpyEval/16", "success": true, "generated_code": "# [start]\n# join(self, iterable_of_bytes, /): Concatenate any number of bytes objects.\n# [end]\nimport numpy as np\n\na = np.arange(0,10)\n# How to print a Numpy array without brackets?\n# For example, I want to convert a = np.array([1,2,3,4,5]) into a_string = \"1 2 3 4 5\".\na_string = ' '.join(a.astype(str))", "error": "", "token_usage": [[194, 103]], "time_usage": [3.5548741817474365]}
{"task_id": "NumpyEval/22", "success": true, "generated_code": "import numpy as np\nfrom numpy import newaxis\n\na = np.array([\n     [1,2],\n     [3,4],\n     [5,6],\n     [7,8]])\n\nb = np.array([1,2,3,4])\n\n# multiply arrays rowwise\n# Basically out[i] = a[i] * b[i], where a[i].shape is (2,) and b[i] then is a scalar.\n# What's the trick?\nout = a * b[:,newaxis]", "error": "", "token_usage": [[200, 109]], "time_usage": [3.8047728538513184]}
{"task_id": "NumpyEval/23", "success": true, "generated_code": "# [start]\n# reshape(a, newshape, order='C'): Gives a new shape to an array without changing its data.\n# [end]\nimport numpy as np\n\nx = np.array([[1], [2], [3]])\n# Numpy Vector (N,1) dimension -> (N,) dimension conversion\nout = np.reshape(x, x.shape[0])", "error": "", "token_usage": [[170, 81]], "time_usage": [2.6381826400756836]}
{"task_id": "NumpyEval/24", "success": true, "generated_code": "fromarrays(arrayList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Create a record array from a (flat) list of arrays.\n\nimport numpy as np\n\nmyarray = np.array([(\"Hello\",2.5,3),(\"World\",3.6,2)])\n# Converting a 2D numpy array to a structured array\n# You can 'create a record array from a (flat) list of arrays' using numpy.core.records.fromarrays as follows:\n# Note that we need conduct the transpose on the array, and the names reset to 'col1, co2, col3'\nnewrecarray = np.core.records.fromarrays(myarray.T, names='col1, col2, col3')", "error": "", "token_usage": [[251, 164]], "time_usage": [5.3034443855285645]}
{"task_id": "NumpyEval/25", "success": true, "generated_code": "myarray = np.stack(list_of_arrays)", "error": "", "token_usage": [[296, 13]], "time_usage": [0.9177041053771973]}
{"task_id": "NumpyEval/26", "success": true, "generated_code": "# [start]\n# histogram(a, bins=10, range=None, normed=None, weights=None, density=None): Compute the histogram of a dataset.\n# cumsum(a, axis=None, dtype=None, out=None): Return the cumulative sum of the elements along a given axis.\n# [end]\nimport numpy as np\n\narr = np.array([[1,2,3], [4,5,6], [7,8,9]])\n# How to get the cumulative distribution function with NumPy?\n# set bins to 10\n# and then generate a cumulative sum of the histogram contents to variable hist self\nhist, bin_edges = np.histogram(arr, bins=10, density=True)\ncumulative_hist = np.cumsum(hist)", "error": "", "token_usage": [[234, 156]], "time_usage": [4.896481275558472]}
{"task_id": "NumpyEval/27", "success": true, "generated_code": "# [start]\n# array(object, dtype=None, ctx=None): Create an array.\n# [end]\nimport numpy as np\n\na = np.array([0,33,4444522])\n# Converting int arrays to string arrays in numpy without truncation\na_str = np.array2string(a, separator=',', formatter={'int_kind': lambda x: str(x)})", "error": "", "token_usage": [[159, 81]], "time_usage": [2.6556599140167236]}
{"task_id": "NumpyEval/28", "success": true, "generated_code": "# [start]\n# setxor1d(ar1, ar2, assume_unique=False): Find the set exclusive-or of two arrays.\n# [end]\nimport numpy as np\n\na = np.array([1,2,3,4,5,6])\nb = np.array([2,3,5])\n\n# Perform a symmetric difference between two numpy arrays.\n# Don't convert the numpy array to a set to perform exclusive-or. Use setxor1d directly.\ndiff_arr = np.setxor1d(a, b)", "error": "", "token_usage": [[202, 113]], "time_usage": [3.5097506046295166]}
{"task_id": "NumpyEval/29", "success": true, "generated_code": "# [start]\n# all(self, axis=None, out=None): Test whether all matrix elements along a given axis evaluate to True.\n# [end]\nimport numpy as np\n\narr = np.array([[ 1.41421356, 0.70710678, 0.70710678], [0., 1.22474487,1.22474487], [0., 0., 0.]])\n# remove zero rows 2-D numpy array\n# Use np.all with an axis argument:\nnew_arr = arr[np.all(arr != 0, axis=1)]", "error": "", "token_usage": [[212, 126]], "time_usage": [3.739597797393799]}
{"task_id": "NumpyEval/30", "success": true, "generated_code": "# [start]\n# add(x1, x2): Return element-wise string concatenation for two arrays of str or unicode.\n# [end]\nimport numpy as np\n\na1=np.array(['a','b'])\na2=np.array(['E','F'])\n# I am trying to do element-wise string concatenation.\n# I thought Add() was the way to do it in numpy but obviously it is not working as expected.\nresult = np.char.add(a1, a2)", "error": "", "token_usage": [[191, 102]], "time_usage": [3.862438678741455]}
{"task_id": "NumpyEval/31", "success": true, "generated_code": "import numpy as np\n\ndat = np.array([[1,2,3], [4,5,np.nan], [np.nan,6,np.nan]])\nmdat = np.ma.masked_array(dat,np.isnan(dat))\n\n# Calculate the mean values along the rows of the matrix, excluding NaN values\nmm = np.ma.mean(mdat, axis=1, keepdims=True)", "error": "", "token_usage": [[242, 79]], "time_usage": [2.9705560207366943]}
{"task_id": "NumpyEval/32", "success": true, "generated_code": "import numpy as np\n\n# I have a 2D numpy array of shape (N,2) which is holding N points.\na = np.array([(3, 2), (6, 2), (3, 6), (3, 4), (5, 3)])\n# Sorting it such that my points are ordered by x-coordinate, and then by y in cases where the x coordinate is the same, and get the values by inplace\nind = np.lexsort((a[:, 1], a[:, 0]))", "error": "", "token_usage": [[199, 115]], "time_usage": [3.8761348724365234]}
{"task_id": "NumpyEval/33", "success": true, "generated_code": "a_list = a.flatten().tolist()[0]", "error": "", "token_usage": [[219, 14]], "time_usage": [1.019136905670166]}
{"task_id": "NumpyEval/34", "success": true, "generated_code": "import numpy as np\n\na = np.arange(9)\na = a.reshape((3, 3))\nb = np.zeros((5, 5))\n# Copy numpy array 'a' into part of another array 'b' in [1:4, 1:4]\nb[1:4, 1:4] = a", "error": "", "token_usage": [[160, 76]], "time_usage": [2.5836615562438965]}
{"task_id": "NumpyEval/35", "success": true, "generated_code": "import numpy as np\n\na = np.array([1, 2, 3])\nb = np.array([4, 5])\n# if function is c(i, j) = a(i) + b(j)*2:\nc = np.zeros((len(a), len(b)))\nfor i in range(len(a)):\n    for j in range(len(b)):\n        c[i][j] = a[i] + b[j] * 2\nc", "error": "", "token_usage": [[151, 97]], "time_usage": [3.3272156715393066]}
{"task_id": "NumpyEval/36", "success": true, "generated_code": "import numpy as np\n\na = np.array([[ 0.,  0.,  0.],\n              [ 0.,  0.,  0.],\n              [ 0.,  0.,  0.],\n              [ 0.,  0.,  0.],\n              [ 0.,  0.,  0.]])\nx = np.ones(5)\n\n# Assigning array x to the 2nd column of array a.\na[:, 1] = x", "error": "", "token_usage": [[202, 112]], "time_usage": [3.689944267272949]}
{"task_id": "NumpyEval/37", "success": true, "generated_code": "# [start]\n# compressed(x): Return all the non-masked data as a 1-D array.\n# [end]\nimport numpy as np\n\ny = np.array([2,1,5,2])          # y axis\n# filter out values larger than 2\nm = np.ma.masked_where(y>2, y)   \n# remove masked values from m\nout = m.compressed()", "error": "", "token_usage": [[375, 177]], "time_usage": [11.049951314926147]}
{"task_id": "NumpyEval/38", "success": true, "generated_code": "# [start]\n# astype(self, dtype, copy=True): Returns a copy of the array after casting to a specified type.\n# [end]\nimport numpy as np\n\na = np.zeros(4, dtype=\"float64\")\n# Convert numpy array type and values from Float64 to Float32\nb = a.astype(np.float32)", "error": "", "token_usage": [[166, 74]], "time_usage": [2.3337152004241943]}
{"task_id": "NumpyEval/39", "success": true, "generated_code": "vals = np.fromiter(Samples.values(), dtype=float)", "error": "", "token_usage": [[257, 16]], "time_usage": [0.9467628002166748]}
{"task_id": "NumpyEval/40", "success": true, "generated_code": "concated_arr = np.concatenate(L, axis=0)", "error": "", "token_usage": [[270, 16]], "time_usage": [1.014402151107788]}
{"task_id": "NumpyEval/41", "success": true, "generated_code": "# [start]\n# argmin(a, axis=None, out=None): Returns the indices of the minimum values along an axis.\n# [end]\nimport numpy as np\nx = np.array([[0, 1], [3, 2]])\n# Return the indices of the minimum values along (axis is zero).\nout = np.argmin(x, axis=0)", "error": "", "token_usage": [[169, 80]], "time_usage": [2.6813597679138184]}
{"task_id": "NumpyEval/42", "success": true, "generated_code": "# [start]\n# arange(*args, **params): arange([start,] stop[, step,], dtype=None, *, like=None) Return evenly spaced values within a given interval.\n# [end]\nimport numpy as np\n\ndef broadcasting_app(a, L, S):  # Window len = L, Stride len/stepsize = S\n    \"\"\"\n    I want to create a matrix of sub sequences from this array of length L with stride S.\n    Return the numpy array of sub sequences.\n    \"\"\"\n    nrows = ((a.size-L)//S)+1\n    ncols = L\n    return np.lib.stride_tricks.as_strided(a, shape=(nrows, ncols), strides=(a.itemsize*S, a.itemsize))", "error": "", "token_usage": [[221, 158]], "time_usage": [4.628400802612305]}
{"task_id": "NumpyEval/43", "success": true, "generated_code": "import numpy as np\n\na = np.array([[1, 2],\n           [3, 4]])\nb = np.array([1,1])\n# I'd like to use b in index a, I would like to get 4 instead of [a[1], a[1]]\n# the code below is the solution\nout = a[b[1], b[1]]", "error": "", "token_usage": [[172, 83]], "time_usage": [2.600584030151367]}
{"task_id": "NumpyEval/44", "success": true, "generated_code": "# [start]\n# abs(a, *args, **kwargs): absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the absolute value element-wise.\n# argmin(self, axis=None, out=None): Indexes of the minimum values along an axis.\n# [end]\nimport numpy as np\n\ndef find_nearest(array, value):\n    array = np.asarray(array)\n    # Find nearest value in numpy array\n    idx = (np.abs(array - value)).argmin()\n    return array[idx]", "error": "", "token_usage": [[216, 130]], "time_usage": [3.9185404777526855]}
{"task_id": "NumpyEval/45", "success": true, "generated_code": "# [start]\n# vstack(tup): Stack arrays in sequence vertically (row wise).\n# hstack(arrays): Stack arrays in sequence horizontally (column wise).\n# [end]\nimport numpy as np\n\ndef append_arr_to_new_empty_arr(arr1, arr2):\n    new_arr = np.array([])\n    new_arr = np.vstack((arr1, arr2))\n    # How to add a new row to an empty numpy array\n    # example: \n    # input: np.array([1,2,3]) and np.array([4,5,6])\n    # output: np.array([[1,2,3],[4,5,6]])\n    # Return the new array\n    return new_arr", "error": "", "token_usage": [[233, 153]], "time_usage": [4.405021667480469]}
{"task_id": "NumpyEval/46", "success": true, "generated_code": "# [start]\n# squeeze(self, axis=None): Return a possibly reshaped matrix.\n# asarray(a, dtype=None, order=None): Convert the input to a masked array of the given data-type.\n# [end]\nimport numpy as np\n\ndef matrix_to_array(matrix):\n    # I am using numpy. I have a matrix with 1 column and N rows and I want to get an array from with N elements.\n    # For example, if i have M = matrix([[1], [2], [3], [4]]), I want to get A = array([1,2,3,4]).\n    # Return the array\n    return np.squeeze(np.asarray(matrix))", "error": "", "token_usage": [[235, 145]], "time_usage": [4.1425957679748535]}
{"task_id": "NumpyEval/47", "success": true, "generated_code": "m = np.repeat(a[cond], n)", "error": "", "token_usage": [[242, 14]], "time_usage": [1.3506755828857422]}
{"task_id": "NumpyEval/48", "success": true, "generated_code": "import numpy as np\n\ndef get_multiply_diff(t):\n    # Is there a function that returns an array with the results of dividing the next element by the previous one? Like a \"diff()\", but with dividing\n    # Not-numpy-example:\n    # source = [1,3,6,24,36]\n    # target = [j / i for i, j in zip(source[:-1], source[1:])]\n    # Return: target implemented in numpy.\n    return np.divide(t[1:], t[:-1])", "error": "", "token_usage": [[199, 113]], "time_usage": [3.507883310317993]}
{"task_id": "NumpyEval/49", "success": true, "generated_code": "out = np.unravel_index(np.argmin(A), A.shape)", "error": "", "token_usage": [[209, 19]], "time_usage": [1.1730694770812988]}
{"task_id": "NumpyEval/50", "success": true, "generated_code": "import numpy as np\n\ndef crop(arr, top, bottom, left, right):\n    # How do I extract a sub-array from a numpy 2d array? \n    # I'd like to extract a numpy array with a specified size from a numpy 2d array--essentially I want to crop the array.\n    # Return a sub-array from a numpy 2d array.\n    return arr[top:bottom, left:right]", "error": "", "token_usage": [[182, 94]], "time_usage": [3.3166255950927734]}
{"task_id": "NumpyEval/51", "success": true, "generated_code": "np.vectorize(my_dict.get)(a)", "error": "", "token_usage": [[248, 13]], "time_usage": [0.9805405139923096]}
{"task_id": "NumpyEval/52", "success": true, "generated_code": "# [start]\n# where(condition, x=<no value>, y=<no value>): Return a masked array with elements from `x` or `y`, depending on condition.\n# [end]\nimport numpy as np\n\nx = np.array([range(100, 1, -1)])\n# This will tell me those values\n# generate a mask to find all values that are even numbers\n# Is there an efficient Numpy mechanism to retrieve the integer indexes of locations in an array based on a condition is true as opposed to the Boolean mask array?\nout = np.where(x % 2 == 0)", "error": "", "token_usage": [[214, 129]], "time_usage": [4.26921820640564]}
{"task_id": "NumpyEval/53", "success": true, "generated_code": "# [start]\n# split(sep=None, maxsplit=-1): Return a list of the words in the string, using sep as the delimiter string.\n# where(condition, x=None, y=None): where(condition, [x, y]) Return elements chosen from `x` or `y` depending on `condition`.\n# diff(a, n=1, axis=-1, prepend=<no value>, append=<no value>): Calculate the n-th discrete difference along the given axis.\n# [end]\nimport numpy as np\n\ndef consecutive(data, stepsize=1):\n    # How to find the groups of consecutive elements in a NumPy array\n    # I have to cluster the consecutive elements from a NumPy array. Considering the following example\n    # a = [ 0, 47, 48, 49, 50, 97, 98, 99]\n    # The output should be a list of tuples as follows\n    # [(0), (47, 48, 49, 50), (97, 98, 99)]\n    # Here the difference is just one between the elements. It will be great if the difference can also be specified as a limit or a hardcoded number.\n    # Finally, return the number of consecutive elements in the array.\n    groups = np.split(data, np.where(np.diff(data) != stepsize)[0]+1)\n    return [tuple(group) for group in groups]", "error": "", "token_usage": [[368, 303]], "time_usage": [8.351972579956055]}
{"task_id": "NumpyEval/54", "success": true, "generated_code": "out = dists[(dists >= r) & (dists < r+dr)]", "error": "", "token_usage": [[328, 24]], "time_usage": [1.3061950206756592]}
{"task_id": "NumpyEval/55", "success": true, "generated_code": "import numpy as np\n\ndef xor_operation(x, y, z):\n    \"\"\"\n    How can I define in numpy a matrix that uses operations modulo 2?\n    This operation is called \"xor\".\n    Arguments:\n        x: a numpy array\n        y: a numpy array\n        z: a numpy array\n    Returns:\n        a numpy array containing the result of the operation\n    \"\"\"\n    return np.mod(np.add(np.add(x, y), z), 2)", "error": "", "token_usage": [[182, 101]], "time_usage": [3.2897849082946777]}
{"task_id": "NumpyEval/56", "success": true, "generated_code": "# [start]\n# array(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0): An array class with possibly masked values.\n# flatten(self, order='C'): Return a copy of the array collapsed into one dimension.\n# [end]\nimport numpy as np\n\na = np.array([ 0,  3,  6,  9, 12])\nb = np.array([ 1,  4,  7, 10, 13])\nc = np.array([ 2,  5,  8, 11, 14])\n\n# How can I join them using numpy methods\n# You can transpose and flatten the arrays:\nd = np.array([a, b, c]).T.flatten()", "error": "", "token_usage": [[270, 184]], "time_usage": [5.689358711242676]}
{"task_id": "NumpyEval/57", "success": true, "generated_code": "out = np.unique(a, axis=0)", "error": "", "token_usage": [[254, 14]], "time_usage": [4.713712930679321]}
{"task_id": "NumpyEval/58", "success": true, "generated_code": "# [start]\n# norm(self, *args, **kwargs): Convenience fluent method for :py:func:`norm`.\n# [end]\nimport numpy as np\n\na = np.array((1,2,3))\nb = np.array((4,5,6))\n# How can the Euclidean distance be calculated with NumPy?\ndist = np.linalg.norm(a-b)", "error": "", "token_usage": [[172, 81]], "time_usage": [2.5757923126220703]}
{"task_id": "NumpyEval/59", "success": true, "generated_code": "result = np.array(data, dtype=object)\nresult = np.array([np.pad(d, (0, max(map(len, data)) - len(d)), constant_values=0) for d in data], dtype=object)", "error": "", "token_usage": [[196, 50]], "time_usage": [1.9890062808990479]}
{"task_id": "NumpyEval/60", "success": true, "generated_code": "# [start]\n# arange(*args, **params): arange([start,] stop[, step,], dtype=None, *, like=None) Return evenly spaced values within a given interval.\n# [end]\nimport numpy as np\n\n# We array `data` defines the columns of the nonzero elements in the output array.\ndata = np.array([1, 0, 3])\n# We need to also define the rows and then use fancy indexing in the following way:\nresult = np.zeros((data.size, data.max()+1))\n# Convert array of indices to 1-hot encoded numpy array\nresult[np.arange(data.size), data] = 1\nresult", "error": "", "token_usage": [[228, 142]], "time_usage": [4.478992700576782]}
{"task_id": "NumpyEval/61", "success": true, "generated_code": "# [start]\n# delete(arr, obj, axis=None): Return a new array with sub-arrays along an axis deleted.\n# [end]\nimport numpy as np\n\ndata = np.array([1,2,3,4,5,6,7,8,9])\n# How to remove specific elements in a numpy array\uff1f\n# I then want to remove 3,4,7 from a. All I know is the index of the values (index=[2,3,6]).\nindex = [2, 3, 6]\nresult = np.delete(data, index)", "error": "", "token_usage": [[217, 125]], "time_usage": [3.9666261672973633]}
{"task_id": "NumpyEval/62", "success": true, "generated_code": "# [start]\n# all(self, axis=None, out=None): Test whether all matrix elements along a given axis evaluate to True.\n# [end]\nimport numpy as np\n\na = np.array([1,2,3,4,5])\n# I have a numpy array and I like to check if it is sorted.\n# Using numpy.all to do this.\nis_sorted = np.all(np.diff(a) >= 0)", "error": "", "token_usage": [[180, 92]], "time_usage": [2.7054593563079834]}
{"task_id": "NumpyEval/63", "success": true, "generated_code": "# [start]\n# ones(shape, dtype=None, order='C', *, like=None): Return a new array of given shape and type, filled with ones.\n# [end]\nimport numpy as np\n\n# How do I create a numpy array of arbitrary shape 3x4 filled with all True?\ndata = np.ones((3, 4), dtype=bool)", "error": "", "token_usage": [[166, 79]], "time_usage": [2.5325090885162354]}
{"task_id": "NumpyEval/64", "success": true, "generated_code": "import numpy as np\n\ndef replace_elements_that_greater_than_value(arr, value, new_value):\n    # Replace all elements of Python NumPy Array that are greater than `value` with `new_value`\n    # Return the array\n    arr[arr > value] = new_value\n    return arr", "error": "", "token_usage": [[149, 65]], "time_usage": [2.31238055229187]}
{"task_id": "NumpyEval/65", "success": true, "generated_code": "# [start]\n# concatenate(arrays, axis=0): Concatenate a sequence of arrays along the given axis.\n# [end]\nimport numpy as np\n\ndef concatenate_two_arrays(arr1, arr2):\n    # Concatenate a NumPy array to another NumPy array\n    return np.concatenate((arr1, arr2))", "error": "", "token_usage": [[159, 72]], "time_usage": [2.311967372894287]}
{"task_id": "NumpyEval/66", "success": true, "generated_code": "import numpy as np\n\ndef numpy_is_empty(arr):\n    # How can I check whether a numpy array is empty or not?\n    # Return the result that contains True or False\n    return np.size(arr) == 0", "error": "", "token_usage": [[141, 51]], "time_usage": [1.97153902053833]}
{"task_id": "NumpyEval/67", "success": true, "generated_code": "def count_true_number(arr):\n    # How to count the number of true elements in a NumPy bool array?\n    # return the count value\n    return np.sum(arr)", "error": "", "token_usage": [[183, 40]], "time_usage": [1.7059662342071533]}
{"task_id": "NumpyEval/68", "success": true, "generated_code": "# [start]\n# vstack(tup): Stack arrays in sequence vertically (row wise).\n# [end]\nimport numpy as np\n\ndef add_row_to_arr(arr, row):\n    # How does one add rows to a numpy array?\n    # Is there a numpythonic way to do this?\n    return np.vstack((arr, row))", "error": "", "token_usage": [[164, 75]], "time_usage": [2.6576335430145264]}
{"task_id": "NumpyEval/69", "success": true, "generated_code": "b = a[3:]", "error": "", "token_usage": [[144, 10]], "time_usage": [0.8835544586181641]}
{"task_id": "NumpyEval/70", "success": true, "generated_code": "result = arr.reshape((arr.shape[0]*arr.shape[1], arr.shape[2]))", "error": "", "token_usage": [[200, 24]], "time_usage": [1.2857565879821777]}
{"task_id": "NumpyEval/71", "success": true, "generated_code": "# [start]\n# squeeze(a, axis=None): Remove axes of length one from `a`.\n# asarray(a, dtype=None, order=None): Convert the input to a masked array of the given data-type.\n# [end]\nimport numpy as np\n\ndef matrix2array(M):\n    # I am using numpy. I have a matrix `M` 1*N and I want to get an array from with N elements.\n    # To achieve it, Does anyone know a more elegant way to get the result?\n    return np.squeeze(np.asarray(M))", "error": "", "token_usage": [[208, 118]], "time_usage": [3.618624687194824]}
{"task_id": "NumpyEval/72", "success": true, "generated_code": "# [start]\n# where(condition, x=<no value>, y=<no value>): Return a masked array with elements from `x` or `y`, depending on condition.\n# [end]\nimport numpy as np\n\ndef find_indices_zero(arr):\n    # Find indices of elements equal to zero in a NumPy array\n    # Return the indices\n    return np.where(arr == 0)", "error": "", "token_usage": [[174, 85]], "time_usage": [2.5720603466033936]}
{"task_id": "NumpyEval/73", "success": true, "generated_code": "# [start]\n# bincount(x, weights=None, minlength=0): Count number of occurrences of each value in array of non-negative ints.\n# argmax(a, axis=None, out=None): Returns the indices of the maximum values along an axis.\n# [end]\nimport numpy as np\n\ndef find_most_frequent_number(arr):\n    # Find the most frequent number in a NumPy array\n    # Return the number\n    unique_values, counts = np.unique(arr, return_counts=True)\n    max_count_index = np.argmax(counts)\n    return unique_values[max_count_index]", "error": "", "token_usage": [[190, 124]], "time_usage": [3.750072479248047]}
{"task_id": "NumpyEval/74", "success": true, "generated_code": "# [start]\n# stack(arrays, axis=0, out=None): Join a sequence of arrays along a new axis.\n# [end]\nimport numpy as np\n\n# List of arrays.\nL = [np.random.randn(5,4,2,5,1,2) for i in range(10)]\n# Stack them using axis that is negative one .\nM = np.stack(L, axis=-1)", "error": "", "token_usage": [[179, 90]], "time_usage": [2.6055188179016113]}
{"task_id": "NumpyEval/75", "success": true, "generated_code": "# [start]\n# append(object, /): Append object to the end of the list.\n# [end]\nimport numpy as np\n\ndef add_first_element_to_arr(arr):\n    # I want to add the first element on to the end of the array.\n    # Return the appended array.\n    arr.append(arr[0])\n    return arr", "error": "", "token_usage": [[162, 75]], "time_usage": [2.7927186489105225]}
{"task_id": "NumpyEval/76", "success": true, "generated_code": "import numpy as np\n\ndef convert_string_in_array_to_float(arr):\n    # How to convert an array of strings to an array of floats in numpy?\n    # Return the final result\n    return np.array(arr, dtype=float)", "error": "", "token_usage": [[140, 51]], "time_usage": [1.7427294254302979]}
{"task_id": "NumpyEval/77", "success": true, "generated_code": "# [start]\n# argmax(a, axis=None, out=None): Returns the indices of the maximum values along an axis.\n# [end]\nimport numpy as np\n\ndef get_index_max_element(arr, axis_value):\n    # How to get the index of a maximum element in a NumPy array along axis_value?\n    # Return the result\n    return np.argmax(arr, axis=axis_value)", "error": "", "token_usage": [[173, 86]], "time_usage": [2.9172422885894775]}
{"task_id": "NumpyEval/78", "success": true, "generated_code": "import numpy as np\n\ndef arr2tuple(arr):\n    # Convert numpy array to tuple\n    # Return the transformed tuple\n    return tuple(arr)", "error": "", "token_usage": [[128, 35]], "time_usage": [1.5394327640533447]}
{"task_id": "NumpyEval/79", "success": true, "generated_code": "# [start]\n# any(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Test whether any array element along a given axis evaluates to True.\n# [end]\nimport numpy as np\n\ndef test_arr_contain_only_zeros(arr):\n    # Test if numpy array contains only zeros\n    # Return the result\n    return np.any(arr != 0, axis=None)", "error": "", "token_usage": [[175, 89]], "time_usage": [2.8464138507843018]}
{"task_id": "NumpyEval/80", "success": true, "generated_code": "# [start]\n# where(condition, x=None, y=None): where(condition, [x, y]) Return elements chosen from `x` or `y` depending on `condition`.\n# logical_and(a, b, *args, **kwargs): logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Compute the truth value of x1 AND x2 element-wise.\n# [end]\nimport numpy as np\n\ndef find_index_within_range(arr, low, high):\n    # find index of the elements within range [low, high]\n    # Return the final array of indices.\n    condition = np.logical_and(arr >= low, arr <= high)\n    indices = np.where(condition)\n    return indices", "error": "", "token_usage": [[247, 174]], "time_usage": [4.879316329956055]}
{"task_id": "NumpyEval/81", "success": true, "generated_code": "# [start]\n# isnan(x, /): Return True if x is a NaN (not a number), and False otherwise.\n# [end]\nimport numpy as np\n\ndef convert_nan_to_zero(arr):\n    # convert nan value to zero\n    # Return the changed array\n    arr[np.isnan(arr)] = 0\n    return arr", "error": "", "token_usage": [[160, 76]], "time_usage": [2.3991281986236572]}
{"task_id": "NumpyEval/82", "success": true, "generated_code": "# [start]\n# isnan(x, /): Return True if x is a NaN (not a number), and False otherwise.\n# any(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Test whether any array element along a given axis evaluates to True.\n# [end]\nimport numpy as np\n\ndef remove_all_rows_contain_non_numeric_values(arr):\n    # How to remove all rows in a numpy.ndarray that contain non-numeric values?\n    # Return the final result\n    mask = np.isnan(arr).any(axis=1)\n    result = arr[~mask]\n    return result", "error": "", "token_usage": [[209, 135]], "time_usage": [3.8971428871154785]}
{"task_id": "NumpyEval/83", "success": true, "generated_code": "result = np.where(a < 0, 0, a)", "error": "", "token_usage": [[201, 18]], "time_usage": [1.0944886207580566]}
{"task_id": "NumpyEval/84", "success": true, "generated_code": "import numpy as np\n\ndef interweaving_two_arrays(a, b):\n    # How would one interweave them efficiently?\n    # It can be assumed that length(a)==length(b).\n    c = np.empty((a.size + b.size,), dtype=a.dtype)\n    c[0::2] = a\n    c[1::2] = b\n    return c", "error": "", "token_usage": [[157, 83]], "time_usage": [2.868880271911621]}
{"task_id": "NumpyEval/85", "success": true, "generated_code": "# Find the index of the k smallest values of a numpy array\nidx = np.argpartition(A, k)[:k]", "error": "", "token_usage": [[206, 29]], "time_usage": [1.3465566635131836]}
{"task_id": "NumpyEval/86", "success": true, "generated_code": "output = np.concatenate(input_list).ravel()", "error": "", "token_usage": [[316, 14]], "time_usage": [0.9605154991149902]}
{"task_id": "NumpyEval/87", "success": true, "generated_code": "result = np.array_split(x, 3)", "error": "", "token_usage": [[159, 14]], "time_usage": [0.8373935222625732]}
{"task_id": "NumpyEval/88", "success": true, "generated_code": "# [start]\n# inv(a): Compute the (multiplicative) inverse of a matrix.\n# [end]\nimport numpy as np\n\ndef inverse_matrix(matrix):\n    # Inverse of a matrix using numpy and return it.\n    # Input:\n    #   matrix: numpy array, shape (n, n)\n    # Output:\n    #   inverse: numpy array, shape (n, n)\n    return np.linalg.inv(matrix)", "error": "", "token_usage": [[184, 93]], "time_usage": [2.933652877807617]}
{"task_id": "NumpyEval/89", "success": true, "generated_code": "# [start]\n# mean(a, axis=None, dtype=None, out=None, keepdims=False): Compute the arithmetic mean along the specified axis.\n# reshape(a, newshape, order='C'): Gives a new shape to an array without changing its data.\n# [end]\nimport numpy as np\n\ndef average_every_3_elements(arr):\n    # Averaging over every 3 elements of a numpy array\n    # I have a numpy array. I want to create a new array which is the average over every consecutive triplet of elements. So the new array will be a third of the size as the original.\n    # Return it\n    \n    # Reshape the input array to have a shape compatible with averaging over every 3 elements\n    reshaped_arr = np.reshape(arr, (-1, 3))\n    \n    # Compute the mean along the specified axis (axis=1) to get the average of every consecutive triplet of elements\n    averaged_arr = np.mean(reshaped_arr, axis=1)\n    \n    # Return the averaged array\n    return averaged_arr", "error": "", "token_usage": [[233, 224]], "time_usage": [6.025933265686035]}
{"task_id": "NumpyEval/90", "success": true, "generated_code": "# [start]\n# insert(index, object, /): Insert object before index.\n# [end]\nimport numpy as np\n\ndef prepend_element_to_array(arr, element):\n    # Prepend element to numpy array\n    # Return the array\n    return np.insert(arr, 0, element)", "error": "", "token_usage": [[152, 65]], "time_usage": [2.2164416313171387]}
{"task_id": "NumpyEval/91", "success": true, "generated_code": "# [start]\n# hstack(tup): Stack arrays in sequence horizontally (column wise).\n# [end]\nimport numpy as np\n\na = np.array([np.array([13.16]), np.array([1.58 , 1.2]), np.array([13.1]), np.array([1. , 2.6])], dtype=object)\n\nout = np.hstack(a)", "error": "", "token_usage": [[209, 85]], "time_usage": [2.7120096683502197]}
{"task_id": "NumpyEval/92", "success": true, "generated_code": "# [start]\n# searchsorted(a, v, side='left', sorter=None): Find indices where elements should be inserted to maintain order.\n# [end]\nimport numpy as np\n\nmaster = np.array([1,2,3,4,5])\nsearch = np.array([4,2,2,3])\n\n# Find indices of a list of values in a numpy array\nout = np.searchsorted(master, search, side='left')\nout", "error": "", "token_usage": [[183, 98]], "time_usage": [2.9793128967285156]}
{"task_id": "NumpyEval/93", "success": true, "generated_code": "# [start]\n# min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the minimum of an array or minimum along an axis.\n# [end]\nimport numpy as np\n\ndef get_minimum_value(arr):\n    # I wish to find and return the minimum value in this 2D array\n    # The following code is aim to implement it\n    return np.min(arr)", "error": "", "token_usage": [[188, 96]], "time_usage": [3.0291411876678467]}
{"task_id": "NumpyEval/94", "success": true, "generated_code": "import numpy as np\n\nz = np.array([0, 1, 3, 9, 18])\n# What is the inverse of the numpy cumsum function?\nz[1:] = np.diff(z)", "error": "", "token_usage": [[144, 49]], "time_usage": [1.7686412334442139]}
{"task_id": "NumpyEval/95", "success": true, "generated_code": "# [start]\n# full(shape, fill_value, dtype=None, order='C', *, like=None): Return a new array of given shape and type, filled with `fill_value`.\n# [end]\nimport numpy as np\n\n# How do I create an array where every entry is the same value?\n# I know numpy.ones() and numpy.zeros() do this for 1's and 0's, but what about -1?\n# the shape of the array is (5, 5)\nout = np.full((5, 5), -1)", "error": "", "token_usage": [[206, 119]], "time_usage": [3.4747142791748047]}
{"task_id": "NumpyEval/96", "success": true, "generated_code": "# [start]\n# delete(arr, obj, axis=None): Return a new array with sub-arrays along an axis deleted.\n# [end]\nimport numpy as np\n\na = np.arange(12).reshape(3,4)\n# Removing columns with index 1 and 3 in numpy\n# If you ever want to delete more than one columns, you just pass indices of columns you want deleted as a list to np.delete, like this:\nout = np.delete(a, [1, 3], axis=1)", "error": "", "token_usage": [[196, 112]], "time_usage": [3.557722568511963]}
{"task_id": "NumpyEval/97", "success": true, "generated_code": "D = np.isin(A, B)\nE = np.where(D)[0]\nF = np.where(np.logical_not(D))[0]", "error": "", "token_usage": [[295, 32]], "time_usage": [1.4436414241790771]}
{"task_id": "NumpyEval/98", "success": true, "generated_code": "# [start]\n# where(condition, x=<no value>, y=<no value>): Return a masked array with elements from `x` or `y`, depending on condition.\n# [end]\nimport numpy as np\n\na = np.array([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11],\n       [12, 13, 14]])\n\n# We want row with the first column value is 0\n# and the second colum value is 1\n# Maybe using np.where() is better\nb = np.where((a[:,0] == 0) & (a[:,1] == 1))[0]", "error": "", "token_usage": [[244, 169]], "time_usage": [4.793649196624756]}
{"task_id": "NumpyEval/99", "success": true, "generated_code": "import numpy as np\n\na = np.array([[[10, 1, 1, 2], [2, 2, 2, 3], [3, 3, 3, 4]],\n              [[1, 1, 1, 2], [2, 2, 2, 3], [3, 3, 3, 4]]])\n\n# Conducting the reverse operation along with the last dimension\nb = np.flip(a, axis=-1)", "error": "", "token_usage": [[200, 110]], "time_usage": [3.172199249267578]}
{"task_id": "NumpyEval/100", "success": true, "generated_code": "np.subtract(a, np.min(a, axis=0))", "error": "", "token_usage": [[209, 16]], "time_usage": [1.0693473815917969]}
{"task_id": "NumpyEval/1", "success": true, "generated_code": "c = a * b[:, None]", "error": "", "token_usage": [[190, 12]], "time_usage": [0.8914988040924072]}
{"task_id": "NumpyEval/2", "success": true, "generated_code": "c = np.reshape(a, (2, 4, 2, 4))\nc = np.transpose(c, (0, 2, 1, 3))", "error": "", "token_usage": [[241, 40]], "time_usage": [1.5207407474517822]}
{"task_id": "NumpyEval/3", "success": true, "generated_code": "import numpy as np\n\ndef get_i_th_index_in_last_dim(arr, i):\n    \"\"\"\n    I would like to slice a numpy array to obtain the i-th index in the last dimension.\n    Is there a way I can obtain this slice for any array without explicitly having to write the array dimensions?\n    There is ... or Ellipsis, which does exactly this\n    Returns: numpy array\n    \"\"\"\n    return arr[..., i]", "error": "", "token_usage": [[184, 92]], "time_usage": [3.1452417373657227]}
